 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 1 - 2023/10/26 22時18分50秒


    1/       0 :                        ;	Z8 NASCOM BASIC
    2/       0 :                        ;	Converted source code from 8080/Z80 to Z8
    3/       0 :                        ;	Assembler: Macro Assembler 1.42
    4/       0 :                        ;	Converted by Satoshi Okue
    5/       0 :                        ;	2023/10/26
    6/       0 :                        ;
    7/       0 :                        ;	EMUBASIC based on GRANT's BASIC
    8/       0 :                        ;	TARGET: EMUZ80
    9/       0 :                        ;	ASSEMBLER: ARCPIT XZ80.EXE
   10/       0 :                        ;
   11/       0 :                        ;	START UP ROUTINE
   12/       0 :                        ;	VERSION 1.0, 2022/02/15
   13/       0 :                        ;	WRITTEN by TETSUYA SUZUKI
   14/       0 :                        ;
   15/       0 :                        ;;; Functions
   16/       0 :                        lo	function	x,x & 255
   17/       0 :                        hi	function	x,(x >> 8)&255
   18/       0 :                        
   19/   0 :                            	CPU	Z8601
   20/   0 :                            
   21/   0 :                            ; Internal processor memory & SFR
   22/   0 : =0H                        P0	EQU	0	; Port 0
   23/   0 : =1H                        P1	EQU	1	; Port 1
   24/   0 : =2H                        P2	EQU	2	; Port 2
   25/   0 : =3H                        P3	EQU	3	; Port 3
   26/   0 :                            
   27/   0 : =0F0H                      SIO	EQU	0F0H	; Serial I/O
   28/   0 : =0F1H                      TMR	EQU	0F1H	; Timer	mode
   29/   0 : =0F2H                      T1	EQU	0F2H	; Timer/counter	1
   30/   0 : =0F3H                      PRE1	EQU	0F3H	; t1 prescaler
   31/   0 : =0F4H                      T0	EQU	0F4H	; Timer/counter	0
   32/   0 : =0F5H                      PRE0	EQU	0F5H	; t0 prescaler
   33/   0 : =0F6H                      P2M	EQU	0F6H	; Port 2 mode
   34/   0 : =0F7H                      P3M	EQU	0F7H	; Port 3 mode
   35/   0 : =0F8H                      P01M	EQU	0F8H	; Ports	0-1 mode
   36/   0 : =0F9H                      IPR	EQU	0F9H	; Interrupt priority register
   37/   0 : =0FAH                      IRQ	EQU	0FAH	; Interrupt request register
   38/   0 : =0FBH                      IMR	EQU	0FBH	; Interrupt mask register
   39/   0 : =0FCH                      FLAGS	EQU	0FCH	; Program control flags
   40/   0 : =0FDH                      RP	EQU	0FDH	; Register pointer
   41/   0 : =0FEH                      SPH	EQU	0FEH	; Stack pointer high
   42/   0 : =0FFH                      SPL	EQU	0FFH	; Stack pointer low
   43/   0 :                            ;
   44/   0 :                            ; Internal UART bps = CLK / SDIV0 / SDIV1 / 16 / 8
   45/   0 : =1H                        SDIV0:	EQU	1	; T0	1-256 (0 means 256)
   46/   0 : =1H                        SDIV1:	EQU	1	; PRE0	1-64 (0 means 64)
   47/   0 :                            
   48/   0 : =70H                       REGPTR	EQU	70H
   49/   0 :                            
   50/   0 :                            ;	MEMORY ASIGN
   51/   0 : =0H                        ROMTOP	EQU	0000H
   52/   0 : =8000H                     RAMTOP	EQU	8000H
   53/   0 : =80EDH                     TSTACK	EQU	80EDH
   54/   0 :                            ;
   55/   0 :                            	ORG	ROMTOP
   56/   0 :                            
   57/   0 : 00 00                      INT0:	DW	0
   58/   2 : 00 00                      INT1:	DW	0
   59/   4 : 00 00                      INT2:	DW	0
   60/   6 : 00 00                      INT3:	DW	0
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 2 - 2023/10/26 22時18分50秒


   61/   8 : 00 00                      INT4:	DW	0
   62/   A : 00 00                      INT5:	DW	0
   63/   C :                            
   64/   C : 8F                         	DI
   65/   D : E6 FD 70                   	LD	RP,#REGPTR
   66/  10 : E6 F8 B2                   	LD	P01M,#0B2H
   67/  13 : FF                         	NOP
   68/  14 : FF                         	NOP
   69/  15 : FF                         	NOP
   70/  16 : E6 FE 80                   	LD	SPH,#hi(TSTACK)
   71/  19 : E6 FF ED                   	LD	SPL,#lo(TSTACK)
   72/  1C : D6 00 22                   	CALL	CONINIT
   73/  1F : 8D 00 5C                   	JP	SINIT
   74/  22 :                            
   75/  22 :                            ;	Z8 Internal UART
   76/  22 :                            ;
   77/  22 :                            ;	UART Initialize
   78/  22 :                            CONINIT:
   79/  22 : E6 F6 00                   	LD	P2M,#00H
   80/  25 : E6 F7 41                   	LD	P3M,#41H	; NoParity
   81/  28 : E6 F4 01                   	LD	T0,#SDIV0
   82/  2B : E6 F5 05                   	LD	PRE0,#(SDIV1 << 2) + 1
   83/  2E : E6 F1 73                   	LD	TMR,#73H
   84/  31 : B0 FB                      	CLR	IMR
   85/  33 : 9F                         	EI
   86/  34 : 8F                         	DI
   87/  35 : E6 F0 0A                   	LD	SIO,#0AH
   88/  38 : 56 FA EF                   	AND	IRQ,#0EFH
   89/  3B : AF                         	RET
   90/  3C :                            ;
   91/  3C :                            ;	UART -> R0;
   92/  3C :                            CONIN:
   93/  3C : 08 FA                      	LD	R0,IRQ
   94/  3E : 56 E0 08                   	AND	R0,#08H
   95/  41 : 6B F9                      	JR	Z,CONIN
   96/  43 : 08 F0                      	LD	R0,SIO
   97/  45 : 56 FA F7                   	AND	IRQ,#0F7H
   98/  48 : AF                         	RET
   99/  49 :                            ;
  100/  49 :                            ;	CHECK RECEIVE STATUS
  101/  49 :                            CONST:
  102/  49 : 08 FA                      	LD	R0,IRQ
  103/  4B : 56 E0 08                   	AND	R0,#08H
  104/  4E : AF                         	RET
  105/  4F :                            ;
  106/  4F :                            ;	R0 -> UART
  107/  4F :                            CONOUT:
  108/  4F : 18 FA                      	LD	R1,IRQ
  109/  51 : 56 E1 10                   	AND	R1,#10H
  110/  54 : 6B F9                      	JR	Z,CONOUT
  111/  56 : 09 F0                      	LD	SIO,R0
  112/  58 : 56 FA EF                   	AND	IRQ,#0EFH
  113/  5B : AF                         	RET
  114/  5C :                            
  115/  5C :                            ;
  116/  5C :                            ; Memory Mapped UART REGISTER ADDRESS
  117/  5C : =0E000H                    UARTDR	EQU	0E000H	; UART DATA REGISTOR
  118/  5C : =0E001H                    UARTCR	EQU	0E001H	; UART CONTROL REGISTOR
  119/  5C :                            
  120/  5C :                            ;;	Memory mapped  UART
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 3 - 2023/10/26 22時18分50秒


  121/  5C :                            ;;
  122/  5C :                            ;;	UART Initialize
  123/  5C :                            ;CONINIT:
  124/  5C :                            ;	RET
  125/  5C :                            ;;
  126/  5C :                            ;;	UART -> R0
  127/  5C :                            ;CONIN:
  128/  5C :                            ;	LD	R9,#lo(UARTCR)
  129/  5C :                            ;	LD	R8,#hi(UARTCR)
  130/  5C :                            ;CONIN1:
  131/  5C :                            ;	LDC	R0,@RR8
  132/  5C :                            ;	AND	R0,#01H
  133/  5C :                            ;	JR	Z,CONIN1
  134/  5C :                            ;	LD	R9,#lo(UARTDR)
  135/  5C :                            ;	LDC	R0,@RR8
  136/  5C :                            ;	RET
  137/  5C :                            ;;
  138/  5C :                            ;;	CHECK RECEIVE STATUS
  139/  5C :                            ;CONST:
  140/  5C :                            ;	LD	R9,#lo(UARTCR)
  141/  5C :                            ;	LD	R8,#hi(UARTCR)
  142/  5C :                            ;	LDC	R0,@RR8
  143/  5C :                            ;	AND	R0,#01H
  144/  5C :                            ;	RET
  145/  5C :                            ;;
  146/  5C :                            ;;	R0 -> UART
  147/  5C :                            ;CONOUT:
  148/  5C :                            ;	LD	R9,#lo(UARTCR)
  149/  5C :                            ;	LD	R8,#hi(UARTCR)
  150/  5C :                            ;CONOUT1:
  151/  5C :                            ;	LDC	R1,@RR8
  152/  5C :                            ;	AND	R1,#02H
  153/  5C :                            ;	JR	Z,CONOUT1
  154/  5C :                            ;	LD	R9,#lo(UARTDR)
  155/  5C :                            ;	LDC	@RR8,R0
  156/  5C :                            ;	RET
  157/  5C :                            
  158/  5C :                            ;
  159/  5C :                            ;	SYSTEM INITIALIZE
  160/  5C :                            SINIT:
  161/  5C : 8D 00 5F                   	JP	COLD
  162/  5F :                            ;
  163/  5F :                            ;==================================================================================
  164/  5F :                            ; The updates to the original BASIC within this file are copyright Grant Searle
  165/  5F :                            ;
  166/  5F :                            ; You have permission to use this for NON COMMERCIAL USE ONLY
  167/  5F :                            ; If you wish to use it elsewhere, please include an acknowledgement to myself.
  168/  5F :                            ;
  169/  5F :                            ; http://searle.hostei.com/grant/index.html
  170/  5F :                            ;
  171/  5F :                            ; eMail: home.micros01@btinternet.com
  172/  5F :                            ;
  173/  5F :                            ; If the above don't work, please perform an Internet search to see if I have
  174/  5F :                            ; updated the web page hosting service.
  175/  5F :                            ;
  176/  5F :                            ;==================================================================================
  177/  5F :                            ;
  178/  5F :                            ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
  179/  5F :                            ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
  180/  5F :                            ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 4 - 2023/10/26 22時18分50秒


  181/  5F :                            ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
  182/  5F :                            ; the original ROM code (checksum A934H). PA
  183/  5F :                            ;
  184/  5F :                            ; GENERAL EQUATES
  185/  5F :                            ;
  186/  5F : =3H                        CTRLC	EQU	03H		; Control "C"
  187/  5F : =7H                        CTRLG	EQU	07H		; Control "G"
  188/  5F : =8H                        BKSP	EQU	08H		; Back space
  189/  5F : =0AH                       LF	EQU	0AH		; Line feed
  190/  5F : =0CH                       CS	EQU	0CH		; Clear screen
  191/  5F : =0DH                       CR	EQU	0DH		; Carriage return
  192/  5F : =0FH                       CTRLO	EQU	0FH		; Control "O"
  193/  5F : =11H                       CTRLQ	EQU	11H		; Control "Q"
  194/  5F : =12H                       CTRLR	EQU	12H		; Control "R"
  195/  5F : =13H                       CTRLS	EQU	13H		; Control "S"
  196/  5F : =15H                       CTRLU	EQU	15H		; Control "U"
  197/  5F : =1BH                       ESC	EQU	1BH		; Escape
  198/  5F : =7FH                       DEL	EQU	7FH		; Delete
  199/  5F :                            ;
  200/  5F :                            ; BASIC WORK SPACE LOCATIONS
  201/  5F :                            ;
  202/  5F : =8045H                     WRKSPC	EQU	RAMTOP+45H	; BASIC Work space
  203/  5F : =8048H                     USR	EQU	WRKSPC+3H	; "USR (x)" jump
  204/  5F : =804BH                     OUTSUB	EQU	WRKSPC+6H	; "OUT p,n"
  205/  5F : =804CH                     OTPORT	EQU	WRKSPC+7H	; Port (p)
  206/  5F : =804EH                     DIVSUP	EQU	WRKSPC+9H	; Division support routine
  207/  5F : =8050H                     DIV1	EQU	WRKSPC+0BH	; <- Values
  208/  5F : =8057H                     DIV2	EQU	WRKSPC+12H	; <- to
  209/  5F : =805EH                     DIV3	EQU	WRKSPC+19H	; <- be
  210/  5F : =8062H                     DIV4	EQU	WRKSPC+1DH	; <- inserted
  211/  5F : =8063H                     SEED	EQU	WRKSPC+16H+8	; Random number seed
  212/  5F : =8087H                     LSTRND	EQU	WRKSPC+3AH+8	; Last random number
  213/  5F : =808BH                     INPSUB	EQU	WRKSPC+3EH+8	; #INP (x)" Routine
  214/  5F : =808CH                     INPORT	EQU	WRKSPC+3FH+8	; PORT (x)
  215/  5F : =808EH                     NULLS	EQU	WRKSPC+41H+8	; Number of nulls
  216/  5F : =808FH                     LWIDTH	EQU	WRKSPC+42H+8	; Terminal width
  217/  5F : =8090H                     COMMAN	EQU	WRKSPC+43H+8	; Width for commas
  218/  5F : =8091H                     NULFLG	EQU	WRKSPC+44H+8	; Null after input byte flag
  219/  5F : =8092H                     CTLOFG	EQU	WRKSPC+45H+8	; Control "O" flag
  220/  5F : =8093H                     LINESC	EQU	WRKSPC+46H+8	; Lines counter
  221/  5F : =8095H                     LINESN	EQU	WRKSPC+48H+8	; Lines number
  222/  5F : =8097H                     CHKSUM	EQU	WRKSPC+4AH+8	; Array load/save check sum
  223/  5F : =8099H                     NMIFLG	EQU	WRKSPC+4CH+8	; Flag for NMI break routine
  224/  5F : =809AH                     BRKFLG	EQU	WRKSPC+4DH+8	; Break flag
  225/  5F : =809BH                     RINPUT	EQU	WRKSPC+4EH+8	; Input reflection
  226/  5F : =809EH                     POINT	EQU	WRKSPC+51H+8	; "POINT" reflection (unused)
  227/  5F : =80A1H                     PSET	EQU	WRKSPC+54H+8	; "SET"	reflection
  228/  5F : =80A4H                     RESET	EQU	WRKSPC+57H+8	; "RESET" reflection
  229/  5F : =80A7H                     STRSPC	EQU	WRKSPC+5AH+8	; Bottom of string space
  230/  5F : =80A9H                     LINEAT	EQU	WRKSPC+5CH+8	; Current line number
  231/  5F : =80ABH                     BASTXT	EQU	WRKSPC+5EH+8	; Pointer to start of program
  232/  5F : =80AEH                     BUFFER	EQU	WRKSPC+61H+8	; Input buffer
  233/  5F : =80B3H                     STACK	EQU	WRKSPC+66H+8	; Initial stack
  234/  5F : =80F8H                     CURPOS	EQU	WRKSPC+0ABH+8	; Character position on line
  235/  5F : =80F9H                     LCRFLG	EQU	WRKSPC+0ACH+8	; Locate/Create flag
  236/  5F : =80FAH                     TYPE	EQU	WRKSPC+0ADH+8	; Data type flag
  237/  5F : =80FBH                     DATFLG	EQU	WRKSPC+0AEH+8	; Literal statement flag
  238/  5F : =80FCH                     LSTRAM	EQU	WRKSPC+0AFH+8	; Last available RAM
  239/  5F : =80FEH                     TMSTPT	EQU	WRKSPC+0B1H+8	; Temporary string pointer
  240/  5F : =8100H                     TMSTPL	EQU	WRKSPC+0B3H+8	; Temporary string pool
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 5 - 2023/10/26 22時18分50秒


  241/  5F : =810CH                     TMPSTR	EQU	WRKSPC+0BFH+8	; Temporary string
  242/  5F : =8110H                     STRBOT	EQU	WRKSPC+0C3H+8	; Bottom of string space
  243/  5F : =8112H                     CUROPR	EQU	WRKSPC+0C5H+8	; Current operator in EVAL
  244/  5F : =8114H                     LOOPST	EQU	WRKSPC+0C7H+8	; First statement of loop
  245/  5F : =8116H                     DATLIN	EQU	WRKSPC+0C9H+8	; Line of current DATA item
  246/  5F : =8118H                     FORFLG	EQU	WRKSPC+0CBH+8	; "FOR" loop flag
  247/  5F : =8119H                     LSTBIN	EQU	WRKSPC+0CCH+8	; Last byte entered
  248/  5F : =811AH                     READFG	EQU	WRKSPC+0CDH+8	; Read/Input flag
  249/  5F : =811BH                     BRKLIN	EQU	WRKSPC+0CEH+8	; Line of break
  250/  5F : =811DH                     NXTOPR	EQU	WRKSPC+0D0H+8	; Next operator in EVAL
  251/  5F : =811FH                     ERRLIN	EQU	WRKSPC+0D2H+8	; Line of error
  252/  5F : =8121H                     CONTAD	EQU	WRKSPC+0D4H+8	; Where to CONTinue
  253/  5F : =8123H                     PROGND	EQU	WRKSPC+0D6H+8	; End of program
  254/  5F : =8125H                     VAREND	EQU	WRKSPC+0D8H+8	; End of variables
  255/  5F : =8127H                     ARREND	EQU	WRKSPC+0DAH+8	; End of arrays
  256/  5F : =8129H                     NXTDAT	EQU	WRKSPC+0DCH+8	; Next data item
  257/  5F : =812BH                     FNRGNM	EQU	WRKSPC+0DEH+8	; Name of FN argument
  258/  5F : =812DH                     FNARG	EQU	WRKSPC+0E0H+8	; FN argument value
  259/  5F : =8131H                     FPREG	EQU	WRKSPC+0E4H+8	; Floating point register
  260/  5F : =8134H                     FPEXP	EQU	FPREG+3		; Floating point exponent
  261/  5F : =8135H                     SGNRES	EQU	WRKSPC+0E8H+8	; Sign of result
  262/  5F : =8136H                     PBUFF	EQU	WRKSPC+0E9H+8	; Number print buffer
  263/  5F : =8143H                     MULVAL	EQU	WRKSPC+0F6H+8	; Multiplier
  264/  5F : =8146H                     PROGST	EQU	WRKSPC+0F9H+8	; Start of program text area
  265/  5F : =81AAH                     STLOOK	EQU	WRKSPC+15DH+8	; Start of memory test
  266/  5F :                            ;
  267/  5F :                            ; BASIC ERROR CODE VALUES
  268/  5F :                            ;
  269/  5F : =0H                        NF	EQU	00H		; NEXT without FOR
  270/  5F : =2H                        SN	EQU	02H		; Syntax error
  271/  5F : =4H                        RG	EQU	04H		; RETURN without GOSUB
  272/  5F : =6H                        OD	EQU	06H		; Out of DATA
  273/  5F : =8H                        FC	EQU	08H		; Function call error
  274/  5F : =0AH                       OV	EQU	0AH		; Overflow
  275/  5F : =0CH                       OM	EQU	0CH		; Out of memory
  276/  5F : =0EH                       UL	EQU	0EH		; Undefined line number
  277/  5F : =10H                       BS	EQU	10H		; Bad subscript
  278/  5F : =12H                       RD	EQU	12H		; Re-DIMensioned array
  279/  5F : =14H                       DZ	EQU	14H		; Division by zero (/0)
  280/  5F : =16H                       ID	EQU	16H		; Illegal direct
  281/  5F : =18H                       TM	EQU	18H		; Type miss-match
  282/  5F : =1AH                       OS	EQU	1AH		; Out of string space
  283/  5F : =1CH                       LS	EQU	1CH		; String too long
  284/  5F : =1EH                       ST	EQU	1EH		; String formula too complex
  285/  5F : =20H                       CN	EQU	20H		; Can't CONTinue
  286/  5F : =22H                       UF	EQU	22H		; UnDEFined FN function
  287/  5F : =24H                       MO	EQU	24H		; Missing operand
  288/  5F : =26H                       HX	EQU	26H		; HEX error
  289/  5F : =28H                       BN	EQU	28H		; BIN error
  290/  5F :                            ;
  291/  5F :                            COLD:
  292/  5F : 8D 00 65                   	JP	STARTB		; Jump for cold start
  293/  62 :                            WARM:
  294/  62 : 8D 01 31                   	JP	WARMST		; Jump for warm start
  295/  65 :                            STARTB:
  296/  65 : 8D 00 6C                   	JP	CSTART		; Jump to initialise
  297/  68 :                            ;
  298/  68 : 0F 57                      	DW	DEINT		; Get integer -32768 to 32767
  299/  6A : 1E B3                      	DW	ABPASS		; Return integer in AB
  300/  6C :                            ;
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 6 - 2023/10/26 22時18分50秒


  301/  6C :                            CSTART:
  302/  6C : 2C 80                      	LD	R2,#hi(WRKSPC)	; Start of workspace RAM
  303/  6E : 3C 45                      	LD	R3,#lo(WRKSPC)
  304/  70 : 29 FE                      	LD	SPH,R2		; Set up a temporary stack
  305/  72 : 39 FF                      	LD	SPL,R3
  306/  74 :                            
  307/  74 : 8D 36 23                   	JP	INITST		; Go to initialise
  308/  77 :                            ;
  309/  77 :                            INIT:
  310/  77 : 6C 03                      	LD	R6,#hi(INITAB)	; Initialise workspace
  311/  79 : 7C A8                      	LD	R7,#lo(INITAB)
  312/  7B : 4C 6B                      	LD	R4,#INITBE-INITAB+3; Bytes to copy
  313/  7D : 2C 80                      	LD	R2,#hi(WRKSPC)	; Into workspace RAM
  314/  7F : 3C 45                      	LD	R3,#lo(WRKSPC)
  315/  81 :                            COPY:
  316/  81 : C2 06                      	LDC	R0,@RR6		; Get source
  317/  83 : D2 02                      	LDC	@RR2,R0		; To destination
  318/  85 : A0 E2                      	INCW	RR2		; Next destination
  319/  87 : A0 E6                      	INCW	RR6		; Next source
  320/  89 : 00 E4                      	DEC	R4		; Count bytes
  321/  8B : ED 00 81                   	JP	NZ,COPY		; More to move
  322/  8E : 29 FE                      	LD	SPH,R2		; Temporary stack
  323/  90 : 39 FF                      	LD	SPL,R3
  324/  92 : D6 07 90                   	CALL	CLREG		; Clear registers and stack
  325/  95 : D6 13 1B                   	CALL	PRCRLF		; Output CRLF
  326/  98 : 8C 80                      	LD	R8,#hi(BUFFER+72+1)
  327/  9A : 9C F7                      	LD	R9,#lo(BUFFER+72+1)
  328/  9C : D2 08                      	LDC	@RR8,R0		; Mark end of buffer
  329/  9E : 8C 81                      	LD	R8,#hi(PROGST)
  330/  A0 : 9C 46                      	LD	R9,#lo(PROGST)
  331/  A2 : D2 08                      	LDC	@RR8,R0		; Initialise program area
  332/  A4 :                            MSIZE:
  333/  A4 : 2C 81                      	LD	R2,#hi(STLOOK)	; Point to start of RAM
  334/  A6 : 3C AA                      	LD	R3,#lo(STLOOK)
  335/  A8 :                            MLOOP:
  336/  A8 : 18 FC                      	LD	R1,FLAGS
  337/  AA : A0 E2                      	INCW	RR2		; Next byte
  338/  AC : 19 FC                      	LD	FLAGS,R1
  339/  AE : 08 E2                      	LD	R0,R2		; Above address FFFF ?
  340/  B0 : 42 03                      	OR	R0,R3
  341/  B2 : CF                         	RCF
  342/  B3 : 6D 00 C7                   	JP	Z,SETTOP	; Yes - 64K RAM
  343/  B6 : C2 02                      	LDC	R0,@RR2		; Get contents
  344/  B8 : 48 E0                      	LD	R4,R0		; Save it
  345/  BA : 60 E0                      	COM	R0		; Flip all bits
  346/  BC : D2 02                      	LDC	@RR2,R0		; Put it back
  347/  BE : C2 82                      	LDC	R8,@RR2
  348/  C0 : A2 08                      	CP	R0,R8		; RAM there if same
  349/  C2 : D2 42                      	LDC	@RR2,R4		; Restore old contents
  350/  C4 : 6D 00 A8                   	JP	Z,MLOOP		; If RAM - test next byte
  351/  C7 :                            SETTOP:
  352/  C7 : 18 FC                      	LD	R1,FLAGS
  353/  C9 : 80 E2                      	DECW	RR2
  354/  CB : 19 FC                      	LD	FLAGS,R1	; Back one byte
  355/  CD : 6C 81                      	LD	R6,#hi(STLOOK-1); See if enough RAM
  356/  CF : 7C A9                      	LD	R7,#lo(STLOOK-1)
  357/  D1 : D6 0A 3D                   	CALL	CPDEHL		; Compare DE with HL
  358/  D4 : 7D 01 3D                   	JP	C,NEMEM		; If not enough RAM
  359/  D7 : 6C FF                      	LD	R6,#hi(0-50)	; 50 Bytes string space
  360/  D9 : 7C CE                      	LD	R7,#lo(0-50)
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 7 - 2023/10/26 22時18分50秒


  361/  DB : 8C 80                      	LD	R8,#hi(LSTRAM)
  362/  DD : 9C FC                      	LD	R9,#lo(LSTRAM)
  363/  DF : D2 28                      	LDC	@RR8,R2		; Save last available RAM
  364/  E1 : A0 E8                      	INCW	RR8
  365/  E3 : D2 38                      	LDC	@RR8,R3
  366/  E5 : 02 37                      	ADD	R3,R7		; Allocate string space
  367/  E7 : 12 26                      	ADC	R2,R6
  368/  E9 : 8C 80                      	LD	R8,#hi(STRSPC)
  369/  EB : 9C A7                      	LD	R9,#lo(STRSPC)
  370/  ED : D2 28                      	LDC	@RR8,R2		; Save string space
  371/  EF : A0 E8                      	INCW	RR8
  372/  F1 : D2 38                      	LDC	@RR8,R3
  373/  F3 : D6 07 25                   	CALL	CLRPTR		; Clear program area
  374/  F6 : 8C 80                      	LD	R8,#hi(STRSPC)
  375/  F8 : 9C A7                      	LD	R9,#lo(STRSPC)
  376/  FA : C2 28                      	LDC	R2,@RR8		; Get end of memory
  377/  FC : A0 E8                      	INCW	RR8
  378/  FE : C2 38                      	LDC	R3,@RR8
  379/ 100 : 6C FF                      	LD	R6,#hi(0-17)	; Offset for free bytes
  380/ 102 : 7C EF                      	LD	R7,#lo(0-17)
  381/ 104 : 02 37                      	ADD	R3,R7		; Adjust HL
  382/ 106 : 12 26                      	ADC	R2,R6
  383/ 108 : 6C 81                      	LD	R6,#hi(PROGST)	; Start of program text
  384/ 10A : 7C 46                      	LD	R7,#lo(PROGST)
  385/ 10C : 08 E3                      	LD	R0,R3		; Get LSB
  386/ 10E : 22 07                      	SUB	R0,R7		; Adjust it
  387/ 110 : 38 E0                      	LD	R3,R0		; Re-save
  388/ 112 : 08 E2                      	LD	R0,R2		; Get MSB
  389/ 114 : 32 06                      	SBC	R0,R6		; Adjust it
  390/ 116 : 28 E0                      	LD	R2,R0		; Re-save
  391/ 118 : 70 E3                      	PUSH	R3		; Save bytes free
  392/ 11A : 70 E2                      	PUSH	R2
  393/ 11C : 2C 01                      	LD	R2,#hi(SIGNON)	; Sign-on message
  394/ 11E : 3C 56                      	LD	R3,#lo(SIGNON)
  395/ 120 : D6 21 02                   	CALL	PRS		; Output string
  396/ 123 : 50 E2                      	POP	R2		; Get bytes free back
  397/ 125 : 50 E3                      	POP	R3
  398/ 127 : D6 2E 8D                   	CALL	PRNTHL		; Output amount of free memory
  399/ 12A : 2C 01                      	LD	R2,#hi(BFREE)	; " Bytes free" message
  400/ 12C : 3C 47                      	LD	R3,#lo(BFREE)
  401/ 12E : D6 21 02                   	CALL	PRS		; Output string
  402/ 131 :                            ;
  403/ 131 :                            WARMST:
  404/ 131 : E6 FE 80                   	LD	SPH,#hi(STACK)	; Temporary stack
  405/ 134 : E6 FF B3                   	LD	SPL,#lo(STACK)
  406/ 137 :                            BRKRET:
  407/ 137 : D6 07 90                   	CALL	CLREG		; Clear registers and stack
  408/ 13A : 8D 05 6A                   	JP	PRNTOK		; Go to get command line
  409/ 13D :                            ;
  410/ 13D :                            NEMEM:
  411/ 13D : 2C 01                      	LD	R2,#hi(MEMMSG)	; Memory size not enough
  412/ 13F : 3C 96                      	LD	R3,#lo(MEMMSG)
  413/ 141 : D6 21 02                   	CALL	PRS		; Print it
  414/ 144 :                            XXXXX:
  415/ 144 : 8D 01 44                   	JP	XXXXX		; Stop
  416/ 147 :                            ;
  417/ 147 :                            BFREE:
  418/ 147 : 20 42 79 74 65 73 20 66 72 	DB	" Bytes free",CR,LF,0,0
       150 : 65 65 0D 0A 00 00         
  419/ 156 :                            ;
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 8 - 2023/10/26 22時18分50秒


  420/ 156 :                            SIGNON:
  421/ 156 : 5A 38 30 20 42 61 73 65 64 	DB	"Z80 Based Z8 BASIC Ver 4.7b",CR,LF
       15F : 20 5A 38 20 42 41 53 49 43
       168 : 20 56 65 72 20 34 2E 37 62
       171 : 0D 0A                     
  422/ 173 : 43 6F 70 79 72 69 67 68 74 	DB	"Copyright ",40,"C",41
       17C : 20 28 43 29               
  423/ 180 : 20 31 39 37 38 20 62 79 20 	DB	" 1978 by Microsoft",CR,LF,0,0
       189 : 4D 69 63 72 6F 73 6F 66 74
       192 : 0D 0A 00 00               
  424/ 196 :                            ;
  425/ 196 :                            MEMMSG:
  426/ 196 : 4D 65 6D 6F 72 79 20 73 69 	DB	"Memory size not enough",CR,LF
       19F : 7A 65 20 6E 6F 74 20 65 6E
       1A8 : 6F 75 67 68 0D 0A         
  427/ 1AE : 54 68 65 20 73 79 73 74 65 	DB	"The system is stopped.",CR,LF,0,0
       1B7 : 6D 20 69 73 20 73 74 6F 70
       1C0 : 70 65 64 2E 0D 0A 00 00   
  428/ 1C8 :                            ;
  429/ 1C8 :                            ; FUNCTION ADDRESS TABLE
  430/ 1C8 :                            ;
  431/ 1C8 :                            FNCTAB:
  432/ 1C8 : 2B 98                      	DW	SGN
  433/ 1CA : 2D 0C                      	DW	INT
  434/ 1CC : 2B B6                      	DW	ABS
  435/ 1CE : 80 48                      	DW	USR
  436/ 1D0 : 1E 55                      	DW	FRE
  437/ 1D2 : 26 94                      	DW	INP
  438/ 1D4 : 1E C2                      	DW	POS
  439/ 1D6 : 30 A6                      	DW	SQR
  440/ 1D8 : 32 32                      	DW	RND
  441/ 1DA : 28 FA                      	DW	LOG
  442/ 1DC : 31 4B                      	DW	EXP
  443/ 1DE : 32 ED                      	DW	COS
  444/ 1E0 : 32 F4                      	DW	SIN
  445/ 1E2 : 33 76                      	DW	TAN
  446/ 1E4 : 33 9C                      	DW	ATN
  447/ 1E6 : 27 01                      	DW	PEEK
  448/ 1E8 : 34 32                      	DW	DEEK
  449/ 1EA : 80 9E                      	DW	POINT
  450/ 1EC : 24 F0                      	DW	LEN
  451/ 1EE : 20 1F                      	DW	STR
  452/ 1F0 : 26 1F                      	DW	VAL
  453/ 1F2 : 25 0C                      	DW	ASC
  454/ 1F4 : 25 2B                      	DW	CHR
  455/ 1F6 : 34 79                      	DW	HEX
  456/ 1F8 : 35 73                      	DW	BIN
  457/ 1FA : 25 4A                      	DW	LEFT
  458/ 1FC : 25 AA                      	DW	RIGHT
  459/ 1FE : 25 BC                      	DW	MID
  460/ 200 :                            ;
  461/ 200 :                            ; RESERVED WORD LIST
  462/ 200 :                            ;
  463/ 200 :                            WORDS:
  464/ 200 : C5 4E 44                   	DB	0C5H,"ND"	; END
  465/ 203 : C6 4F 52                   	DB	0C6H,"OR"	; FOR
  466/ 206 : CE 45 58 54                	DB	0CEH,"EXT"	; NEXT
  467/ 20A : C4 41 54 41                	DB	0C4H,"ATA"	; DATA
  468/ 20E : C9 4E 50 55 54             	DB	0C9H,"NPUT"	; INPUT
  469/ 213 : C4 49 4D                   	DB	0C4H,"IM"	; DIM
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 9 - 2023/10/26 22時18分50秒


  470/ 216 : D2 45 41 44                	DB	0D2H,"EAD"	; READ
  471/ 21A : CC 45 54                   	DB	0CCH,"ET"	; LET
  472/ 21D : C7 4F 54 4F                	DB	0C7H,"OTO"	; GOTO
  473/ 221 : D2 55 4E                   	DB	0D2H,"UN"	; RUN
  474/ 224 : C9 46                      	DB	0C9H,"F"	; IF
  475/ 226 : D2 45 53 54 4F 52 45       	DB	0D2H,"ESTORE"	; RESTORE
  476/ 22D : C7 4F 53 55 42             	DB	0C7H,"OSUB"	; GOSUB
  477/ 232 : D2 45 54 55 52 4E          	DB	0D2H,"ETURN"	; RETURN
  478/ 238 : D2 45 4D                   	DB	0D2H,"EM"	; REM
  479/ 23B : D3 54 4F 50                	DB	0D3H,"TOP"	; STOP
  480/ 23F : CF 55 54                   	DB	0CFH,"UT"	; OUT
  481/ 242 : CF 4E                      	DB	0CFH,"N"	; ON
  482/ 244 : CE 55 4C 4C                	DB	0CEH,"ULL"	; NULL
  483/ 248 : D7 41 49 54                	DB	0D7H,"AIT"	; WAIT
  484/ 24C : C4 45 46                   	DB	0C4H,"EF"	; DEF
  485/ 24F : D0 4F 4B 45                	DB	0D0H,"OKE"	; POKE
  486/ 253 : C4 4F 4B 45                	DB	0C4H,"OKE"	; DOKE
  487/ 257 : D3 43 52 45 45 4E          	DB	0D3H,"CREEN"	; SCREEN
  488/ 25D : CC 49 4E 45 53             	DB	0CCH,"INES"	; LINES
  489/ 262 : C3 4C 53                   	DB	0C3H,"LS"	; CLS
  490/ 265 : D7 49 44 54 48             	DB	0D7H,"IDTH"	; WIDTH
  491/ 26A : CD 4F 4E 49 54 4F 52       	DB	0CDH,"ONITOR"	; MONITOR
  492/ 271 : D3 45 54                   	DB	0D3H,"ET"	; SET
  493/ 274 : D2 45 53 45 54             	DB	0D2H,"ESET"	; RESET
  494/ 279 : D0 52 49 4E 54             	DB	0D0H,"RINT"	; PRINT
  495/ 27E : C3 4F 4E 54                	DB	0C3H,"ONT"	; CONT
  496/ 282 : CC 49 53 54                	DB	0CCH,"IST"	; LIST
  497/ 286 : C3 4C 45 41 52             	DB	0C3H,"LEAR"	; CLEAR
  498/ 28B : C3 4C 4F 41 44             	DB	0C3H,"LOAD"	; CLOAD
  499/ 290 : C3 53 41 56 45             	DB	0C3H,"SAVE"	; CSAVE
  500/ 295 : CE 45 57                   	DB	0CEH,"EW"	; NEW
  501/ 298 :                            ;
  502/ 298 : D4 41 42 28                	DB	0D4H,"AB("	; TAB(
  503/ 29C : D4 4F                      	DB	0D4H,"O"	; TO
  504/ 29E : C6 4E                      	DB	0C6H,"N"	; FN
  505/ 2A0 : D3 50 43 28                	DB	0D3H,"PC("	; SPC(
  506/ 2A4 : D4 48 45 4E                	DB	0D4H,"HEN"	; THEN
  507/ 2A8 : CE 4F 54                   	DB	0CEH,"OT"	; NOT
  508/ 2AB : D3 54 45 50                	DB	0D3H,"TEP"	; STEP
  509/ 2AF :                            ;
  510/ 2AF : AB                         	DB	0ABH
  511/ 2B0 : AD                         	DB	0ADH
  512/ 2B1 : AA                         	DB	0AAH
  513/ 2B2 : AF                         	DB	0AFH
  514/ 2B3 : DE                         	DB	0DEH
  515/ 2B4 : C1 4E 44                   	DB	0C1H,"ND"	; AND
  516/ 2B7 : CF 52                      	DB	0CFH,"R"	; OR
  517/ 2B9 : BE                         	DB	0BEH
  518/ 2BA : BD                         	DB	0BDH
  519/ 2BB : BC                         	DB	0BCH
  520/ 2BC :                            ;
  521/ 2BC : D3 47 4E                   	DB	0D3H,"GN"	; SGN
  522/ 2BF : C9 4E 54                   	DB	0C9H,"NT"	; INT
  523/ 2C2 : C1 42 53                   	DB	0C1H,"BS"	; ABS
  524/ 2C5 : D5 53 52                   	DB	0D5H,"SR"	; USR
  525/ 2C8 : C6 52 45                   	DB	0C6H,"RE"	; FRE
  526/ 2CB : C9 4E 50                   	DB	0C9H,"NP"	; INP
  527/ 2CE : D0 4F 53                   	DB	0D0H,"OS"	; POS
  528/ 2D1 : D3 51 52                   	DB	0D3H,"QR"	; SQR
  529/ 2D4 : D2 4E 44                   	DB	0D2H,"ND"	; RND
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 10 - 2023/10/26 22時18分50秒


  530/ 2D7 : CC 4F 47                   	DB	0CCH,"OG"	; LOG
  531/ 2DA : C5 58 50                   	DB	0C5H,"XP"	; EXP
  532/ 2DD : C3 4F 53                   	DB	0C3H,"OS"	; COS
  533/ 2E0 : D3 49 4E                   	DB	0D3H,"IN"	; SIN
  534/ 2E3 : D4 41 4E                   	DB	0D4H,"AN"	; TAN
  535/ 2E6 : C1 54 4E                   	DB	0C1H,"TN"	; ATN
  536/ 2E9 : D0 45 45 4B                	DB	0D0H,"EEK"	; PEEK
  537/ 2ED : C4 45 45 4B                	DB	0C4H,"EEK"	; DEEK
  538/ 2F1 : D0 4F 49 4E 54             	DB	0D0H,"OINT"	; POINT
  539/ 2F6 : CC 45 4E                   	DB	0CCH,"EN"	; LEN
  540/ 2F9 : D3 54 52 24                	DB	0D3H,"TR$"	; STR
  541/ 2FD : D6 41 4C                   	DB	0D6H,"AL"	; VAL
  542/ 300 : C1 53 43                   	DB	0C1H,"SC"	; ASC
  543/ 303 : C3 48 52 24                	DB	0C3H,"HR$"	; CHR$
  544/ 307 : C8 45 58 24                	DB	0C8H,"EX$"	; HEX$
  545/ 30B : C2 49 4E 24                	DB	0C2H,"IN$"	; BIN$
  546/ 30F : CC 45 46 54 24             	DB	0CCH,"EFT$"	; LEFT$
  547/ 314 : D2 49 47 48 54 24          	DB	0D2H,"IGHT$"	; RIGHT$
  548/ 31A : CD 49 44 24                	DB	0CDH,"ID$"	; MID$
  549/ 31E : 80                         	DB	80H		; End of list marker
  550/ 31F :                            ;
  551/ 31F :                            ; KEYWORD ADDRESS TABLE
  552/ 31F :                            ;
  553/ 31F :                            WORDTB:
  554/ 31F : 0E 55                      	DW	PEND
  555/ 321 : 0B F8                      	DW	FOR
  556/ 323 : 15 BE                      	DW	NEXT
  557/ 325 : 11 3E                      	DW	DATA
  558/ 327 : 13 E1                      	DW	INPUT
  559/ 329 : 1A 52                      	DW	DIM
  560/ 32B : 14 28                      	DW	READ
  561/ 32D : 11 63                      	DW	LET
  562/ 32F : 10 B5                      	DW	GOTO
  563/ 331 : 10 79                      	DW	RUN
  564/ 333 : 12 4E                      	DW	IF
  565/ 335 : 0D C5                      	DW	RESTOR
  566/ 337 : 10 86                      	DW	GOSUB
  567/ 339 : 10 F2                      	DW	RETURN
  568/ 33B : 11 42                      	DW	REM
  569/ 33D : 0E 4D                      	DW	STOP
  570/ 33F : 26 A3                      	DW	POUT
  571/ 341 : 12 26                      	DW	ON
  572/ 343 : 0F 08                      	DW	NULL
  573/ 345 : 26 A9                      	DW	WAIT
  574/ 347 : 1E D0                      	DW	DEF
  575/ 349 : 27 09                      	DW	POKE
  576/ 34B : 34 4A                      	DW	DOKE
  577/ 34D : 11 42                      	DW	REM
  578/ 34F : 34 0F                      	DW	LINES
  579/ 351 : 33 FE                      	DW	CLS
  580/ 353 : 34 03                      	DW	WIDTH
  581/ 355 : 36 20                      	DW	MONITR
  582/ 357 : 80 A1                      	DW	PSET
  583/ 359 : 80 A4                      	DW	RESET
  584/ 35B : 12 76                      	DW	PRINT
  585/ 35D : 0E C4                      	DW	CONT
  586/ 35F : 0A DC                      	DW	LIST
  587/ 361 : 0F D4                      	DW	CLEAR
  588/ 363 : 11 42                      	DW	REM
  589/ 365 : 11 42                      	DW	REM
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 11 - 2023/10/26 22時18分50秒


  590/ 367 : 07 22                      	DW	NEW
  591/ 369 :                            ;
  592/ 369 :                            ; RESERVED WORD TOKEN VALUES
  593/ 369 :                            ;
  594/ 369 : =80H                       ZEND	EQU	080H		; END
  595/ 369 : =81H                       ZFOR	EQU	081H		; FOR
  596/ 369 : =83H                       ZDATA	EQU	083H		; DATA
  597/ 369 : =88H                       ZGOTO	EQU	088H		; GOTO
  598/ 369 : =8CH                       ZGOSUB	EQU	08CH		; GOSUB
  599/ 369 : =8EH                       ZREM	EQU	08EH		; REM
  600/ 369 : =9EH                       ZPRINT	EQU	09EH		; PRINT
  601/ 369 : =0A4H                      ZNEW	EQU	0A4H		; NEW
  602/ 369 :                            ;
  603/ 369 : =0A5H                      ZTAB	EQU	0A5H		; TAB
  604/ 369 : =0A6H                      ZTO	EQU	0A6H		; TO
  605/ 369 : =0A7H                      ZFN	EQU	0A7H		; FN
  606/ 369 : =0A8H                      ZSPC	EQU	0A8H		; SPC
  607/ 369 : =0A9H                      ZTHEN	EQU	0A9H		; THEN
  608/ 369 : =0AAH                      ZNOT	EQU	0AAH		; NOT
  609/ 369 : =0ABH                      ZSTEP	EQU	0ABH		; STEP
  610/ 369 :                            ;
  611/ 369 : =0ACH                      ZPLUS	EQU	0ACH		; +
  612/ 369 : =0ADH                      ZMINUS	EQU	0ADH		; -
  613/ 369 : =0AEH                      ZTIMES	EQU	0AEH		; *
  614/ 369 : =0AFH                      ZDIV	EQU	0AFH		; /
  615/ 369 : =0B2H                      ZOR	EQU	0B2H		; OR
  616/ 369 : =0B3H                      ZGTR	EQU	0B3H		; >
  617/ 369 : =0B4H                      ZEQUAL	EQU	0B4H		; M
  618/ 369 : =0B5H                      ZLTH	EQU	0B5H		; <
  619/ 369 : =0B6H                      ZSGN	EQU	0B6H		; SGN
  620/ 369 : =0C7H                      ZPOINT	EQU	0C7H		; POINT
  621/ 369 : =0CFH                      ZLEFT	EQU	0CDH +2		; LEFT$
  622/ 369 :                            ;
  623/ 369 :                            ; ARITHMETIC PRECEDENCE TABLE
  624/ 369 :                            ;
  625/ 369 :                            PRITAB:
  626/ 369 : 79                         	DB	79H		; Precedence value
  627/ 36A : 2E 5D                      	DW	PADD		; FPREG = <last> + FPREG
  628/ 36C :                            ;
  629/ 36C : 79                         	DB	79H		; Precedence value
  630/ 36D : 27 30                      	DW	PSUB		; FPREG = <last> - FPREG
  631/ 36F :                            ;
  632/ 36F : 7C                         	DB	7CH		; Precedence value
  633/ 370 : 29 78                      	DW	MULT		; PPREG = <last> * FPREG
  634/ 372 :                            ;
  635/ 372 : 7C                         	DB	7CH		; Precedence value
  636/ 373 : 2A 38                      	DW	DIV		; FPREG = <last> / FPREG
  637/ 375 :                            ;
  638/ 375 : 7F                         	DB	7FH		; Precedence value
  639/ 376 : 30 B0                      	DW	POWER		; FPREG = <last> ^ FPREG
  640/ 378 :                            ;
  641/ 378 : 50                         	DB	50H		; Precedence value
  642/ 379 : 19 00                      	DW	PAND		; FPREG = <last> AND FPREG
  643/ 37B :                            ;
  644/ 37B : 46                         	DB	46H		; Precedence value
  645/ 37C : 18 FA                      	DW	POR		; FPREG = <last> OR FPREG
  646/ 37E :                            ;
  647/ 37E :                            ; BASIC ERROR CODE LIST
  648/ 37E :                            ;
  649/ 37E :                            ERRORS:
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 12 - 2023/10/26 22時18分50秒


  650/ 37E : 4E 46                      	DB	"NF"		; NEXT without FOR
  651/ 380 : 53 4E                      	DB	"SN"		; Syntax error
  652/ 382 : 52 47                      	DB	"RG"		; RETURN without GOSUB
  653/ 384 : 4F 44                      	DB	"OD"		; Out of DATA
  654/ 386 : 46 43                      	DB	"FC"		; Illegal function call
  655/ 388 : 4F 56                      	DB	"OV"		; Overflow error
  656/ 38A : 4F 4D                      	DB	"OM"		; Out of memory
  657/ 38C : 55 4C                      	DB	"UL"		; Undefined line
  658/ 38E : 42 53                      	DB	"BS"		; Bad subscript
  659/ 390 : 44 44                      	DB	"DD"		; Re-DIMensioned array
  660/ 392 : 2F 30                      	DB	"/0"		; Division by zero
  661/ 394 : 49 44                      	DB	"ID"		; Illegal direct
  662/ 396 : 54 4D                      	DB	"TM"		; Type mis-match
  663/ 398 : 4F 53                      	DB	"OS"		; Out of string space
  664/ 39A : 4C 53                      	DB	"LS"		; String too long
  665/ 39C : 53 54                      	DB	"ST"		; String formula too complex
  666/ 39E : 43 4E                      	DB	"CN"		; Can't CONTinue
  667/ 3A0 : 55 46                      	DB	"UF"		; Undefined FN function
  668/ 3A2 : 4D 4F                      	DB	"MO"		; Missing operand
  669/ 3A4 : 48 58                      	DB	"HX"		; HEX error
  670/ 3A6 : 42 4E                      	DB	"BN"		; BIN error
  671/ 3A8 :                            ;
  672/ 3A8 :                            ; INITIALISATION TABLE -------------------------------------------------------
  673/ 3A8 :                            ;
  674/ 3A8 :                            INITAB:
  675/ 3A8 : 8D 01 31                   	JP	WARMST		; Warm start jump
  676/ 3AB : 8D 0F 7B                   	JP	FCERR		; "USR (X)" jump (Set to Error)
  677/ 3AE :                            ;  OUT	(0),A		; "OUT p,n" skeleton
  678/ 3AE : FF                         	NOP
  679/ 3AF : FF                         	NOP
  680/ 3B0 : AF                         	RET
  681/ 3B1 : 26 E0 00                   	SUB	R0,#0		; Division support routine
  682/ 3B4 : 38 E0                      	LD	R3,R0
  683/ 3B6 : 08 E2                      	LD	R0,R2
  684/ 3B8 : 36 E0 00                   	SBC	R0,#0
  685/ 3BB : 28 E0                      	LD	R2,R0
  686/ 3BD : 08 E4                      	LD	R0,R4
  687/ 3BF : 36 E0 00                   	SBC	R0,#0
  688/ 3C2 : 48 E0                      	LD	R4,R0
  689/ 3C4 : 0C 00                      	LD	R0,#0
  690/ 3C6 : AF                         	RET
  691/ 3C7 : 00 00 00                   	DB	0,0,0			; Random number seed table used by RND
  692/ 3CA : 35 4A CA 99                	DB	035H,04AH,0CAH,099H	;-2.65145E+07
  693/ 3CE : 39 1C 76 98                	DB	039H,01CH,076H,098H	; 1.61291E+07
  694/ 3D2 : 22 95 B3 98                	DB	022H,095H,0B3H,098H	;-1.17691E+07
  695/ 3D6 : 0A DD 47 98                	DB	00AH,0DDH,047H,098H	; 1.30983E+07
  696/ 3DA : 53 D1 99 99                	DB	053H,0D1H,099H,099H	;-2-01612E+07
  697/ 3DE : 0A 1A 9F 98                	DB	00AH,01AH,09FH,098H	;-1.04269E+07
  698/ 3E2 : 65 BC CD 98                	DB	065H,0BCH,0CDH,098H	;-1.34831E+07
  699/ 3E6 : D6 77 3E 98                	DB	0D6H,077H,03EH,098H	; 1.24825E+07
  700/ 3EA : 52 C7 4F 80                	DB	052H,0C7H,04FH,080H	; Last random number
  701/ 3EE :                            ;  IN	A,(0)		; INP (x) skeleton
  702/ 3EE : FF                         	NOP
  703/ 3EF : FF                         	NOP
  704/ 3F0 : AF                         	RET
  705/ 3F1 : 01                         	DB	1		; POS (x) number (1)
  706/ 3F2 : FF                         	DB	255		; Terminal width (255 = no auto CRLF)
  707/ 3F3 : 1C                         	DB	28		; Width for commas (3 columns)
  708/ 3F4 : 00                         	DB	0		; No nulls after input bytes
  709/ 3F5 : 00                         	DB	0		; Output enabled (^O off)
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 13 - 2023/10/26 22時18分50秒


  710/ 3F6 : 00 14                      	DW	20		; Initial lines counter
  711/ 3F8 : 00 14                      	DW	20		; Initial lines number
  712/ 3FA : 00 00                      	DW	0		; Array load/save check sum
  713/ 3FC : 00                         	DB	0		; Break not by NMI
  714/ 3FD : 00                         	DB	0		; Break flag
  715/ 3FE : 8D 09 7F                   	JP	TTYLIN		; Input reflection (set to TTY)
  716/ 401 : 8D 00 00                   	JP	0000H		; POINT reflection unused
  717/ 404 : 8D 00 00                   	JP	0000H		; SET reflection
  718/ 407 : 8D 00 00                   	JP	0000H			; RESET reflection
  719/ 40A : 81 AA                      	DW	STLOOK		; Temp string space
  720/ 40C : FF FE                      	DW	-2		; Current line number (cold)
  721/ 40E : 81 47                      	DW	PROGST+1	; Start of program text
  722/ 410 :                            INITBE:
  723/ 410 :                            ;
  724/ 410 :                            ; END OF INITIALISATION TABLE ---------------------------------------------------
  725/ 410 :                            ;
  726/ 410 :                            ERRMSG:
  727/ 410 : 20 45 72 72 6F 72 00       	DB	" Error",0
  728/ 417 :                            INMSG:
  729/ 417 : 20 69 6E 20 00             	DB	" in ",0
  730/ 41C : =41BH                      ZERBYT	EQU	$-1		; A zero byte
  731/ 41C :                            OKMSG:
  732/ 41C : 4F 6B 0D 0A 00 00          	DB	"Ok",CR,LF,0,0
  733/ 422 :                            BRKMSG:
  734/ 422 : 42 72 65 61 6B 00          	DB	"Break",0
  735/ 428 :                            ;
  736/ 428 :                            BAKSTK:
  737/ 428 : 2C 00                      	LD	R2,#hi(4)	; Look for "FOR" block with
  738/ 42A : 3C 04                      	LD	R3,#lo(4)
  739/ 42C : 04 FF E3                   	ADD	R3,SPL
  740/ 42F : 14 FE E2                   	ADC	R2,SPH		; same index as specified
  741/ 432 :                            LOKFOR:
  742/ 432 : C2 02                      	LDC	R0,@RR2		; Get block ID
  743/ 434 : 18 FC                      	LD	R1,FLAGS
  744/ 436 : A0 E2                      	INCW	RR2		; Point to index address
  745/ 438 : 19 FC                      	LD	FLAGS,R1
  746/ 43A : A6 E0 81                   	CP	R0,#ZFOR	; Is it a "FOR" token
  747/ 43D : 6B 01                      	JR	Z,$+3
  748/ 43F : AF                         	RET			; No - exit
  749/ 440 : C2 52                      	LDC	R5,@RR2		; BC = Address of "FOR" index
  750/ 442 : A0 E2                      	INCW	RR2
  751/ 444 : C2 42                      	LDC	R4,@RR2
  752/ 446 : A0 E2                      	INCW	RR2		; Point to sign of STEP
  753/ 448 : 70 E3                      	PUSH	R3
  754/ 44A : 70 E2                      	PUSH	R2		; Save pointer to sign
  755/ 44C : 38 E5                      	LD	R3,R5		; HL = address of "FOR" index
  756/ 44E : 28 E4                      	LD	R2,R4
  757/ 450 : 08 E6                      	LD	R0,R6		; See if an index was specified
  758/ 452 : 42 07                      	OR	R0,R7		; DE = 0 if no index specified
  759/ 454 : 88 E6                      	LD	R8,R6
  760/ 456 : 98 E7                      	LD	R9,R7
  761/ 458 : 68 E2                      	LD	R6,R2
  762/ 45A : 78 E3                      	LD	R7,R3
  763/ 45C : 28 E8                      	LD	R2,R8		; Specified index into HL
  764/ 45E : 38 E9                      	LD	R3,R9
  765/ 460 : 6D 04 72                   	JP	Z,INDFND	; Skip if no index given
  766/ 463 : 88 E6                      	LD	R8,R6
  767/ 465 : 98 E7                      	LD	R9,R7
  768/ 467 : 68 E2                      	LD	R6,R2		; Index back into DE
  769/ 469 : 78 E3                      	LD	R7,R3
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 14 - 2023/10/26 22時18分50秒


  770/ 46B : 28 E8                      	LD	R2,R8
  771/ 46D : 38 E9                      	LD	R3,R9
  772/ 46F : D6 0A 3D                   	CALL	CPDEHL		; Compare index with one given
  773/ 472 :                            INDFND:
  774/ 472 : 4C 00                      	LD	R4,#hi(16-3)	; Offset to next block
  775/ 474 : 5C 0D                      	LD	R5,#lo(16-3)
  776/ 476 : 50 E2                      	POP	R2
  777/ 478 : 50 E3                      	POP	R3		; Restore pointer to sign
  778/ 47A : EB 01                      	JR	NZ,$+3
  779/ 47C : AF                         	RET			; Return if block found
  780/ 47D : 02 35                      	ADD	R3,R5
  781/ 47F : 12 24                      	ADC	R2,R4		; Point to next block
  782/ 481 : 8D 04 32                   	JP	LOKFOR		; Keep on looking
  783/ 484 :                            ;
  784/ 484 :                            MOVUP:
  785/ 484 : D6 04 C6                   	CALL	ENFMEM		; See if enough memory
  786/ 487 :                            MOVSTR:
  787/ 487 : 70 E5                      	PUSH	R5
  788/ 489 : 70 E4                      	PUSH	R4		; Save end of source
  789/ 48B : 50 E8                      	POP	R8
  790/ 48D : 50 E9                      	POP	R9
  791/ 48F : 70 E3                      	PUSH	R3
  792/ 491 : 70 E2                      	PUSH	R2
  793/ 493 : 28 E8                      	LD	R2,R8		; Swap source and dest" end
  794/ 495 : 38 E9                      	LD	R3,R9
  795/ 497 : 50 E4                      	POP	R4
  796/ 499 : 50 E5                      	POP	R5		; Get end of destination
  797/ 49B :                            MOVLP:
  798/ 49B : D6 0A 3D                   	CALL	CPDEHL		; See if list moved
  799/ 49E : C2 02                      	LDC	R0,@RR2		; Get byte
  800/ 4A0 : D2 04                      	LDC	@RR4,R0		; Move it
  801/ 4A2 : EB 01                      	JR	NZ,$+3
  802/ 4A4 : AF                         	RET			; Exit if all done
  803/ 4A5 : 80 E4                      	DECW	RR4		; Next byte to move to
  804/ 4A7 : 80 E2                      	DECW	RR2		; Next byte to move
  805/ 4A9 : 8D 04 9B                   	JP	MOVLP		; Loop until all bytes moved
  806/ 4AC :                            ;
  807/ 4AC :                            CHKSTK:
  808/ 4AC : 70 E3                      	PUSH	R3
  809/ 4AE : 70 E2                      	PUSH	R2		; Save code string address
  810/ 4B0 : 8C 81                      	LD	R8,#hi(ARREND)
  811/ 4B2 : 9C 27                      	LD	R9,#lo(ARREND)
  812/ 4B4 : C2 28                      	LDC	R2,@RR8
  813/ 4B6 : A0 E8                      	INCW	RR8
  814/ 4B8 : C2 38                      	LDC	R3,@RR8		; Lowest free memory
  815/ 4BA : 4C 00                      	LD	R4,#0		; BC = Number of levels to test
  816/ 4BC : 02 35                      	ADD	R3,R5
  817/ 4BE : 12 24                      	ADC	R2,R4		; 2 Bytes for each level
  818/ 4C0 : 02 35                      	ADD	R3,R5
  819/ 4C2 : 12 24                      	ADC	R2,R4
  820/ 4C4 : 8B 04                      	JR	ENFMEM1		; Skip "PUSH HL"
  821/ 4C6 :                            ENFMEM:
  822/ 4C6 : 70 E3                      	PUSH	R3
  823/ 4C8 : 70 E2                      	PUSH	R2		; Save code string address
  824/ 4CA :                            ENFMEM1:
  825/ 4CA : 0C D0                      	LD	R0,#0D0H	; LOW -48; 48 Bytes minimum RAM
  826/ 4CC : 22 03                      	SUB	R0,R3
  827/ 4CE : 38 E0                      	LD	R3,R0
  828/ 4D0 : 0C FF                      	LD	R0,#0FFH	; HIGH (-48); 48 Bytes minimum RAM
  829/ 4D2 : 32 02                      	SBC	R0,R2
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 15 - 2023/10/26 22時18分50秒


  830/ 4D4 : 7D 04 E6                   	JP	C,OMERR		; Not enough - ?OM Error
  831/ 4D7 : 28 E0                      	LD	R2,R0
  832/ 4D9 : 04 FF E3                   	ADD	R3,SPL
  833/ 4DC : 14 FE E2                   	ADC	R2,SPH		; Test if stack is overflowed
  834/ 4DF : 50 E2                      	POP	R2
  835/ 4E1 : 50 E3                      	POP	R3		; Restore code string address
  836/ 4E3 : FB 01                      	JR	NC,$+3
  837/ 4E5 : AF                         	RET			; Return if enough mmory
  838/ 4E6 :                            OMERR:
  839/ 4E6 : 7C 0C                      	LD	R7,#OM		; ?OM Error
  840/ 4E8 : 8D 05 19                   	JP	ERROR
  841/ 4EB :                            ;
  842/ 4EB :                            DATSNR:
  843/ 4EB : 8C 81                      	LD	R8,#hi(DATLIN)
  844/ 4ED : 9C 16                      	LD	R9,#lo(DATLIN)
  845/ 4EF : C2 28                      	LDC	R2,@RR8
  846/ 4F1 : A0 E8                      	INCW	RR8
  847/ 4F3 : C2 38                      	LDC	R3,@RR8		; Get line of current DATA item
  848/ 4F5 : 8C 80                      	LD	R8,#hi(LINEAT)
  849/ 4F7 : 9C A9                      	LD	R9,#lo(LINEAT)
  850/ 4F9 : D2 28                      	LDC	@RR8,R2
  851/ 4FB : A0 E8                      	INCW	RR8
  852/ 4FD : D2 38                      	LDC	@RR8,R3		; Save as current line
  853/ 4FF :                            SNERR:
  854/ 4FF : 7C 02                      	LD	R7,#SN		; ?SN Error
  855/ 501 : 8B 16                      	JR	ERROR		; Skip "LD E,DZ"
  856/ 503 :                            DZERR:
  857/ 503 : 7C 14                      	LD	R7,#DZ		; ?/0 Error
  858/ 505 : 8B 12                      	JR	ERROR		; Skip "LD E,NF"
  859/ 507 :                            NFERR:
  860/ 507 : 7C 00                      	LD	R7,#NF		; ?NF Error
  861/ 509 : 8B 0E                      	JR	ERROR		; Skip "LD E,RD"
  862/ 50B :                            DDERR:
  863/ 50B : 7C 12                      	LD	R7,#RD		; ?DD Error
  864/ 50D : 8B 0A                      	JR	ERROR		; Skip "LD E,UF"
  865/ 50F :                            UFERR:
  866/ 50F : 7C 22                      	LD	R7,#UF		; ?UF Error
  867/ 511 : 8B 06                      	JR	ERROR		; Skip "LD E,OV
  868/ 513 :                            OVERR:
  869/ 513 : 7C 0A                      	LD	R7,#OV		; ?OV Error
  870/ 515 : 8B 02                      	JR	ERROR		; Skip "LD E,TM"
  871/ 517 :                            TMERR:
  872/ 517 : 7C 18                      	LD	R7,#TM		; ?TM Error
  873/ 519 :                            ;
  874/ 519 :                            ERROR:
  875/ 519 : D6 07 90                   	CALL	CLREG		; Clear registers and stack
  876/ 51C : 8C 80                      	LD	R8,#hi(CTLOFG)
  877/ 51E : 9C 92                      	LD	R9,#lo(CTLOFG)
  878/ 520 : D2 08                      	LDC	@RR8,R0		; Enable output (A is 0)
  879/ 522 : D6 13 04                   	CALL	STTLIN		; Start new line
  880/ 525 : 2C 03                      	LD	R2,#hi(ERRORS)	; Point to error codes
  881/ 527 : 3C 7E                      	LD	R3,#lo(ERRORS)
  882/ 529 : 68 E0                      	LD	R6,R0		; D = 0 (A is 0)
  883/ 52B : 0C 3F                      	LD	R0,#'?'
  884/ 52D : D6 0A 6F                   	CALL	OUTC		; Output '?'
  885/ 530 : 02 37                      	ADD	R3,R7
  886/ 532 : 12 26                      	ADC	R2,R6		; Offset to correct error code
  887/ 534 : C2 02                      	LDC	R0,@RR2		; First character
  888/ 536 : D6 0A 6F                   	CALL	OUTC		; Output it
  889/ 539 : D6 0D AD                   	CALL	GETCHR		; Get next character
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 16 - 2023/10/26 22時18分50秒


  890/ 53C : D6 0A 6F                   	CALL	OUTC		; Output it
  891/ 53F : 2C 04                      	LD	R2,#hi(ERRMSG)	; "Error" message
  892/ 541 : 3C 10                      	LD	R3,#lo(ERRMSG)
  893/ 543 :                            ERRIN:
  894/ 543 : D6 21 02                   	CALL	PRS		; Output message
  895/ 546 : 8C 80                      	LD	R8,#hi(LINEAT)
  896/ 548 : 9C A9                      	LD	R9,#lo(LINEAT)
  897/ 54A : C2 28                      	LDC	R2,@RR8
  898/ 54C : A0 E8                      	INCW	RR8
  899/ 54E : C2 38                      	LDC	R3,@RR8		; Get line of error
  900/ 550 : 6C FF                      	LD	R6,#hi(-2)
  901/ 552 : 7C FE                      	LD	R7,#lo(-2)	; Cold start error if -2
  902/ 554 : D6 0A 3D                   	CALL	CPDEHL		; See if cold start error
  903/ 557 : 6D 00 6C                   	JP	Z,CSTART	; Cold start error - Restart
  904/ 55A : 08 E2                      	LD	R0,R2		; Was it a direct error?
  905/ 55C : 52 03                      	AND	R0,R3		; Line = -1 if direct error
  906/ 55E : 0E                         	INC	R0
  907/ 55F : 6B 03                      	JR	Z,$+5
  908/ 561 : D6 2E 7E                   	CALL	LINEIN		; No - output line of error
  909/ 564 : 8B 04                      	JR	PRNTOK		; Skip "POP BC"
  910/ 566 :                            POPNOK:
  911/ 566 : 50 E4                      	POP	R4
  912/ 568 : 50 E5                      	POP	R5		; Drop address in input buffer
  913/ 56A :                            ;
  914/ 56A :                            PRNTOK:
  915/ 56A : B2 00                      	XOR	R0,R0		; Output "Ok" and get command
  916/ 56C : 8C 80                      	LD	R8,#hi(CTLOFG)
  917/ 56E : 9C 92                      	LD	R9,#lo(CTLOFG)
  918/ 570 : D2 08                      	LDC	@RR8,R0		; Enable output
  919/ 572 : D6 13 04                   	CALL	STTLIN		; Start new line
  920/ 575 : 2C 04                      	LD	R2,#hi(OKMSG)
  921/ 577 : 3C 1C                      	LD	R3,#lo(OKMSG)	; "Ok" message
  922/ 579 : D6 21 02                   	CALL	PRS		; Output "Ok"
  923/ 57C :                            GETCMD:
  924/ 57C : 2C FF                      	LD	R2,#hi(-1)	; Flag direct mode
  925/ 57E : 3C FF                      	LD	R3,#lo(-1)
  926/ 580 : 8C 80                      	LD	R8,#hi(LINEAT)
  927/ 582 : 9C A9                      	LD	R9,#lo(LINEAT)
  928/ 584 : D2 28                      	LDC	@RR8,R2
  929/ 586 : A0 E8                      	INCW	RR8
  930/ 588 : D2 38                      	LDC	@RR8,R3		; Save as current line
  931/ 58A : D6 09 7F                   	CALL	GETLIN		; Get an input line
  932/ 58D : 7D 05 7C                   	JP	C,GETCMD	; Get line again if break
  933/ 590 : D6 0D AD                   	CALL	GETCHR		; Get first character
  934/ 593 : 0E                         	INC	R0		; Test if end of line
  935/ 594 : 00 E0                      	DEC	R0		; Without affecting Carry
  936/ 596 : 6D 05 7C                   	JP	Z,GETCMD	; Nothing entered - Get another
  937/ 599 : 18 FC                      	LD	R1,FLAGS
  938/ 59B : 70 E1                      	PUSH	R1		; Save Carry status
  939/ 59D : 70 E0                      	PUSH	R0
  940/ 59F : D6 0F 80                   	CALL	ATOH		; Get line number into DE
  941/ 5A2 : 70 E7                      	PUSH	R7
  942/ 5A4 : 70 E6                      	PUSH	R6		; Save line number
  943/ 5A6 : D6 07 F0                   	CALL	CRUNCH		; Tokenise rest of line
  944/ 5A9 : 48 E0                      	LD	R4,R0		; Length of tokenised line
  945/ 5AB : 50 E6                      	POP	R6		; Restore line number
  946/ 5AD : 50 E7                      	POP	R7
  947/ 5AF : 50 E0                      	POP	R0
  948/ 5B1 : 50 E1                      	POP	R1		; Restore Carry
  949/ 5B3 : 19 FC                      	LD	FLAGS,R1
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 17 - 2023/10/26 22時18分50秒


  950/ 5B5 : FD 0D 63                   	JP	NC,EXCUTE	; No line number - Direct mode
  951/ 5B8 : 70 E7                      	PUSH	R7
  952/ 5BA : 70 E6                      	PUSH	R6		; Save line number
  953/ 5BC : 70 E5                      	PUSH	R5
  954/ 5BE : 70 E4                      	PUSH	R4		; Save length of tokenised line
  955/ 5C0 : B2 00                      	XOR	R0,R0
  956/ 5C2 : 8C 81                      	LD	R8,#hi(LSTBIN)
  957/ 5C4 : 9C 19                      	LD	R9,#lo(LSTBIN)
  958/ 5C6 : D2 08                      	LDC	@RR8,R0		; Clear last byte input
  959/ 5C8 : D6 0D AD                   	CALL	GETCHR		; Get next character
  960/ 5CB : 42 00                      	OR	R0,R0		; Set flags
  961/ 5CD : 18 FC                      	LD	R1,FLAGS
  962/ 5CF : 70 E1                      	PUSH	R1
  963/ 5D1 : 70 E0                      	PUSH	R0		; And save them
  964/ 5D3 : D6 06 D9                   	CALL	SRCHLN		; Search for line number in DE
  965/ 5D6 : 7D 05 E7                   	JP	C,LINFND	; Jump if line found
  966/ 5D9 : 50 E0                      	POP	R0
  967/ 5DB : 50 E1                      	POP	R1		; Get status
  968/ 5DD : 19 FC                      	LD	FLAGS,R1
  969/ 5DF : 70 E1                      	PUSH	R1
  970/ 5E1 : 70 E0                      	PUSH	R0		; And re-save
  971/ 5E3 : 6D 10 ED                   	JP	Z,ULERR		; Nothing after number - Error
  972/ 5E6 : CF                         	RCF			; Clear Carry
  973/ 5E7 :                            LINFND:
  974/ 5E7 : 70 E5                      	PUSH	R5
  975/ 5E9 : 70 E4                      	PUSH	R4		; Save address of line in prog
  976/ 5EB : FD 06 20                   	JP	NC,INEWLN	; Line not found - Insert new
  977/ 5EE : 88 E6                      	LD	R8,R6
  978/ 5F0 : 98 E7                      	LD	R9,R7
  979/ 5F2 : 68 E2                      	LD	R6,R2
  980/ 5F4 : 78 E3                      	LD	R7,R3
  981/ 5F6 : 28 E8                      	LD	R2,R8
  982/ 5F8 : 38 E9                      	LD	R3,R9		; Next line address in DE
  983/ 5FA : 8C 81                      	LD	R8,#hi(PROGND)
  984/ 5FC : 9C 23                      	LD	R9,#lo(PROGND)
  985/ 5FE : C2 28                      	LDC	R2,@RR8
  986/ 600 : A0 E8                      	INCW	RR8
  987/ 602 : C2 38                      	LDC	R3,@RR8		; End of program
  988/ 604 :                            SFTPRG:
  989/ 604 : C2 06                      	LDC	R0,@RR6		; Shift rest of program down
  990/ 606 : D2 04                      	LDC	@RR4,R0
  991/ 608 : A0 E4                      	INCW	RR4		; Next destination
  992/ 60A : A0 E6                      	INCW	RR6		; Next source
  993/ 60C : D6 0A 3D                   	CALL	CPDEHL		; All done?
  994/ 60F : ED 06 04                   	JP	NZ,SFTPRG	; More to do
  995/ 612 : 28 E4                      	LD	R2,R4		; HL - New end of program
  996/ 614 : 38 E5                      	LD	R3,R5
  997/ 616 : 8C 81                      	LD	R8,#hi(PROGND)
  998/ 618 : 9C 23                      	LD	R9,#lo(PROGND)
  999/ 61A : D2 28                      	LDC	@RR8,R2
 1000/ 61C : A0 E8                      	INCW	RR8
 1001/ 61E : D2 38                      	LDC	@RR8,R3		; Update end of program
 1002/ 620 :                            ;
 1003/ 620 :                            INEWLN:
 1004/ 620 : 50 E6                      	POP	R6		; Get address of line,
 1005/ 622 : 50 E7                      	POP	R7
 1006/ 624 : 50 E0                      	POP	R0
 1007/ 626 : 50 E1                      	POP	R1		; Get status
 1008/ 628 : 19 FC                      	LD	FLAGS,R1
 1009/ 62A : 6D 06 8F                   	JP	Z,SETPTR	; No text - Set up pointers
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 18 - 2023/10/26 22時18分50秒


 1010/ 62D : 8C 81                      	LD	R8,#hi(PROGND)
 1011/ 62F : 9C 23                      	LD	R9,#lo(PROGND)
 1012/ 631 : C2 28                      	LDC	R2,@RR8
 1013/ 633 : A0 E8                      	INCW	RR8
 1014/ 635 : C2 38                      	LDC	R3,@RR8		; Get end of program
 1015/ 637 : 50 E8                      	POP	R8
 1016/ 639 : 50 E9                      	POP	R9
 1017/ 63B : 70 E3                      	PUSH	R3
 1018/ 63D : 70 E2                      	PUSH	R2
 1019/ 63F : 28 E8                      	LD	R2,R8
 1020/ 641 : 38 E9                      	LD	R3,R9		; Get length of input line
 1021/ 643 : 50 E4                      	POP	R4
 1022/ 645 : 50 E5                      	POP	R5		; End of program to BC
 1023/ 647 : 02 35                      	ADD	R3,R5
 1024/ 649 : 12 24                      	ADC	R2,R4		; Find new end
 1025/ 64B : 70 E3                      	PUSH	R3
 1026/ 64D : 70 E2                      	PUSH	R2		; Save new end
 1027/ 64F : D6 04 84                   	CALL	MOVUP		; Make space for line
 1028/ 652 : 50 E2                      	POP	R2
 1029/ 654 : 50 E3                      	POP	R3		; Restore new end
 1030/ 656 : 8C 81                      	LD	R8,#hi(PROGND)
 1031/ 658 : 9C 23                      	LD	R9,#lo(PROGND)
 1032/ 65A : D2 28                      	LDC	@RR8,R2
 1033/ 65C : A0 E8                      	INCW	RR8
 1034/ 65E : D2 38                      	LDC	@RR8,R3		; Update end of program pointer
 1035/ 660 : 88 E6                      	LD	R8,R6
 1036/ 662 : 98 E7                      	LD	R9,R7
 1037/ 664 : 68 E2                      	LD	R6,R2
 1038/ 666 : 78 E3                      	LD	R7,R3
 1039/ 668 : 28 E8                      	LD	R2,R8
 1040/ 66A : 38 E9                      	LD	R3,R9		; Get line to move up in HL
 1041/ 66C : D2 22                      	LDC	@RR2,R2		; Save MSB
 1042/ 66E : 50 E6                      	POP	R6
 1043/ 670 : 50 E7                      	POP	R7		; Get new line number
 1044/ 672 : A0 E2                      	INCW	RR2		; Skip pointer
 1045/ 674 : A0 E2                      	INCW	RR2
 1046/ 676 : D2 72                      	LDC	@RR2,R7		; Save LSB of line number
 1047/ 678 : A0 E2                      	INCW	RR2
 1048/ 67A : D2 62                      	LDC	@RR2,R6		; Save MSB of line number
 1049/ 67C : A0 E2                      	INCW	RR2		; To first byte in line
 1050/ 67E : 6C 80                      	LD	R6,#hi(BUFFER)
 1051/ 680 : 7C AE                      	LD	R7,#lo(BUFFER)	; Copy buffer to program
 1052/ 682 :                            MOVBUF:
 1053/ 682 : C2 06                      	LDC	R0,@RR6		; Get source
 1054/ 684 : D2 02                      	LDC	@RR2,R0		; Save destinations
 1055/ 686 : A0 E2                      	INCW	RR2		; Next source
 1056/ 688 : A0 E6                      	INCW	RR6		; Next destination
 1057/ 68A : 42 00                      	OR	R0,R0		; Done?
 1058/ 68C : ED 06 82                   	JP	NZ,MOVBUF	; No - Repeat
 1059/ 68F :                            SETPTR:
 1060/ 68F : D6 07 43                   	CALL	RUNFST		; Set line pointers
 1061/ 692 : A0 E2                      	INCW	RR2		; To LSB of pointer
 1062/ 694 : 88 E6                      	LD	R8,R6
 1063/ 696 : 98 E7                      	LD	R9,R7
 1064/ 698 : 68 E2                      	LD	R6,R2
 1065/ 69A : 78 E3                      	LD	R7,R3
 1066/ 69C : 28 E8                      	LD	R2,R8
 1067/ 69E : 38 E9                      	LD	R3,R9		; Address to DE
 1068/ 6A0 :                            PTRLP:
 1069/ 6A0 : 28 E6                      	LD	R2,R6		; Address to HL
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 19 - 2023/10/26 22時18分50秒


 1070/ 6A2 : 38 E7                      	LD	R3,R7
 1071/ 6A4 : C2 02                      	LDC	R0,@RR2		; Get LSB of pointer
 1072/ 6A6 : A0 E2                      	INCW	RR2		; To MSB of pointer
 1073/ 6A8 : C2 12                      	LDC	R1,@RR2
 1074/ 6AA : 42 01                      	OR	R0,R1		; Compare with MSB pointer
 1075/ 6AC : 6D 05 7C                   	JP	Z,GETCMD	; Get command line if end
 1076/ 6AF : A0 E2                      	INCW	RR2		; To LSB of line number
 1077/ 6B1 : A0 E2                      	INCW	RR2		; Skip line number
 1078/ 6B3 : A0 E2                      	INCW	RR2		; Point to first byte in line
 1079/ 6B5 : B2 00                      	XOR	R0,R0		; Looking for 00 byte
 1080/ 6B7 :                            FNDEND:
 1081/ 6B7 : C2 82                      	LDC	R8,@RR2
 1082/ 6B9 : A2 08                      	CP	R0,R8		; Found end of line?
 1083/ 6BB : 18 FC                      	LD	R1,FLAGS
 1084/ 6BD : A0 E2                      	INCW	RR2		; Move to next byte
 1085/ 6BF : 19 FC                      	LD	FLAGS,R1
 1086/ 6C1 : ED 06 B7                   	JP	NZ,FNDEND	; No - Keep looking
 1087/ 6C4 : 88 E6                      	LD	R8,R6
 1088/ 6C6 : 98 E7                      	LD	R9,R7
 1089/ 6C8 : 68 E2                      	LD	R6,R2
 1090/ 6CA : 78 E3                      	LD	R7,R3
 1091/ 6CC : 28 E8                      	LD	R2,R8
 1092/ 6CE : 38 E9                      	LD	R3,R9		; Next line address to HL
 1093/ 6D0 : D2 72                      	LDC	@RR2,R7		; Save LSB of pointer
 1094/ 6D2 : A0 E2                      	INCW	RR2
 1095/ 6D4 : D2 62                      	LDC	@RR2,R6		; Save MSB of pointer
 1096/ 6D6 : 8D 06 A0                   	JP	PTRLP		; Do next line
 1097/ 6D9 :                            ;
 1098/ 6D9 :                            SRCHLN:
 1099/ 6D9 : 8C 80                      	LD	R8,#hi(BASTXT)
 1100/ 6DB : 9C AB                      	LD	R9,#lo(BASTXT)
 1101/ 6DD : C2 28                      	LDC	R2,@RR8
 1102/ 6DF : A0 E8                      	INCW	RR8
 1103/ 6E1 : C2 38                      	LDC	R3,@RR8		; Start of program text
 1104/ 6E3 :                            SRCHLP:
 1105/ 6E3 : 48 E2                      	LD	R4,R2		; BC = Address to look at
 1106/ 6E5 : 58 E3                      	LD	R5,R3
 1107/ 6E7 : C2 02                      	LDC	R0,@RR2		; Get address of next line
 1108/ 6E9 : A0 E2                      	INCW	RR2
 1109/ 6EB : C2 12                      	LDC	R1,@RR2
 1110/ 6ED : 42 01                      	OR	R0,R1		; End of program found?
 1111/ 6EF : 18 FC                      	LD	R1,FLAGS
 1112/ 6F1 : 80 E2                      	DECW	RR2
 1113/ 6F3 : 19 FC                      	LD	FLAGS,R1
 1114/ 6F5 : EB 01                      	JR	NZ,$+3
 1115/ 6F7 : AF                         	RET			; Yes - Line not found
 1116/ 6F8 : A0 E2                      	INCW	RR2
 1117/ 6FA : A0 E2                      	INCW	RR2
 1118/ 6FC : C2 02                      	LDC	R0,@RR2		; Get LSB of line number
 1119/ 6FE : A0 E2                      	INCW	RR2
 1120/ 700 : C2 22                      	LDC	R2,@RR2		; Get MSB of line number
 1121/ 702 : 38 E0                      	LD	R3,R0
 1122/ 704 : D6 0A 3D                   	CALL	CPDEHL		; Compare with line in DE
 1123/ 707 : 28 E4                      	LD	R2,R4		; HL = Start of this line
 1124/ 709 : 38 E5                      	LD	R3,R5
 1125/ 70B : C2 02                      	LDC	R0,@RR2		; Get LSB of next line address
 1126/ 70D : 18 FC                      	LD	R1,FLAGS
 1127/ 70F : A0 E2                      	INCW	RR2
 1128/ 711 : 19 FC                      	LD	FLAGS,R1
 1129/ 713 : C2 22                      	LDC	R2,@RR2		; Get MSB of next line address
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 20 - 2023/10/26 22時18分50秒


 1130/ 715 : 38 E0                      	LD	R3,R0		; Next line to HL
 1131/ 717 : EF                         	CCF
 1132/ 718 : EB 01                      	JR	NZ,$+3
 1133/ 71A : AF                         	RET			; Lines found - Exit
 1134/ 71B : EF                         	CCF
 1135/ 71C : 7B 01                      	JR	C,$+3
 1136/ 71E : AF                         	RET			; Line not found,at line after
 1137/ 71F : 8D 06 E3                   	JP	SRCHLP		; Keep looking
 1138/ 722 :                            ;
 1139/ 722 :                            NEW:
 1140/ 722 : 6B 01                      	JR	Z,$+3
 1141/ 724 : AF                         	RET			; Return if any more on line
 1142/ 725 :                            CLRPTR:
 1143/ 725 : 8C 80                      	LD	R8,#hi(BASTXT)
 1144/ 727 : 9C AB                      	LD	R9,#lo(BASTXT)
 1145/ 729 : C2 28                      	LDC	R2,@RR8
 1146/ 72B : A0 E8                      	INCW	RR8
 1147/ 72D : C2 38                      	LDC	R3,@RR8		; Point to start of program
 1148/ 72F : B2 00                      	XOR	R0,R0		; Set program area to empty
 1149/ 731 : D2 02                      	LDC	@RR2,R0		; Save LSB = 00
 1150/ 733 : A0 E2                      	INCW	RR2
 1151/ 735 : D2 02                      	LDC	@RR2,R0		; Save MSB = 00
 1152/ 737 : A0 E2                      	INCW	RR2
 1153/ 739 : 8C 81                      	LD	R8,#hi(PROGND)
 1154/ 73B : 9C 23                      	LD	R9,#lo(PROGND)
 1155/ 73D : D2 28                      	LDC	@RR8,R2
 1156/ 73F : A0 E8                      	INCW	RR8
 1157/ 741 : D2 38                      	LDC	@RR8,R3		; Set program end
 1158/ 743 :                            ;
 1159/ 743 :                            RUNFST:
 1160/ 743 : 8C 80                      	LD	R8,#hi(BASTXT)
 1161/ 745 : 9C AB                      	LD	R9,#lo(BASTXT)
 1162/ 747 : C2 28                      	LDC	R2,@RR8
 1163/ 749 : A0 E8                      	INCW	RR8
 1164/ 74B : C2 38                      	LDC	R3,@RR8		; Clear all variables
 1165/ 74D : 80 E2                      	DECW	RR2
 1166/ 74F :                            ;
 1167/ 74F :                            INTVAR:
 1168/ 74F : 8C 81                      	LD	R8,#hi(BRKLIN)
 1169/ 751 : 9C 1B                      	LD	R9,#lo(BRKLIN)
 1170/ 753 : D2 28                      	LDC	@RR8,R2
 1171/ 755 : A0 E8                      	INCW	RR8
 1172/ 757 : D2 38                      	LDC	@RR8,R3		; Initialise RUN variables
 1173/ 759 : 8C 80                      	LD	R8,#hi(LSTRAM)
 1174/ 75B : 9C FC                      	LD	R9,#lo(LSTRAM)
 1175/ 75D : C2 28                      	LDC	R2,@RR8
 1176/ 75F : A0 E8                      	INCW	RR8
 1177/ 761 : C2 38                      	LDC	R3,@RR8		; Get end of RAM
 1178/ 763 : 8C 81                      	LD	R8,#hi(STRBOT)
 1179/ 765 : 9C 10                      	LD	R9,#lo(STRBOT)
 1180/ 767 : D2 28                      	LDC	@RR8,R2
 1181/ 769 : A0 E8                      	INCW	RR8
 1182/ 76B : D2 38                      	LDC	@RR8,R3		; Clear string space
 1183/ 76D : B2 00                      	XOR	R0,R0
 1184/ 76F : D6 0D C5                   	CALL	RESTOR		; Reset DATA pointers
 1185/ 772 : 8C 81                      	LD	R8,#hi(PROGND)
 1186/ 774 : 9C 23                      	LD	R9,#lo(PROGND)
 1187/ 776 : C2 28                      	LDC	R2,@RR8
 1188/ 778 : A0 E8                      	INCW	RR8
 1189/ 77A : C2 38                      	LDC	R3,@RR8		; Get end of program
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 21 - 2023/10/26 22時18分50秒


 1190/ 77C : 8C 81                      	LD	R8,#hi(VAREND)
 1191/ 77E : 9C 25                      	LD	R9,#lo(VAREND)
 1192/ 780 : D2 28                      	LDC	@RR8,R2
 1193/ 782 : A0 E8                      	INCW	RR8
 1194/ 784 : D2 38                      	LDC	@RR8,R3		; Clear variables
 1195/ 786 : 8C 81                      	LD	R8,#hi(ARREND)
 1196/ 788 : 9C 27                      	LD	R9,#lo(ARREND)
 1197/ 78A : D2 28                      	LDC	@RR8,R2
 1198/ 78C : A0 E8                      	INCW	RR8
 1199/ 78E : D2 38                      	LDC	@RR8,R3		; Clear arrays
 1200/ 790 :                            ;
 1201/ 790 :                            CLREG:
 1202/ 790 : 50 E4                      	POP	R4
 1203/ 792 : 50 E5                      	POP	R5		; Save return address
 1204/ 794 : 8C 80                      	LD	R8,#hi(STRSPC)
 1205/ 796 : 9C A7                      	LD	R9,#lo(STRSPC)
 1206/ 798 : C2 28                      	LDC	R2,@RR8
 1207/ 79A : A0 E8                      	INCW	RR8
 1208/ 79C : C2 38                      	LDC	R3,@RR8		; Get end of working RAN
 1209/ 79E : 29 FE                      	LD	SPH,R2		; Set stack
 1210/ 7A0 : 39 FF                      	LD	SPL,R3
 1211/ 7A2 : 2C 81                      	LD	R2,#hi(TMSTPL)
 1212/ 7A4 : 3C 00                      	LD	R3,#lo(TMSTPL)	; Temporary string pool
 1213/ 7A6 : 8C 80                      	LD	R8,#hi(TMSTPT)
 1214/ 7A8 : 9C FE                      	LD	R9,#lo(TMSTPT)
 1215/ 7AA : D2 28                      	LDC	@RR8,R2
 1216/ 7AC : A0 E8                      	INCW	RR8
 1217/ 7AE : D2 38                      	LDC	@RR8,R3		; Reset temporary string ptr
 1218/ 7B0 : B2 00                      	XOR	R0,R0		; A = 00
 1219/ 7B2 : 38 E0                      	LD	R3,R0		; HL = 0000
 1220/ 7B4 : 28 E0                      	LD	R2,R0
 1221/ 7B6 : 8C 81                      	LD	R8,#hi(CONTAD)
 1222/ 7B8 : 9C 21                      	LD	R9,#lo(CONTAD)
 1223/ 7BA : D2 28                      	LDC	@RR8,R2
 1224/ 7BC :                            ;	LD	R1,FLAGS
 1225/ 7BC : A0 E8                      	INCW	RR8
 1226/ 7BE :                            ;	LD	FLAGS,R1
 1227/ 7BE : D2 38                      	LDC	@RR8,R3		; No CONTinue
 1228/ 7C0 : 8C 81                      	LD	R8,#hi(FORFLG)
 1229/ 7C2 : 9C 18                      	LD	R9,#lo(FORFLG)
 1230/ 7C4 : D2 08                      	LDC	@RR8,R0		; Clear FOR flag
 1231/ 7C6 : 8C 81                      	LD	R8,#hi(FNRGNM)
 1232/ 7C8 : 9C 2B                      	LD	R9,#lo(FNRGNM)
 1233/ 7CA : D2 28                      	LDC	@RR8,R2
 1234/ 7CC :                            ;	LD	R1,FLAGS
 1235/ 7CC : A0 E8                      	INCW	RR8
 1236/ 7CE :                            ;	LD	FLAGS,R1
 1237/ 7CE : D2 38                      	LDC	@RR8,R3		; Clear FN argument
 1238/ 7D0 : 70 E3                      	PUSH	R3
 1239/ 7D2 : 70 E2                      	PUSH	R2		; HL = 0000
 1240/ 7D4 : 70 E5                      	PUSH	R5
 1241/ 7D6 : 70 E4                      	PUSH	R4		; Put back return
 1242/ 7D8 :                            DOAGN:
 1243/ 7D8 : 8C 81                      	LD	R8,#hi(BRKLIN)
 1244/ 7DA : 9C 1B                      	LD	R9,#lo(BRKLIN)
 1245/ 7DC : C2 28                      	LDC	R2,@RR8
 1246/ 7DE :                            ;	LD	R1,FLAGS
 1247/ 7DE : A0 E8                      	INCW	RR8
 1248/ 7E0 :                            ;	LD	FLAGS,R1
 1249/ 7E0 : C2 38                      	LDC	R3,@RR8		; Get address of code to RUN
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 22 - 2023/10/26 22時18分50秒


 1250/ 7E2 : AF                         	RET			; Return to execution driver
 1251/ 7E3 :                            ;
 1252/ 7E3 :                            PROMPT:
 1253/ 7E3 : 0C 3F                      	LD	R0,#'?'		; '?'
 1254/ 7E5 : D6 0A 6F                   	CALL	OUTC		; Output character
 1255/ 7E8 : 0C 20                      	LD	R0,#' '		; Space
 1256/ 7EA : D6 0A 6F                   	CALL	OUTC		; Output character
 1257/ 7ED : 8D 80 9B                   	JP	RINPUT		; Get input line
 1258/ 7F0 :                            ;
 1259/ 7F0 :                            CRUNCH:
 1260/ 7F0 : B2 00                      	XOR	R0,R0		; Tokenise line @ HL to BUFFER
 1261/ 7F2 : 8C 80                      	LD	R8,#hi(DATFLG)
 1262/ 7F4 : 9C FB                      	LD	R9,#lo(DATFLG)
 1263/ 7F6 : D2 08                      	LDC	@RR8,R0		; Reset literal flag
 1264/ 7F8 : 5C 05                      	LD	R5,#2+3		; 2 byte number and 3 nulls
 1265/ 7FA : 6C 80                      	LD	R6,#hi(BUFFER)
 1266/ 7FC : 7C AE                      	LD	R7,#lo(BUFFER)	; Start of input buffer
 1267/ 7FE :                            CRNCLP:
 1268/ 7FE : C2 02                      	LDC	R0,@RR2		; Get byte
 1269/ 800 : A6 E0 20                   	CP	R0,#' '		; Is it a space?
 1270/ 803 : 6D 08 F0                   	JP	Z,MOVDIR	; Yes - Copy direct
 1271/ 806 : 48 E0                      	LD	R4,R0		; Save character
 1272/ 808 : A6 E0 22                   	CP	R0,#'"'		; Is it a quote?
 1273/ 80B : 6D 09 1E                   	JP	Z,CPYLIT	; Yes - Copy literal string
 1274/ 80E : 42 00                      	OR	R0,R0		; Is it end of buffer?
 1275/ 810 : 6D 09 28                   	JP	Z,ENDBUF	; Yes - End buffer
 1276/ 813 : 8C 80                      	LD	R8,#hi(DATFLG)
 1277/ 815 : 9C FB                      	LD	R9,#lo(DATFLG)
 1278/ 817 : C2 08                      	LDC	R0,@RR8		; Get data type
 1279/ 819 : 42 00                      	OR	R0,R0		; Literal?
 1280/ 81B : C2 02                      	LDC	R0,@RR2		; Get byte to copy
 1281/ 81D : ED 08 F0                   	JP	NZ,MOVDIR	; Literal - Copy direct
 1282/ 820 : A6 E0 3F                   	CP	R0,#'?'		; Is it '?' short for PRINT
 1283/ 823 : 0C 9E                      	LD	R0,#ZPRINT	; "PRINT" token
 1284/ 825 : 6D 08 F0                   	JP	Z,MOVDIR	; Yes - replace it
 1285/ 828 : C2 02                      	LDC	R0,@RR2		; Get byte again
 1286/ 82A : A6 E0 30                   	CP	R0,#'0'		; Is it less than '0'
 1287/ 82D : 7D 08 36                   	JP	C,FNDWRD	; Yes - Look for reserved words
 1288/ 830 : A6 E0 3C                   	CP	R0,#60		; ";"+1; Is it "0123456789:;" ?
 1289/ 833 : 7D 08 F0                   	JP	C,MOVDIR	; Yes - copy it direct
 1290/ 836 :                            FNDWRD:
 1291/ 836 : 70 E7                      	PUSH	R7
 1292/ 838 : 70 E6                      	PUSH	R6		; Look for reserved words
 1293/ 83A : 6C 01                      	LD	R6,#hi(WORDS-1)
 1294/ 83C : 7C FF                      	LD	R7,#lo(WORDS-1)	; Point to table
 1295/ 83E : 70 E5                      	PUSH	R5
 1296/ 840 : 70 E4                      	PUSH	R4		; Save count
 1297/ 842 : 4C 08                      	LD	R4,#hi(RETNAD)
 1298/ 844 : 5C DA                      	LD	R5,#lo(RETNAD)	; Where to return to
 1299/ 846 : 70 E5                      	PUSH	R5
 1300/ 848 : 70 E4                      	PUSH	R4		; Save return address
 1301/ 84A : 4C 7F                      	LD	R4,#ZEND-1	; First token value -1
 1302/ 84C : C2 02                      	LDC	R0,@RR2		; Get byte
 1303/ 84E : A6 E0 61                   	CP	R0,#'a'		; Less than 'a' ?
 1304/ 851 : 7D 08 5F                   	JP	C,SEARCH	; Yes - search for words
 1305/ 854 : A6 E0 7B                   	CP	R0,#'z'+1	; Greater than 'z' ?
 1306/ 857 : FD 08 5F                   	JP	NC,SEARCH	; Yes - search for words
 1307/ 85A : 56 E0 5F                   	AND	R0,#01011111B	; Force upper case
 1308/ 85D : D2 02                      	LDC	@RR2,R0		; Replace byte
 1309/ 85F :                            SEARCH:
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 23 - 2023/10/26 22時18分50秒


 1310/ 85F : C2 52                      	LDC	R5,@RR2		; Search for a word
 1311/ 861 : 88 E6                      	LD	R8,R6
 1312/ 863 : 98 E7                      	LD	R9,R7
 1313/ 865 : 68 E2                      	LD	R6,R2
 1314/ 867 : 78 E3                      	LD	R7,R3
 1315/ 869 : 28 E8                      	LD	R2,R8
 1316/ 86B : 38 E9                      	LD	R3,R9
 1317/ 86D :                            GETNXT:
 1318/ 86D : A0 E2                      	INCW	RR2		; Get next reserved word
 1319/ 86F : C2 12                      	LDC	R1,@RR2
 1320/ 871 : 42 01                      	OR	R0,R1		; Start of word?
 1321/ 873 : DD 08 6D                   	JP	PL,GETNXT	; No - move on
 1322/ 876 : 4E                         	INC	R4		; Increment token value
 1323/ 877 : C2 02                      	LDC	R0,@RR2		; Get byte from table
 1324/ 879 : 56 E0 7F                   	AND	R0,#01111111B	; Strip bit 7
 1325/ 87C : EB 01                      	JR	NZ,$+3
 1326/ 87E : AF                         	RET			; Return if end of list
 1327/ 87F : A2 05                      	CP	R0,R5		; Same character as in buffer?
 1328/ 881 : ED 08 6D                   	JP	NZ,GETNXT	; No - get next word
 1329/ 884 : 88 E6                      	LD	R8,R6
 1330/ 886 : 98 E7                      	LD	R9,R7
 1331/ 888 : 68 E2                      	LD	R6,R2
 1332/ 88A : 78 E3                      	LD	R7,R3
 1333/ 88C : 28 E8                      	LD	R2,R8
 1334/ 88E : 38 E9                      	LD	R3,R9
 1335/ 890 : 70 E3                      	PUSH	R3
 1336/ 892 : 70 E2                      	PUSH	R2		; Save start of word
 1337/ 894 :                            ;
 1338/ 894 :                            NXTBYT:
 1339/ 894 : A0 E6                      	INCW	RR6		; Look through rest of word
 1340/ 896 : C2 06                      	LDC	R0,@RR6		; Get byte from table
 1341/ 898 : 42 00                      	OR	R0,R0		; End of word ?
 1342/ 89A : 5D 08 C5                   	JP	MI,MATCH	; Yes - Match found
 1343/ 89D : 58 E0                      	LD	R5,R0		; Save it
 1344/ 89F : 08 E4                      	LD	R0,R4		; Get token value
 1345/ 8A1 : A6 E0 88                   	CP	R0,#ZGOTO	; Is it "GOTO" token ?
 1346/ 8A4 : ED 08 AC                   	JP	NZ,NOSPC	; No - Don't allow spaces
 1347/ 8A7 : D6 0D AD                   	CALL	GETCHR		; Get next character
 1348/ 8AA : 80 E2                      	DECW	RR2		; Cancel increment from GETCHR
 1349/ 8AC :                            NOSPC:
 1350/ 8AC : A0 E2                      	INCW	RR2		; Next byte
 1351/ 8AE : C2 02                      	LDC	R0,@RR2		; Get byte
 1352/ 8B0 : A6 E0 61                   	CP	R0,#'a'		; Less than 'a' ?
 1353/ 8B3 : 7D 08 B9                   	JP	C,NOCHNG	; Yes - don't change
 1354/ 8B6 : 56 E0 5F                   	AND	R0,#01011111B	; Make upper case
 1355/ 8B9 :                            NOCHNG:
 1356/ 8B9 : A2 05                      	CP	R0,R5		; Same as in buffer ?
 1357/ 8BB : 6D 08 94                   	JP	Z,NXTBYT	; Yes - keep testing
 1358/ 8BE : 50 E2                      	POP	R2		; Get back start of word
 1359/ 8C0 : 50 E3                      	POP	R3
 1360/ 8C2 : 8D 08 5F                   	JP	SEARCH		; Look at next word
 1361/ 8C5 :                            ;
 1362/ 8C5 :                            MATCH:
 1363/ 8C5 : 58 E4                      	LD	R5,R4		; Word found - Save token value
 1364/ 8C7 : 50 E0                      	POP	R0		; Throw away return
 1365/ 8C9 : 50 E1                      	POP	R1
 1366/ 8CB : 19 FC                      	LD	FLAGS,R1
 1367/ 8CD : 88 E6                      	LD	R8,R6
 1368/ 8CF : 98 E7                      	LD	R9,R7
 1369/ 8D1 : 68 E2                      	LD	R6,R2
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 24 - 2023/10/26 22時18分50秒


 1370/ 8D3 : 78 E3                      	LD	R7,R3
 1371/ 8D5 : 28 E8                      	LD	R2,R8
 1372/ 8D7 : 38 E9                      	LD	R3,R9
 1373/ 8D9 : AF                         	RET			; Return to "RETNAD"
 1374/ 8DA :                            RETNAD:
 1375/ 8DA : 88 E6                      	LD	R8,R6
 1376/ 8DC : 98 E7                      	LD	R9,R7
 1377/ 8DE : 68 E2                      	LD	R6,R2
 1378/ 8E0 : 78 E3                      	LD	R7,R3
 1379/ 8E2 : 28 E8                      	LD	R2,R8
 1380/ 8E4 : 38 E9                      	LD	R3,R9		; Get address in string
 1381/ 8E6 : 08 E5                      	LD	R0,R5		; Get token value
 1382/ 8E8 : 50 E4                      	POP	R4
 1383/ 8EA : 50 E5                      	POP	R5		; Restore buffer length
 1384/ 8EC : 50 E6                      	POP	R6
 1385/ 8EE : 50 E7                      	POP	R7		; Get destination address
 1386/ 8F0 :                            MOVDIR:
 1387/ 8F0 : A0 E2                      	INCW	RR2		; Next source in buffer
 1388/ 8F2 : D2 06                      	LDC	@RR6,R0		; Put byte in buffer
 1389/ 8F4 : A0 E6                      	INCW	RR6		; Move up buffer
 1390/ 8F6 : 5E                         	INC	R5		; Increment length of buffer
 1391/ 8F7 : 26 E0 3A                   	SUB	R0,#':'		; End of statement?
 1392/ 8FA : 6D 09 03                   	JP	Z,SETLIT	; Jump if multi-statement line
 1393/ 8FD : A6 E0 49                   	CP	R0,#ZDATA-3AH	; Is it DATA statement ?
 1394/ 900 : ED 09 09                   	JP	NZ,TSTREM	; No - see if REM
 1395/ 903 :                            SETLIT:
 1396/ 903 : 8C 80                      	LD	R8,#hi(DATFLG)
 1397/ 905 : 9C FB                      	LD	R9,#lo(DATFLG)
 1398/ 907 : D2 08                      	LDC	@RR8,R0		; Set literal flag
 1399/ 909 :                            TSTREM:
 1400/ 909 : 26 E0 54                   	SUB	R0,#ZREM-3AH	; Is it REM?
 1401/ 90C : ED 07 FE                   	JP	NZ,CRNCLP	; No - Leave flag
 1402/ 90F : 48 E0                      	LD	R4,R0		; Copy rest of buffer
 1403/ 911 :                            NXTCHR:
 1404/ 911 : C2 02                      	LDC	R0,@RR2		; Get byte
 1405/ 913 : 42 00                      	OR	R0,R0
 1406/ 915 : CF                         	RCF			; End of line ?
 1407/ 916 : 6D 09 28                   	JP	Z,ENDBUF	; Yes - Terminate buffer
 1408/ 919 : A2 04                      	CP	R0,R4		; End of statement ?
 1409/ 91B : 6D 08 F0                   	JP	Z,MOVDIR	; Yes - Get next one
 1410/ 91E :                            CPYLIT:
 1411/ 91E : A0 E2                      	INCW	RR2		; Move up source string
 1412/ 920 : D2 06                      	LDC	@RR6,R0		; Save in destination
 1413/ 922 : 5E                         	INC	R5		; Increment length
 1414/ 923 : A0 E6                      	INCW	RR6		; Move up destination
 1415/ 925 : 8D 09 11                   	JP	NXTCHR		; Repeat
 1416/ 928 :                            ;
 1417/ 928 :                            ENDBUF:
 1418/ 928 : 2C 80                      	LD	R2,#hi(BUFFER-1)
 1419/ 92A : 3C AD                      	LD	R3,#lo(BUFFER-1); Point to start of buffer
 1420/ 92C : D2 06                      	LDC	@RR6,R0		; Mark end of buffer (A = 00)
 1421/ 92E :                            ;	LD	R1,FLAGS
 1422/ 92E : A0 E6                      	INCW	RR6
 1423/ 930 :                            ;	LD	FLAGS,R1
 1424/ 930 : D2 06                      	LDC	@RR6,R0		; A = 00
 1425/ 932 :                            ;	LD	R1,FLAGS
 1426/ 932 : A0 E6                      	INCW	RR6
 1427/ 934 :                            ;	LD	FLAGS,R1
 1428/ 934 : D2 06                      	LDC	@RR6,R0		; A = 00
 1429/ 936 : AF                         	RET
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 25 - 2023/10/26 22時18分50秒


 1430/ 937 :                            ;
 1431/ 937 :                            DODEL:
 1432/ 937 : 8C 80                      	LD	R8,#hi(NULFLG)
 1433/ 939 : 9C 91                      	LD	R9,#lo(NULFLG)
 1434/ 93B : C2 08                      	LDC	R0,@RR8		; Get null flag status
 1435/ 93D : 42 00                      	OR	R0,R0
 1436/ 93F : CF                         	RCF			; Is it zero?
 1437/ 940 : 0C 00                      	LD	R0,#0		; Zero A - Leave flags
 1438/ 942 : 8C 80                      	LD	R8,#hi(NULFLG)
 1439/ 944 : 9C 91                      	LD	R9,#lo(NULFLG)
 1440/ 946 : D2 08                      	LDC	@RR8,R0		; Zero null flag
 1441/ 948 : ED 09 55                   	JP	NZ,ECHDEL	; Set - Echo it
 1442/ 94B : 00 E4                      	DEC	R4		; Decrement length
 1443/ 94D : 6D 09 7F                   	JP	Z,GETLIN	; Get line again if empty
 1444/ 950 : D6 0A 6F                   	CALL	OUTC		; Output null character
 1445/ 953 : 8B 02                      	JR	ECHDEL1		; Skip "DEC B"
 1446/ 955 :                            ECHDEL:
 1447/ 955 : 00 E4                      	DEC	R4		; Count bytes in buffer
 1448/ 957 :                            ECHDEL1:
 1449/ 957 : 18 FC                      	LD	R1,FLAGS
 1450/ 959 : 80 E2                      	DECW	RR2		; Back space buffer
 1451/ 95B : 19 FC                      	LD	FLAGS,R1
 1452/ 95D : 6D 09 76                   	JP	Z,OTKLN		; No buffer - Try again
 1453/ 960 : C2 02                      	LDC	R0,@RR2		; Get deleted byte
 1454/ 962 : D6 0A 6F                   	CALL	OUTC		; Echo it
 1455/ 965 : 8D 09 8D                   	JP	MORINP		; Get more input
 1456/ 968 :                            ;
 1457/ 968 :                            DELCHR:
 1458/ 968 : 00 E4                      	DEC	R4		; Count bytes in buffer
 1459/ 96A : 18 FC                      	LD	R1,FLAGS
 1460/ 96C : 80 E2                      	DECW	RR2		; Back space buffer
 1461/ 96E : 19 FC                      	LD	FLAGS,R1
 1462/ 970 : D6 0A 6F                   	CALL	OUTC		; Output character in A
 1463/ 973 : ED 09 8D                   	JP	NZ,MORINP	; Not end - Get more
 1464/ 976 :                            OTKLN:
 1465/ 976 : D6 0A 6F                   	CALL	OUTC		; Output character in A
 1466/ 979 :                            KILIN:
 1467/ 979 : D6 13 1B                   	CALL	PRCRLF		; Output CRLF
 1468/ 97C : 8D 09 7F                   	JP	TTYLIN		; Get line again
 1469/ 97F :                            ;
 1470/ 97F :                            GETLIN:
 1471/ 97F :                            TTYLIN:
 1472/ 97F : 2C 80                      	LD	R2,#hi(BUFFER)	; Get a line by character
 1473/ 981 : 3C AE                      	LD	R3,#lo(BUFFER)
 1474/ 983 : 4C 01                      	LD	R4,#1		; Set buffer as empty
 1475/ 985 : B2 00                      	XOR	R0,R0
 1476/ 987 : 8C 80                      	LD	R8,#hi(NULFLG)
 1477/ 989 : 9C 91                      	LD	R9,#lo(NULFLG)
 1478/ 98B : D2 08                      	LDC	@RR8,R0		; Clear null flag
 1479/ 98D :                            MORINP:
 1480/ 98D : D6 0A BF                   	CALL	CLOTST		; Get character and test ^O
 1481/ 990 : 58 E0                      	LD	R5,R0		; Save character in C
 1482/ 992 : A6 E0 7F                   	CP	R0,#DEL		; Delete character?
 1483/ 995 : 6D 09 37                   	JP	Z,DODEL		; Yes - Process it
 1484/ 998 : 8C 80                      	LD	R8,#hi(NULFLG)
 1485/ 99A : 9C 91                      	LD	R9,#lo(NULFLG)
 1486/ 99C : C2 08                      	LDC	R0,@RR8		; Get null flag
 1487/ 99E : 42 00                      	OR	R0,R0		; Test null flag status
 1488/ 9A0 : 6D 09 B1                   	JP	Z,PROCES	; Reset - Process character
 1489/ 9A3 : 0C 00                      	LD	R0,#0		; Set a null
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 26 - 2023/10/26 22時18分50秒


 1490/ 9A5 : D6 0A 6F                   	CALL	OUTC		; Output null
 1491/ 9A8 : B2 00                      	XOR	R0,R0		; Clear A
 1492/ 9AA : CF                         	RCF
 1493/ 9AB : 8C 80                      	LD	R8,#hi(NULFLG)
 1494/ 9AD : 9C 91                      	LD	R9,#lo(NULFLG)
 1495/ 9AF : D2 08                      	LDC	@RR8,R0		; Reset null flag
 1496/ 9B1 :                            PROCES:
 1497/ 9B1 : 08 E5                      	LD	R0,R5		; Get character
 1498/ 9B3 : A6 E0 07                   	CP	R0,#CTRLG	; Bell?
 1499/ 9B6 : 6D 0A 18                   	JP	Z,PUTCTL	; Yes - Save it
 1500/ 9B9 : A6 E0 03                   	CP	R0,#CTRLC	; Is it control "C"?
 1501/ 9BC : EB 03                      	JR	NZ,$+5
 1502/ 9BE : D6 13 1B                   	CALL	PRCRLF		; Yes - Output CRLF
 1503/ 9C1 : DF                         	SCF			; Flag break
 1504/ 9C2 : EB 01                      	JR	NZ,$+3
 1505/ 9C4 : AF                         	RET			; Return if control "C"
 1506/ 9C5 : A6 E0 0D                   	CP	R0,#CR		; Is it enter?
 1507/ 9C8 : 6D 13 13                   	JP	Z,ENDINP	; Yes - Terminate input
 1508/ 9CB : A6 E0 15                   	CP	R0,#CTRLU	; Is it control "U"?
 1509/ 9CE : 6D 09 79                   	JP	Z,KILIN		; Yes - Get another line
 1510/ 9D1 : A6 E0 40                   	CP	R0,#'@'		; Is it "kill line"?
 1511/ 9D4 : 6D 09 76                   	JP	Z,OTKLN		; Yes - Kill line
 1512/ 9D7 : A6 E0 5F                   	CP	R0,#'_'		; Is it delete?
 1513/ 9DA : 6D 09 68                   	JP	Z,DELCHR	; Yes - Delete character
 1514/ 9DD : A6 E0 08                   	CP	R0,#BKSP	; Is it backspace?
 1515/ 9E0 : 6D 09 68                   	JP	Z,DELCHR	; Yes - Delete character
 1516/ 9E3 : A6 E0 12                   	CP	R0,#CTRLR	; Is it control "R"?
 1517/ 9E6 : ED 0A 12                   	JP	NZ,PUTBUF	; No - Put in buffer
 1518/ 9E9 : 70 E5                      	PUSH	R5
 1519/ 9EB : 70 E4                      	PUSH	R4		; Save buffer length
 1520/ 9ED : 70 E7                      	PUSH	R7
 1521/ 9EF : 70 E6                      	PUSH	R6		; Save DE
 1522/ 9F1 : 70 E3                      	PUSH	R3
 1523/ 9F3 : 70 E2                      	PUSH	R2		; Save buffer address
 1524/ 9F5 : 1C 00                      	LD	R1,#0
 1525/ 9F7 : D2 12                      	LDC	@RR2,R1		; Mark end of buffer
 1526/ 9F9 : D6 36 2E                   	CALL	OUTNCR		; Output and do CRLF
 1527/ 9FC : 2C 80                      	LD	R2,#hi(BUFFER)	; Point to buffer start
 1528/ 9FE : 3C AE                      	LD	R3,#lo(BUFFER)
 1529/ A00 : D6 21 02                   	CALL	PRS		; Output buffer
 1530/ A03 : 50 E2                      	POP	R2
 1531/ A05 : 50 E3                      	POP	R3		; Restore buffer address
 1532/ A07 : 50 E6                      	POP	R6
 1533/ A09 : 50 E7                      	POP	R7		; Restore DE
 1534/ A0B : 50 E4                      	POP	R4
 1535/ A0D : 50 E5                      	POP	R5		; Restore buffer length
 1536/ A0F : 8D 09 8D                   	JP	MORINP		; Get another character
 1537/ A12 :                            ;
 1538/ A12 :                            PUTBUF:
 1539/ A12 : A6 E0 20                   	CP	R0,#' '		; Is it a control code?
 1540/ A15 : 7D 09 8D                   	JP	C,MORINP	; Yes - Ignore
 1541/ A18 :                            PUTCTL:
 1542/ A18 : 08 E4                      	LD	R0,R4		; Get number of bytes in buffer
 1543/ A1A : A6 E0 49                   	CP	R0,#72+1	; Test for line overflow
 1544/ A1D : 0C 07                      	LD	R0,#CTRLG	; Set a bell
 1545/ A1F : FD 0A 35                   	JP	NC,OUTNBS	; Ring bell if buffer full
 1546/ A22 : 08 E5                      	LD	R0,R5		; Get character
 1547/ A24 : D2 52                      	LDC	@RR2,R5		; Save in buffer
 1548/ A26 : 8C 81                      	LD	R8,#hi(LSTBIN)
 1549/ A28 : 9C 19                      	LD	R9,#lo(LSTBIN)
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 27 - 2023/10/26 22時18分50秒


 1550/ A2A : D2 08                      	LDC	@RR8,R0		; Save last input byte
 1551/ A2C : A0 E2                      	INCW	RR2		; Move up buffer
 1552/ A2E : 4E                         	INC	R4		; Increment length
 1553/ A2F :                            OUTIT:
 1554/ A2F : D6 0A 6F                   	CALL	OUTC		; Output the character entered
 1555/ A32 : 8D 09 8D                   	JP	MORINP		; Get another character
 1556/ A35 :                            ;
 1557/ A35 :                            OUTNBS:
 1558/ A35 : D6 0A 6F                   	CALL	OUTC		; Output bell and back over it
 1559/ A38 : 0C 08                      	LD	R0,#BKSP	; Set back space
 1560/ A3A : 8D 0A 2F                   	JP	OUTIT		; Output it and get more
 1561/ A3D :                            ;
 1562/ A3D :                            CPDEHL:
 1563/ A3D : 08 E2                      	LD	R0,R2		; Get H
 1564/ A3F : 22 06                      	SUB	R0,R6		; Compare with D
 1565/ A41 : 6B 01                      	JR	Z,$+3
 1566/ A43 : AF                         	RET			; Different - Exit
 1567/ A44 : 08 E3                      	LD	R0,R3		; Get L
 1568/ A46 : 22 07                      	SUB	R0,R7		; Compare with E
 1569/ A48 : AF                         	RET			; Return status
 1570/ A49 :                            ;
 1571/ A49 :                            CHKSYN:
 1572/ A49 : C2 02                      	LDC	R0,@RR2		; Check syntax of character
 1573/ A4B : 50 E8                      	POP	R8
 1574/ A4D : 50 E9                      	POP	R9
 1575/ A4F : 70 E3                      	PUSH	R3
 1576/ A51 : 70 E2                      	PUSH	R2
 1577/ A53 : 28 E8                      	LD	R2,R8
 1578/ A55 : 38 E9                      	LD	R3,R9		; Address of test byte
 1579/ A57 : C2 82                      	LDC	R8,@RR2
 1580/ A59 : A0 E2                      	INCW	RR2		; Return address
 1581/ A5B : A2 08                      	CP	R0,R8		; Same as in code string?
 1582/ A5D : 50 E8                      	POP	R8
 1583/ A5F : 50 E9                      	POP	R9
 1584/ A61 : 70 E3                      	PUSH	R3
 1585/ A63 : 70 E2                      	PUSH	R2
 1586/ A65 : 28 E8                      	LD	R2,R8
 1587/ A67 : 38 E9                      	LD	R3,R9		; Put it back
 1588/ A69 : 6D 0D AD                   	JP	Z,GETCHR	; Yes - Get next character
 1589/ A6C : 8D 04 FF                   	JP	SNERR		; Different - ?SN Error
 1590/ A6F :                            ;
 1591/ A6F :                            OUTC:
 1592/ A6F : 18 FC                      	LD	R1,FLAGS
 1593/ A71 : 70 E1                      	PUSH	R1
 1594/ A73 : 70 E0                      	PUSH	R0		; Save character
 1595/ A75 : 8C 80                      	LD	R8,#hi(CTLOFG)
 1596/ A77 : 9C 92                      	LD	R9,#lo(CTLOFG)
 1597/ A79 : C2 08                      	LDC	R0,@RR8		; Get control "O" flag
 1598/ A7B : 42 00                      	OR	R0,R0
 1599/ A7D : CF                         	RCF			; Is it set?
 1600/ A7E : ED 21 7D                   	JP	NZ,POPAF	; Yes - don't output
 1601/ A81 : 50 E0                      	POP	R0		; Restore character
 1602/ A83 : 50 E1                      	POP	R1
 1603/ A85 : 19 FC                      	LD	FLAGS,R1
 1604/ A87 : 70 E5                      	PUSH	R5
 1605/ A89 : 70 E4                      	PUSH	R4		; Save buffer length
 1606/ A8B :                            ;	LD	R1,FLAGS
 1607/ A8B :                            ;	PUSH	R1
 1608/ A8B : 70 E0                      	PUSH	R0		; Save character
 1609/ A8D : A6 E0 20                   	CP	R0,#' '		; Is it a control code?
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 28 - 2023/10/26 22時18分50秒


 1610/ A90 : 7D 0A B5                   	JP	C,DINPOS	; Yes - Don't INC POS(X)
 1611/ A93 : 8C 80                      	LD	R8,#hi(LWIDTH)
 1612/ A95 : 9C 8F                      	LD	R9,#lo(LWIDTH)
 1613/ A97 : C2 08                      	LDC	R0,@RR8		; Get line width
 1614/ A99 : 48 E0                      	LD	R4,R0		; To B
 1615/ A9B : 8C 80                      	LD	R8,#hi(CURPOS)
 1616/ A9D : 9C F8                      	LD	R9,#lo(CURPOS)
 1617/ A9F : C2 08                      	LDC	R0,@RR8		; Get cursor position
 1618/ AA1 : 4E                         	INC	R4		; Width 255?
 1619/ AA2 : 6D 0A AE                   	JP	Z,INCLEN	; Yes - No width limit
 1620/ AA5 : 00 E4                      	DEC	R4		; Restore width
 1621/ AA7 : A2 04                      	CP	R0,R4		; At end of line?
 1622/ AA9 : EB 03                      	JR	NZ,$+5
 1623/ AAB : D6 13 1B                   	CALL	PRCRLF		; Yes - output CRLF
 1624/ AAE :                            INCLEN:
 1625/ AAE : 0E                         	INC	R0		; Move on one character
 1626/ AAF : 8C 80                      	LD	R8,#hi(CURPOS)
 1627/ AB1 : 9C F8                      	LD	R9,#lo(CURPOS)
 1628/ AB3 : D2 08                      	LDC	@RR8,R0		; Save new position
 1629/ AB5 :                            DINPOS:
 1630/ AB5 : 50 E0                      	POP	R0		; Restore character
 1631/ AB7 :                            ;	POP	R1
 1632/ AB7 :                            ;	LD	FLAGS,R1
 1633/ AB7 : 50 E4                      	POP	R4
 1634/ AB9 : 50 E5                      	POP	R5		; Restore buffer length
 1635/ ABB : D6 36 1D                   	CALL	MONOUT		; Send it
 1636/ ABE : AF                         	RET
 1637/ ABF :                            ;
 1638/ ABF :                            CLOTST:
 1639/ ABF : D6 33 FA                   	CALL	GETINP		; Get input character
 1640/ AC2 : 56 E0 7F                   	AND	R0,#01111111B	; Strip bit 7
 1641/ AC5 : A6 E0 0F                   	CP	R0,#CTRLO	; Is it control "O"?
 1642/ AC8 : 6B 01                      	JR	Z,$+3
 1643/ ACA : AF                         	RET			; No don't flip flag
 1644/ ACB : 8C 80                      	LD	R8,#hi(CTLOFG)
 1645/ ACD : 9C 92                      	LD	R9,#lo(CTLOFG)
 1646/ ACF : C2 08                      	LDC	R0,@RR8		; Get flag
 1647/ AD1 : 60 E0                      	COM	R0		; Flip it
 1648/ AD3 : 8C 80                      	LD	R8,#hi(CTLOFG)
 1649/ AD5 : 9C 92                      	LD	R9,#lo(CTLOFG)
 1650/ AD7 : D2 08                      	LDC	@RR8,R0		; Put it back
 1651/ AD9 : B2 00                      	XOR	R0,R0		; Null character
 1652/ ADB :                            ;	RCF
 1653/ ADB : AF                         	RET
 1654/ ADC :                            ;
 1655/ ADC :                            LIST:
 1656/ ADC : D6 0F 80                   	CALL	ATOH		; ASCII number to DE
 1657/ ADF : 6B 01                      	JR	Z,$+3
 1658/ AE1 : AF                         	RET			; Return if anything extra
 1659/ AE2 : 50 E4                      	POP	R4
 1660/ AE4 : 50 E5                      	POP	R5		; Rubbish - Not needed
 1661/ AE6 : D6 06 D9                   	CALL	SRCHLN		; Search for line number in DE
 1662/ AE9 : 70 E5                      	PUSH	R5
 1663/ AEB : 70 E4                      	PUSH	R4		; Save address of line
 1664/ AED : D6 0B 69                   	CALL	SETLIN		; Set up lines counter
 1665/ AF0 :                            LISTLP:
 1666/ AF0 : 50 E2                      	POP	R2
 1667/ AF2 : 50 E3                      	POP	R3		; Restore address of line
 1668/ AF4 : C2 52                      	LDC	R5,@RR2		; Get LSB of next line
 1669/ AF6 : A0 E2                      	INCW	RR2
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 29 - 2023/10/26 22時18分50秒


 1670/ AF8 : C2 42                      	LDC	R4,@RR2		; Get MSB of next line
 1671/ AFA : A0 E2                      	INCW	RR2
 1672/ AFC : 08 E4                      	LD	R0,R4		; BC = 0 (End of program)?
 1673/ AFE : 42 05                      	OR	R0,R5
 1674/ B00 : 6D 05 6A                   	JP	Z,PRNTOK	; Yes - Go to command mode
 1675/ B03 : D6 0B 86                   	CALL	COUNT		; Count lines
 1676/ B06 : D6 0E 1C                   	CALL	TSTBRK		; Test for break key
 1677/ B09 : 70 E5                      	PUSH	R5
 1678/ B0B : 70 E4                      	PUSH	R4		; Save address of next line
 1679/ B0D : D6 13 1B                   	CALL	PRCRLF		; Output CRLF
 1680/ B10 : C2 72                      	LDC	R7,@RR2		; Get LSB of line number
 1681/ B12 : A0 E2                      	INCW	RR2
 1682/ B14 : C2 62                      	LDC	R6,@RR2		; Get MSB of line number
 1683/ B16 : A0 E2                      	INCW	RR2
 1684/ B18 : 70 E3                      	PUSH	R3
 1685/ B1A : 70 E2                      	PUSH	R2		; Save address of line start
 1686/ B1C : 88 E6                      	LD	R8,R6
 1687/ B1E : 98 E7                      	LD	R9,R7
 1688/ B20 : 68 E2                      	LD	R6,R2
 1689/ B22 : 78 E3                      	LD	R7,R3
 1690/ B24 : 28 E8                      	LD	R2,R8
 1691/ B26 : 38 E9                      	LD	R3,R9		; Line number to HL
 1692/ B28 : D6 2E 8D                   	CALL	PRNTHL		; Output line number in decimal
 1693/ B2B : 0C 20                      	LD	R0,#' '		; Space after line number
 1694/ B2D : 50 E2                      	POP	R2
 1695/ B2F : 50 E3                      	POP	R3		; Restore start of line address
 1696/ B31 :                            LSTLP2:
 1697/ B31 : D6 0A 6F                   	CALL	OUTC		; Output character in A
 1698/ B34 :                            LSTLP3:
 1699/ B34 : C2 02                      	LDC	R0,@RR2		; Get next byte in line
 1700/ B36 : A0 E2                      	INCW	RR2		; To next byte in line
 1701/ B38 : 42 00                      	OR	R0,R0		; End of line?
 1702/ B3A : 6D 0A F0                   	JP	Z,LISTLP	; Yes - get next line
 1703/ B3D : DD 0B 31                   	JP	PL,LSTLP2	; No token - output it
 1704/ B40 : 26 E0 7F                   	SUB	R0,#ZEND-1	; Find and output word
 1705/ B43 : 58 E0                      	LD	R5,R0		; Token offset+1 to C
 1706/ B45 : 6C 02                      	LD	R6,#hi(WORDS)
 1707/ B47 : 7C 00                      	LD	R7,#lo(WORDS)	; Reserved word list
 1708/ B49 :                            FNDTOK:
 1709/ B49 : C2 06                      	LDC	R0,@RR6		; Get character in list
 1710/ B4B : A0 E6                      	INCW	RR6		; Move on to next
 1711/ B4D : 42 00                      	OR	R0,R0		; Is it start of word?
 1712/ B4F : DD 0B 49                   	JP	PL,FNDTOK	; No - Keep looking for word
 1713/ B52 : 00 E5                      	DEC	R5		; Count words
 1714/ B54 : ED 0B 49                   	JP	NZ,FNDTOK	; Not there - keep looking
 1715/ B57 :                            OUTWRD:
 1716/ B57 : 56 E0 7F                   	AND	R0,#01111111B	; Strip bit 7
 1717/ B5A : D6 0A 6F                   	CALL	OUTC		; Output first character
 1718/ B5D : C2 06                      	LDC	R0,@RR6		; Get next character
 1719/ B5F : A0 E6                      	INCW	RR6		; Move on to next
 1720/ B61 : 42 00                      	OR	R0,R0		; Is it end of word?
 1721/ B63 : DD 0B 57                   	JP	PL,OUTWRD	; No - output the rest
 1722/ B66 : 8D 0B 34                   	JP	LSTLP3		; Next byte in line
 1723/ B69 :                            ;
 1724/ B69 :                            SETLIN:
 1725/ B69 : 70 E3                      	PUSH	R3
 1726/ B6B : 70 E2                      	PUSH	R2		; Set up LINES counter
 1727/ B6D : 8C 80                      	LD	R8,#hi(LINESN)
 1728/ B6F : 9C 95                      	LD	R9,#lo(LINESN)
 1729/ B71 : C2 28                      	LDC	R2,@RR8
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 30 - 2023/10/26 22時18分50秒


 1730/ B73 :                            ;	LD	R1,FLAGS
 1731/ B73 : A0 E8                      	INCW	RR8
 1732/ B75 :                            ;	LD	FLAGS,R1
 1733/ B75 : C2 38                      	LDC	R3,@RR8		; Get LINES number
 1734/ B77 : 8C 80                      	LD	R8,#hi(LINESC)
 1735/ B79 : 9C 93                      	LD	R9,#lo(LINESC)
 1736/ B7B : D2 28                      	LDC	@RR8,R2
 1737/ B7D :                            ;	LD	R1,FLAGS
 1738/ B7D : A0 E8                      	INCW	RR8
 1739/ B7F :                            ;	LD	FLAGS,R1
 1740/ B7F : D2 38                      	LDC	@RR8,R3		; Save in LINES counter
 1741/ B81 : 50 E2                      	POP	R2
 1742/ B83 : 50 E3                      	POP	R3
 1743/ B85 : AF                         	RET
 1744/ B86 :                            ;
 1745/ B86 :                            COUNT:
 1746/ B86 : 70 E3                      	PUSH	R3
 1747/ B88 : 70 E2                      	PUSH	R2		; Save code string address
 1748/ B8A : 70 E7                      	PUSH	R7
 1749/ B8C : 70 E6                      	PUSH	R6
 1750/ B8E : 8C 80                      	LD	R8,#hi(LINESC)
 1751/ B90 : 9C 93                      	LD	R9,#lo(LINESC)
 1752/ B92 : C2 28                      	LDC	R2,@RR8
 1753/ B94 : A0 E8                      	INCW	RR8
 1754/ B96 : C2 38                      	LDC	R3,@RR8		; Get LINES counter
 1755/ B98 : 6C FF                      	LD	R6,#hi(-1)
 1756/ B9A : 7C FF                      	LD	R7,#lo(-1)
 1757/ B9C : 12 37                      	ADC	R3,R7
 1758/ B9E : 12 26                      	ADC	R2,R6		; Decrement
 1759/ BA0 : 8C 80                      	LD	R8,#hi(LINESC)
 1760/ BA2 : 9C 93                      	LD	R9,#lo(LINESC)
 1761/ BA4 : D2 28                      	LDC	@RR8,R2
 1762/ BA6 : 18 FC                      	LD	R1,FLAGS
 1763/ BA8 : A0 E8                      	INCW	RR8
 1764/ BAA : 19 FC                      	LD	FLAGS,R1
 1765/ BAC : D2 38                      	LDC	@RR8,R3		; Put it back
 1766/ BAE : 50 E6                      	POP	R6
 1767/ BB0 : 50 E7                      	POP	R7
 1768/ BB2 : 50 E2                      	POP	R2
 1769/ BB4 : 50 E3                      	POP	R3		; Restore code string address
 1770/ BB6 : 5B 01                      	JR	MI,$+3
 1771/ BB8 : AF                         	RET			; Return if more lines to go
 1772/ BB9 : 70 E3                      	PUSH	R3
 1773/ BBB : 70 E2                      	PUSH	R2		; Save code string address
 1774/ BBD : 8C 80                      	LD	R8,#hi(LINESN)
 1775/ BBF : 9C 95                      	LD	R9,#lo(LINESN)
 1776/ BC1 : C2 28                      	LDC	R2,@RR8
 1777/ BC3 : A0 E8                      	INCW	RR8
 1778/ BC5 : C2 38                      	LDC	R3,@RR8		; Get LINES number
 1779/ BC7 : 8C 80                      	LD	R8,#hi(LINESC)
 1780/ BC9 : 9C 93                      	LD	R9,#lo(LINESC)
 1781/ BCB : D2 28                      	LDC	@RR8,R2
 1782/ BCD : A0 E8                      	INCW	RR8
 1783/ BCF : D2 38                      	LDC	@RR8,R3		; Reset LINES counter
 1784/ BD1 : D6 33 FA                   	CALL	GETINP		; Get input character
 1785/ BD4 : A6 E0 03                   	CP	R0,#CTRLC	; Is it control "C"?
 1786/ BD7 : 6D 0B E1                   	JP	Z,RSLNBK	; Yes - Reset LINES and break
 1787/ BDA : 50 E2                      	POP	R2
 1788/ BDC : 50 E3                      	POP	R3		; Restore code string address
 1789/ BDE : 8D 0B 86                   	JP	COUNT		; Keep on counting
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 31 - 2023/10/26 22時18分50秒


 1790/ BE1 :                            ;
 1791/ BE1 :                            RSLNBK:
 1792/ BE1 : 8C 80                      	LD	R8,#hi(LINESN)
 1793/ BE3 : 9C 95                      	LD	R9,#lo(LINESN)
 1794/ BE5 : C2 28                      	LDC	R2,@RR8
 1795/ BE7 :                            ;	LD	R1,FLAGS
 1796/ BE7 : A0 E8                      	INCW	RR8
 1797/ BE9 :                            ;	LD	FLAGS,R1
 1798/ BE9 : C2 38                      	LDC	R3,@RR8		; Get LINES number
 1799/ BEB : 8C 80                      	LD	R8,#hi(LINESC)
 1800/ BED : 9C 93                      	LD	R9,#lo(LINESC)
 1801/ BEF : D2 28                      	LDC	@RR8,R2
 1802/ BF1 :                            ;	LD	R1,FLAGS
 1803/ BF1 : A0 E8                      	INCW	RR8
 1804/ BF3 :                            ;	LD	FLAGS,R1
 1805/ BF3 : D2 38                      	LDC	@RR8,R3		; Reset LINES counter
 1806/ BF5 : 8D 01 37                   	JP	BRKRET		; Go and output "Break"
 1807/ BF8 :                            ;
 1808/ BF8 :                            FOR:
 1809/ BF8 : 0C 64                      	LD	R0,#64H		; Flag "FOR" assignment
 1810/ BFA : 8C 81                      	LD	R8,#hi(FORFLG)
 1811/ BFC : 9C 18                      	LD	R9,#lo(FORFLG)
 1812/ BFE : D2 08                      	LDC	@RR8,R0		; Save "FOR" flag
 1813/ C00 : D6 11 63                   	CALL	LET		; Set up initial index
 1814/ C03 : 50 E4                      	POP	R4
 1815/ C05 : 50 E5                      	POP	R5		; Drop RETurn address
 1816/ C07 : 70 E3                      	PUSH	R3
 1817/ C09 : 70 E2                      	PUSH	R2		; Save code string address
 1818/ C0B : D6 11 3E                   	CALL	DATA		; Get next statement address
 1819/ C0E : 8C 81                      	LD	R8,#hi(LOOPST)
 1820/ C10 : 9C 14                      	LD	R9,#lo(LOOPST)
 1821/ C12 : D2 28                      	LDC	@RR8,R2
 1822/ C14 : A0 E8                      	INCW	RR8
 1823/ C16 : D2 38                      	LDC	@RR8,R3		; Save it for start of loop
 1824/ C18 : 2C 00                      	LD	R2,#hi(2)
 1825/ C1A : 3C 02                      	LD	R3,#lo(2)	; Offset for "FOR" block
 1826/ C1C : 04 FF E3                   	ADD	R3,SPL
 1827/ C1F : 14 FE E2                   	ADC	R2,SPH		; Point to it
 1828/ C22 :                            FORSLP:
 1829/ C22 : D6 04 32                   	CALL	LOKFOR		; Look for existing "FOR" block
 1830/ C25 : 50 E6                      	POP	R6
 1831/ C27 : 50 E7                      	POP	R7		; Get code string address
 1832/ C29 : ED 0C 60                   	JP	NZ,FORFND	; No nesting found
 1833/ C2C : 02 35                      	ADD	R3,R5
 1834/ C2E : 12 24                      	ADC	R2,R4		; Move into "FOR" block
 1835/ C30 : 70 E7                      	PUSH	R7
 1836/ C32 : 70 E6                      	PUSH	R6		; Save code string address
 1837/ C34 : 80 E2                      	DECW	RR2
 1838/ C36 : C2 62                      	LDC	R6,@RR2		; Get MSB of loop statement
 1839/ C38 : 80 E2                      	DECW	RR2
 1840/ C3A : C2 72                      	LDC	R7,@RR2		; Get LSB of loop statement
 1841/ C3C : A0 E2                      	INCW	RR2
 1842/ C3E : A0 E2                      	INCW	RR2
 1843/ C40 : 70 E3                      	PUSH	R3
 1844/ C42 : 70 E2                      	PUSH	R2		; Save block address
 1845/ C44 : 8C 81                      	LD	R8,#hi(LOOPST)
 1846/ C46 : 9C 14                      	LD	R9,#lo(LOOPST)
 1847/ C48 : C2 28                      	LDC	R2,@RR8
 1848/ C4A : A0 E8                      	INCW	RR8
 1849/ C4C : C2 38                      	LDC	R3,@RR8		; Get address of loop statement
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 32 - 2023/10/26 22時18分50秒


 1850/ C4E : D6 0A 3D                   	CALL	CPDEHL		; Compare the FOR loops
 1851/ C51 : 50 E2                      	POP	R2
 1852/ C53 : 50 E3                      	POP	R3		; Restore block address
 1853/ C55 : ED 0C 22                   	JP	NZ,FORSLP	; Different FORs - Find another
 1854/ C58 : 50 E6                      	POP	R6
 1855/ C5A : 50 E7                      	POP	R7		; Restore code string address
 1856/ C5C : 29 FE                      	LD	SPH,R2
 1857/ C5E : 39 FF                      	LD	SPL,R3		; Remove all nested loops
 1858/ C60 :                            ;
 1859/ C60 :                            FORFND:
 1860/ C60 : 88 E6                      	LD	R8,R6
 1861/ C62 : 98 E7                      	LD	R9,R7
 1862/ C64 : 68 E2                      	LD	R6,R2
 1863/ C66 : 78 E3                      	LD	R7,R3
 1864/ C68 : 28 E8                      	LD	R2,R8
 1865/ C6A : 38 E9                      	LD	R3,R9		; Code string address to HL
 1866/ C6C : 5C 08                      	LD	R5,#8
 1867/ C6E : D6 04 AC                   	CALL	CHKSTK		; Check for 8 levels of stack
 1868/ C71 : 70 E3                      	PUSH	R3
 1869/ C73 : 70 E2                      	PUSH	R2		; Save code string address
 1870/ C75 : 8C 81                      	LD	R8,#hi(LOOPST)
 1871/ C77 : 9C 14                      	LD	R9,#lo(LOOPST)
 1872/ C79 : C2 28                      	LDC	R2,@RR8
 1873/ C7B : A0 E8                      	INCW	RR8
 1874/ C7D : C2 38                      	LDC	R3,@RR8		; Get first statement of loop
 1875/ C7F : 50 E8                      	POP	R8
 1876/ C81 : 50 E9                      	POP	R9
 1877/ C83 : 70 E3                      	PUSH	R3
 1878/ C85 : 70 E2                      	PUSH	R2
 1879/ C87 : 28 E8                      	LD	R2,R8
 1880/ C89 : 38 E9                      	LD	R3,R9		; Save and restore code string
 1881/ C8B : 70 E3                      	PUSH	R3
 1882/ C8D : 70 E2                      	PUSH	R2		; Re-save code string address
 1883/ C8F : 8C 80                      	LD	R8,#hi(LINEAT)
 1884/ C91 : 9C A9                      	LD	R9,#lo(LINEAT)
 1885/ C93 : C2 28                      	LDC	R2,@RR8
 1886/ C95 : A0 E8                      	INCW	RR8
 1887/ C97 : C2 38                      	LDC	R3,@RR8		; Get current line number
 1888/ C99 : 50 E8                      	POP	R8
 1889/ C9B : 50 E9                      	POP	R9
 1890/ C9D : 70 E3                      	PUSH	R3
 1891/ C9F : 70 E2                      	PUSH	R2
 1892/ CA1 : 28 E8                      	LD	R2,R8
 1893/ CA3 : 38 E9                      	LD	R3,R9		; Save and restore code string
 1894/ CA5 : D6 16 80                   	CALL	TSTNUM		; Make sure it's a number
 1895/ CA8 : D6 0A 49                   	CALL	CHKSYN		; Make sure "TO" is next
 1896/ CAB : A6                         	DB	ZTO		; "TO" token
 1897/ CAC : D6 16 7D                   	CALL	GETNUM		; Get "TO" expression value
 1898/ CAF : 70 E3                      	PUSH	R3
 1899/ CB1 : 70 E2                      	PUSH	R2		; Save code string address
 1900/ CB3 : D6 2C 03                   	CALL	BCDEFP		; Move "TO" value to BCDE
 1901/ CB6 : 50 E2                      	POP	R2
 1902/ CB8 : 50 E3                      	POP	R3		; Restore code string address
 1903/ CBA :                            
 1904/ CBA : 70 E4                      	PUSH	R4		; Save "TO" value in block
 1905/ CBC : 70 E5                      	PUSH	R5		; @@@ SWAP BC
 1906/ CBE : 70 E6                      	PUSH	R6		; @@@ SWAP DE
 1907/ CC0 : 70 E7                      	PUSH	R7
 1908/ CC2 :                            
 1909/ CC2 : 4C 81                      	LD	R4,#hi(8100H)
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 33 - 2023/10/26 22時18分50秒


 1910/ CC4 : 5C 00                      	LD	R5,#lo(8100H)	; BCDE - 1 (default STEP)
 1911/ CC6 : 68 E5                      	LD	R6,R5		; C=0
 1912/ CC8 : 78 E6                      	LD	R7,R6		; D=0
 1913/ CCA : C2 02                      	LDC	R0,@RR2		; Get next byte in code string
 1914/ CCC : A6 E0 AB                   	CP	R0,#ZSTEP	; See if "STEP" is stated
 1915/ CCF : 0C 01                      	LD	R0,#1		; Sign of step = 1
 1916/ CD1 : ED 0C E8                   	JP	NZ,SAVSTP	; No STEP given - Default to 1
 1917/ CD4 : D6 0D AD                   	CALL	GETCHR		; Jump over "STEP" token
 1918/ CD7 : D6 16 7D                   	CALL	GETNUM		; Get step value
 1919/ CDA : 70 E3                      	PUSH	R3
 1920/ CDC : 70 E2                      	PUSH	R2		; Save code string address
 1921/ CDE : D6 2C 03                   	CALL	BCDEFP		; Move STEP to BCDE
 1922/ CE1 : D6 2B 76                   	CALL	TSTSGN		; Test sign of FPREG
 1923/ CE4 : 50 E2                      	POP	R2
 1924/ CE6 : 50 E3                      	POP	R3		; Restore code string address
 1925/ CE8 :                            SAVSTP:
 1926/ CE8 : 70 E4                      	PUSH	R4		; Save the STEP value in block
 1927/ CEA : 70 E5                      	PUSH	R5		; @@@ SWAP DE
 1928/ CEC : 70 E6                      	PUSH	R6		; @@@ SWAP BC
 1929/ CEE : 70 E7                      	PUSH	R7
 1930/ CF0 :                            
 1931/ CF0 : 18 FC                      	LD	R1,FLAGS
 1932/ CF2 :                            ;	PUSH	R1
 1933/ CF2 : 70 E0                      	PUSH	R0		; Save sign of STEP
 1934/ CF4 :                            ;	ADD	SPL,#1
 1935/ CF4 :                            ;	ADC	SPH,#0		; Don't save flags
 1936/ CF4 :                            
 1937/ CF4 : 70 E3                      	PUSH	R3
 1938/ CF6 : 70 E2                      	PUSH	R2		; Save code string address
 1939/ CF8 : 8C 81                      	LD	R8,#hi(BRKLIN)
 1940/ CFA : 9C 1B                      	LD	R9,#lo(BRKLIN)
 1941/ CFC : C2 28                      	LDC	R2,@RR8
 1942/ CFE : A0 E8                      	INCW	RR8
 1943/ D00 : C2 38                      	LDC	R3,@RR8		; Get address of index variable
 1944/ D02 : 50 E8                      	POP	R8
 1945/ D04 : 50 E9                      	POP	R9
 1946/ D06 :                            
 1947/ D06 : 70 E2                      	PUSH	R2		; @@@ SWAP HL
 1948/ D08 : 70 E3                      	PUSH	R3
 1949/ D0A :                            
 1950/ D0A : 28 E8                      	LD	R2,R8
 1951/ D0C : 38 E9                      	LD	R3,R9		; Save and restore code string
 1952/ D0E :                            PUTFID:
 1953/ D0E : 4C 81                      	LD	R4,#ZFOR	; "FOR" block marker
 1954/ D10 :                            ;	PUSH	R5
 1955/ D10 : 70 E4                      	PUSH	R4		; Save it
 1956/ D12 :                            ;	ADD	SPL,#1
 1957/ D12 :                            ;	ADC	SPH,#0		; Don't save C
 1958/ D12 :                            ;
 1959/ D12 :                            RUNCNT:
 1960/ D12 : D6 0E 1C                   	CALL	TSTBRK		; Execution driver - Test break
 1961/ D15 : 8C 81                      	LD	R8,#hi(BRKLIN)
 1962/ D17 : 9C 1B                      	LD	R9,#lo(BRKLIN)
 1963/ D19 : D2 28                      	LDC	@RR8,R2
 1964/ D1B : A0 E8                      	INCW	RR8
 1965/ D1D : D2 38                      	LDC	@RR8,R3		; Save code address for break
 1966/ D1F : C2 02                      	LDC	R0,@RR2		; Get next byte in code string
 1967/ D21 : A6 E0 3A                   	CP	R0,#':'		; Multi statement line?
 1968/ D24 : 6D 0D 63                   	JP	Z,EXCUTE	; Yes - Execute it
 1969/ D27 : 42 00                      	OR	R0,R0		; End of line?
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 34 - 2023/10/26 22時18分50秒


 1970/ D29 : ED 04 FF                   	JP	NZ,SNERR	; No - Syntax error
 1971/ D2C : A0 E2                      	INCW	RR2		; Point to address of next line
 1972/ D2E : C2 02                      	LDC	R0,@RR2		; Get LSB of line pointer
 1973/ D30 : A0 E2                      	INCW	RR2
 1974/ D32 : C2 12                      	LDC	R1,@RR2
 1975/ D34 : 42 01                      	OR	R0,R1		; Is it zero (End of prog)?
 1976/ D36 : 6D 0E 6F                   	JP	Z,ENDPRG	; Yes - Terminate execution
 1977/ D39 : A0 E2                      	INCW	RR2		; Point to line number
 1978/ D3B : C2 72                      	LDC	R7,@RR2		; Get LSB of line number
 1979/ D3D : A0 E2                      	INCW	RR2
 1980/ D3F : C2 62                      	LDC	R6,@RR2		; Get MSB of line number
 1981/ D41 : 88 E6                      	LD	R8,R6
 1982/ D43 : 98 E7                      	LD	R9,R7
 1983/ D45 : 68 E2                      	LD	R6,R2
 1984/ D47 : 78 E3                      	LD	R7,R3
 1985/ D49 : 28 E8                      	LD	R2,R8
 1986/ D4B : 38 E9                      	LD	R3,R9		; Line number to HL
 1987/ D4D : 8C 80                      	LD	R8,#hi(LINEAT)
 1988/ D4F : 9C A9                      	LD	R9,#lo(LINEAT)
 1989/ D51 : D2 28                      	LDC	@RR8,R2
 1990/ D53 : A0 E8                      	INCW	RR8
 1991/ D55 : D2 38                      	LDC	@RR8,R3		; Save as current line number
 1992/ D57 : 88 E6                      	LD	R8,R6
 1993/ D59 : 98 E7                      	LD	R9,R7
 1994/ D5B : 68 E2                      	LD	R6,R2
 1995/ D5D : 78 E3                      	LD	R7,R3
 1996/ D5F : 28 E8                      	LD	R2,R8
 1997/ D61 : 38 E9                      	LD	R3,R9		; Line number back to DE
 1998/ D63 :                            EXCUTE:
 1999/ D63 : D6 0D AD                   	CALL	GETCHR		; Get key word
 2000/ D66 : 6C 0D                      	LD	R6,#hi(RUNCNT)
 2001/ D68 : 7C 12                      	LD	R7,#lo(RUNCNT)	; Where to RETurn to
 2002/ D6A : 70 E7                      	PUSH	R7
 2003/ D6C : 70 E6                      	PUSH	R6		; Save for RETurn
 2004/ D6E :                            IFJMP:
 2005/ D6E : EB 01                      	JR	NZ,$+3
 2006/ D70 : AF                         	RET			; Go to RUNCNT if end of STMT
 2007/ D71 :                            ONJMP:
 2008/ D71 : 26 E0 80                   	SUB	R0,#ZEND	; Is it a token?
 2009/ D74 : 7D 11 63                   	JP	C,LET		; No - try to assign it
 2010/ D77 : A6 E0 25                   	CP	R0,#ZNEW+1-ZEND	; END to NEW ?
 2011/ D7A : FD 04 FF                   	JP	NC,SNERR	; Not a key word - ?SN Error
 2012/ D7D : 90 E0                      	RL	R0		; Double it
 2013/ D7F : 58 E0                      	LD	R5,R0		; BC = Offset into table
 2014/ D81 : 4C 00                      	LD	R4,#0
 2015/ D83 : 88 E6                      	LD	R8,R6
 2016/ D85 : 98 E7                      	LD	R9,R7
 2017/ D87 : 68 E2                      	LD	R6,R2
 2018/ D89 : 78 E3                      	LD	R7,R3
 2019/ D8B : 28 E8                      	LD	R2,R8
 2020/ D8D : 38 E9                      	LD	R3,R9		; Save code string address
 2021/ D8F : 2C 03                      	LD	R2,#hi(WORDTB)
 2022/ D91 : 3C 1F                      	LD	R3,#lo(WORDTB)	; Keyword address table
 2023/ D93 : 02 35                      	ADD	R3,R5
 2024/ D95 : 12 24                      	ADC	R2,R4		; Point to routine address
 2025/ D97 :                            
 2026/ D97 :                            ;	LDC	R5,@RR2		; Get LSB of routine address
 2027/ D97 : C2 42                      	LDC	R4,@RR2		; Get MSB of routine address
 2028/ D99 :                            
 2029/ D99 : A0 E2                      	INCW	RR2
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 35 - 2023/10/26 22時18分50秒


 2030/ D9B :                            
 2031/ D9B :                            ;	LDC	R4,@RR2		; Get MSB of routine address
 2032/ D9B : C2 52                      	LDC	R5,@RR2		; Get LSB of routine address
 2033/ D9D :                            
 2034/ D9D : 70 E5                      	PUSH	R5
 2035/ D9F : 70 E4                      	PUSH	R4		; Save routine address
 2036/ DA1 : 88 E6                      	LD	R8,R6
 2037/ DA3 : 98 E7                      	LD	R9,R7
 2038/ DA5 : 68 E2                      	LD	R6,R2
 2039/ DA7 : 78 E3                      	LD	R7,R3
 2040/ DA9 : 28 E8                      	LD	R2,R8
 2041/ DAB : 38 E9                      	LD	R3,R9		; Restore code string address
 2042/ DAD :                            ;
 2043/ DAD :                            GETCHR:
 2044/ DAD : A0 E2                      	INCW	RR2		; Point to next character
 2045/ DAF : C2 02                      	LDC	R0,@RR2		; Get next code string byte
 2046/ DB1 : A6 E0 3A                   	CP	R0,#':'		; Z if ':'
 2047/ DB4 : 7B 01                      	JR	C,$+3
 2048/ DB6 : AF                         	RET			; NC if > "9"
 2049/ DB7 : A6 E0 20                   	CP	R0,#' '
 2050/ DBA : 6D 0D AD                   	JP	Z,GETCHR	; Skip over spaces
 2051/ DBD : A6 E0 30                   	CP	R0,#'0'
 2052/ DC0 : EF                         	CCF			; NC if < '0'
 2053/ DC1 : 0E                         	INC	R0		; Test for zero - Leave carry
 2054/ DC2 : 00 E0                      	DEC	R0		; Z if Null
 2055/ DC4 : AF                         	RET
 2056/ DC5 :                            ;
 2057/ DC5 :                            RESTOR:
 2058/ DC5 : 88 E6                      	LD	R8,R6
 2059/ DC7 : 98 E7                      	LD	R9,R7
 2060/ DC9 : 68 E2                      	LD	R6,R2
 2061/ DCB : 78 E3                      	LD	R7,R3
 2062/ DCD : 28 E8                      	LD	R2,R8
 2063/ DCF : 38 E9                      	LD	R3,R9		; Save code string address
 2064/ DD1 : 8C 80                      	LD	R8,#hi(BASTXT)
 2065/ DD3 : 9C AB                      	LD	R9,#lo(BASTXT)
 2066/ DD5 : C2 28                      	LDC	R2,@RR8
 2067/ DD7 : 18 FC                      	LD	R1,FLAGS
 2068/ DD9 : A0 E8                      	INCW	RR8
 2069/ DDB : 19 FC                      	LD	FLAGS,R1
 2070/ DDD : C2 38                      	LDC	R3,@RR8		; Point to start of program
 2071/ DDF : 6D 0E 03                   	JP	Z,RESTNL	; Just RESTORE - reset pointer
 2072/ DE2 : 88 E6                      	LD	R8,R6
 2073/ DE4 : 98 E7                      	LD	R9,R7
 2074/ DE6 : 68 E2                      	LD	R6,R2
 2075/ DE8 : 78 E3                      	LD	R7,R3
 2076/ DEA : 28 E8                      	LD	R2,R8
 2077/ DEC : 38 E9                      	LD	R3,R9		; Restore code string address
 2078/ DEE : D6 0F 80                   	CALL	ATOH		; Get line number to DE
 2079/ DF1 : 70 E3                      	PUSH	R3
 2080/ DF3 : 70 E2                      	PUSH	R2		; Save code string address
 2081/ DF5 : D6 06 D9                   	CALL	SRCHLN		; Search for line number in DE
 2082/ DF8 : 28 E4                      	LD	R2,R4		; HL = Address of line
 2083/ DFA : 38 E5                      	LD	R3,R5
 2084/ DFC : 50 E6                      	POP	R6
 2085/ DFE : 50 E7                      	POP	R7		; Restore code string address
 2086/ E00 : FD 10 ED                   	JP	NC,ULERR	; ?UL Error if not found
 2087/ E03 :                            RESTNL:
 2088/ E03 :                            ;	LD	R1,FLAGS
 2089/ E03 : 80 E2                      	DECW	RR2		; Byte before DATA statement
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 36 - 2023/10/26 22時18分50秒


 2090/ E05 :                            ;	LD	FLAGS,R1
 2091/ E05 :                            UPDATA:
 2092/ E05 : 8C 81                      	LD	R8,#hi(NXTDAT)
 2093/ E07 : 9C 29                      	LD	R9,#lo(NXTDAT)
 2094/ E09 : D2 28                      	LDC	@RR8,R2
 2095/ E0B :                            ;	LD	R1,FLAGS
 2096/ E0B : A0 E8                      	INCW	RR8
 2097/ E0D :                            ;	LD	FLAGS,R1
 2098/ E0D : D2 38                      	LDC	@RR8,R3		; Update DATA pointer
 2099/ E0F : 88 E6                      	LD	R8,R6
 2100/ E11 : 98 E7                      	LD	R9,R7
 2101/ E13 : 68 E2                      	LD	R6,R2
 2102/ E15 : 78 E3                      	LD	R7,R3
 2103/ E17 : 28 E8                      	LD	R2,R8
 2104/ E19 : 38 E9                      	LD	R3,R9		; Restore code string address
 2105/ E1B : AF                         	RET
 2106/ E1C :                            ;
 2107/ E1C :                            
 2108/ E1C :                            TSTBRK:
 2109/ E1C : D6 00 49                   	CALL	CONST		; Check input status
 2110/ E1F : EB 01                      	JR	NZ,$+3
 2111/ E21 : AF                         	RET			; No key, go back
 2112/ E22 : D6 00 3C                   	CALL	CONIN		; Get the key into A
 2113/ E25 : A6 E0 1B                   	CP	R0,#ESC		; Escape key?
 2114/ E28 : 6B 1B                      	JR	Z,BRK		; Yes, break
 2115/ E2A : A6 E0 03                   	CP	R0,#CTRLC		; <Ctrl-C>
 2116/ E2D : 6B 16                      	JR	Z,BRK		; Yes, break
 2117/ E2F : A6 E0 13                   	CP	R0,#CTRLS		; Stop scrolling?
 2118/ E32 : 6B 01                      	JR	Z,$+3
 2119/ E34 : AF                         	RET			; Other key, ignore
 2120/ E35 :                            ;
 2121/ E35 :                            
 2122/ E35 :                            STALL:
 2123/ E35 : D6 00 3C                   	CALL	CONIN		; Wait for key
 2124/ E38 : A6 E0 11                   	CP	R0,#CTRLQ	; Resume scrolling?
 2125/ E3B : EB 01                      	JR	NZ,$+3
 2126/ E3D : AF                         	RET			; Release the chokehold
 2127/ E3E : A6 E0 03                   	CP	R0,#CTRLC	; Second break?
 2128/ E41 : 6B 0A                      	JR	Z,STOP		; Break during hold exits prog
 2129/ E43 : 8B F0                      	JR	STALL		; Loop until <Ctrl-Q> or <brk>
 2130/ E45 :                            ;
 2131/ E45 :                            BRK:
 2132/ E45 : 0C FF                      	LD	R0,#0FFH	; Set BRKFLG
 2133/ E47 : 8C 80                      	LD	R8,#hi(BRKFLG)
 2134/ E49 : 9C 9A                      	LD	R9,#lo(BRKFLG)
 2135/ E4B : D2 08                      	LDC	@RR8,R0		; Store it
 2136/ E4D :                            ;
 2137/ E4D :                            
 2138/ E4D :                            STOP:
 2139/ E4D : 6B 01                      	JR	Z,$+3
 2140/ E4F : AF                         	RET			; Exit if anything else
 2141/ E50 : 46 E0 C0                   	OR	R0,#0C0H	; Flag "STOP"
 2142/ E53 : 8B 03                      	JR	PEND1
 2143/ E55 :                            PEND:
 2144/ E55 : 6B 01                      	JR	Z,$+3
 2145/ E57 : AF                         	RET			; Exit if anything else
 2146/ E58 :                            PEND1:
 2147/ E58 : 8C 81                      	LD	R8,#hi(BRKLIN)
 2148/ E5A : 9C 1B                      	LD	R9,#lo(BRKLIN)
 2149/ E5C : D2 28                      	LDC	@RR8,R2
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 37 - 2023/10/26 22時18分50秒


 2150/ E5E : 18 FC                      	LD	R1,FLAGS
 2151/ E60 : A0 E8                      	INCW	RR8
 2152/ E62 : 19 FC                      	LD	FLAGS,R1
 2153/ E64 : D2 38                      	LDC	@RR8,R3		; Save point of break
 2154/ E66 : 8B 03                      	JR	INPBRK1		; Skip "OR 11111111B"
 2155/ E68 :                            INPBRK:
 2156/ E68 : 46 E0 FF                   	OR	R0,#11111111B	; Flag "Break" wanted
 2157/ E6B :                            INPBRK1:
 2158/ E6B : 50 E4                      	POP	R4
 2159/ E6D : 50 E5                      	POP	R5		; Return not needed and more
 2160/ E6F :                            ENDPRG:
 2161/ E6F : 8C 80                      	LD	R8,#hi(LINEAT)
 2162/ E71 : 9C A9                      	LD	R9,#lo(LINEAT)
 2163/ E73 : C2 28                      	LDC	R2,@RR8
 2164/ E75 : 18 FC                      	LD	R1,FLAGS
 2165/ E77 : A0 E8                      	INCW	RR8
 2166/ E79 : 19 FC                      	LD	FLAGS,R1
 2167/ E7B : C2 38                      	LDC	R3,@RR8		; Get current line number
 2168/ E7D : 18 FC                      	LD	R1,FLAGS
 2169/ E7F : 70 E1                      	PUSH	R1		; Save STOP / END status
 2170/ E81 : 70 E0                      	PUSH	R0
 2171/ E83 : 08 E3                      	LD	R0,R3		; Is it direct break?
 2172/ E85 : 52 02                      	AND	R0,R2
 2173/ E87 : 0E                         	INC	R0		; Line is -1 if direct break
 2174/ E88 : 6D 0E A9                   	JP	Z,NOLIN		; Yes - No line number
 2175/ E8B : 8C 81                      	LD	R8,#hi(ERRLIN)
 2176/ E8D : 9C 1F                      	LD	R9,#lo(ERRLIN)
 2177/ E8F : D2 28                      	LDC	@RR8,R2
 2178/ E91 : A0 E8                      	INCW	RR8
 2179/ E93 : D2 38                      	LDC	@RR8,R3		; Save line of break
 2180/ E95 : 8C 81                      	LD	R8,#hi(BRKLIN)
 2181/ E97 : 9C 1B                      	LD	R9,#lo(BRKLIN)
 2182/ E99 : C2 28                      	LDC	R2,@RR8
 2183/ E9B : A0 E8                      	INCW	RR8
 2184/ E9D : C2 38                      	LDC	R3,@RR8		; Get point of break
 2185/ E9F : 8C 81                      	LD	R8,#hi(CONTAD)
 2186/ EA1 : 9C 21                      	LD	R9,#lo(CONTAD)
 2187/ EA3 : D2 28                      	LDC	@RR8,R2
 2188/ EA5 : A0 E8                      	INCW	RR8
 2189/ EA7 : D2 38                      	LDC	@RR8,R3		; Save point to CONTinue
 2190/ EA9 :                            NOLIN:
 2191/ EA9 : B2 00                      	XOR	R0,R0
 2192/ EAB : 8C 80                      	LD	R8,#hi(CTLOFG)
 2193/ EAD : 9C 92                      	LD	R9,#lo(CTLOFG)
 2194/ EAF : D2 08                      	LDC	@RR8,R0		; Enable output
 2195/ EB1 : D6 13 04                   	CALL	STTLIN		; Start a new line
 2196/ EB4 : 50 E0                      	POP	R0
 2197/ EB6 : 50 E1                      	POP	R1		; Restore STOP / END status
 2198/ EB8 : 19 FC                      	LD	FLAGS,R1
 2199/ EBA : 2C 04                      	LD	R2,#hi(BRKMSG)
 2200/ EBC : 3C 22                      	LD	R3,#lo(BRKMSG)	; "Break" message
 2201/ EBE : ED 05 43                   	JP	NZ,ERRIN	; "in line" wanted?
 2202/ EC1 : 8D 05 6A                   	JP	PRNTOK		; Go to command mode
 2203/ EC4 :                            ;
 2204/ EC4 :                            CONT:
 2205/ EC4 : 8C 81                      	LD	R8,#hi(CONTAD)
 2206/ EC6 : 9C 21                      	LD	R9,#lo(CONTAD)
 2207/ EC8 : C2 28                      	LDC	R2,@RR8
 2208/ ECA : A0 E8                      	INCW	RR8
 2209/ ECC : C2 38                      	LDC	R3,@RR8		; Get CONTinue address
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 38 - 2023/10/26 22時18分50秒


 2210/ ECE : 08 E2                      	LD	R0,R2		; Is it zero?
 2211/ ED0 : 42 03                      	OR	R0,R3
 2212/ ED2 : 7C 20                      	LD	R7,#CN		; ?CN Error
 2213/ ED4 : 6D 05 19                   	JP	Z,ERROR		; Yes - output "?CN Error"
 2214/ ED7 : 88 E6                      	LD	R8,R6
 2215/ ED9 : 98 E7                      	LD	R9,R7
 2216/ EDB : 68 E2                      	LD	R6,R2
 2217/ EDD : 78 E3                      	LD	R7,R3
 2218/ EDF : 28 E8                      	LD	R2,R8
 2219/ EE1 : 38 E9                      	LD	R3,R9		; Save code string address
 2220/ EE3 : 8C 81                      	LD	R8,#hi(ERRLIN)
 2221/ EE5 : 9C 1F                      	LD	R9,#lo(ERRLIN)
 2222/ EE7 : C2 28                      	LDC	R2,@RR8
 2223/ EE9 : 18 FC                      	LD	R1,FLAGS
 2224/ EEB : A0 E8                      	INCW	RR8
 2225/ EED :                            ;	LD	FLAGS,R1
 2226/ EED : C2 38                      	LDC	R3,@RR8		; Get line of last break
 2227/ EEF : 8C 80                      	LD	R8,#hi(LINEAT)
 2228/ EF1 : 9C A9                      	LD	R9,#lo(LINEAT)
 2229/ EF3 : D2 28                      	LDC	@RR8,R2
 2230/ EF5 :                            ;	LD	R1,FLAGS
 2231/ EF5 : A0 E8                      	INCW	RR8
 2232/ EF7 : 19 FC                      	LD	FLAGS,R1
 2233/ EF9 : D2 38                      	LDC	@RR8,R3		; Set up current line number
 2234/ EFB : 88 E6                      	LD	R8,R6
 2235/ EFD : 98 E7                      	LD	R9,R7
 2236/ EFF : 68 E2                      	LD	R6,R2
 2237/ F01 : 78 E3                      	LD	R7,R3
 2238/ F03 : 28 E8                      	LD	R2,R8
 2239/ F05 : 38 E9                      	LD	R3,R9		; Restore code string address
 2240/ F07 : AF                         	RET			; CONTinue where left off
 2241/ F08 :                            ;
 2242/ F08 :                            NULL:
 2243/ F08 : D6 26 EB                   	CALL	GETINT		; Get integer 0-255
 2244/ F0B : 6B 01                      	JR	Z,$+3
 2245/ F0D : AF                         	RET			; Return if bad value
 2246/ F0E : 8C 80                      	LD	R8,#hi(NULLS)
 2247/ F10 : 9C 8E                      	LD	R9,#lo(NULLS)
 2248/ F12 : D2 08                      	LDC	@RR8,R0		; Set nulls number
 2249/ F14 : AF                         	RET
 2250/ F15 :                            ;
 2251/ F15 :                            
 2252/ F15 :                            ACCSUM:
 2253/ F15 : 70 E3                      	PUSH	R3
 2254/ F17 : 70 E2                      	PUSH	R2		; Save address in array
 2255/ F19 : 8C 80                      	LD	R8,#hi(CHKSUM)
 2256/ F1B : 9C 97                      	LD	R9,#lo(CHKSUM)
 2257/ F1D : C2 28                      	LDC	R2,@RR8
 2258/ F1F : A0 E8                      	INCW	RR8
 2259/ F21 : C2 38                      	LDC	R3,@RR8		; Get check sum
 2260/ F23 : 4C 00                      	LD	R4,#0		; BC - Value of byte
 2261/ F25 : 58 E0                      	LD	R5,R0
 2262/ F27 : 02 35                      	ADD	R3,R5
 2263/ F29 : 12 24                      	ADC	R2,R4		; Add byte to check sum
 2264/ F2B : 8C 80                      	LD	R8,#hi(CHKSUM)
 2265/ F2D : 9C 97                      	LD	R9,#lo(CHKSUM)
 2266/ F2F : D2 28                      	LDC	@RR8,R2
 2267/ F31 : 18 FC                      	LD	R1,FLAGS
 2268/ F33 : A0 E8                      	INCW	RR8
 2269/ F35 : 19 FC                      	LD	FLAGS,R1
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 39 - 2023/10/26 22時18分50秒


 2270/ F37 : D2 38                      	LDC	@RR8,R3		; Re-save check sum
 2271/ F39 : 50 E2                      	POP	R2
 2272/ F3B : 50 E3                      	POP	R3		; Restore address in array
 2273/ F3D : AF                         	RET
 2274/ F3E :                            ;
 2275/ F3E :                            CHKLTR:
 2276/ F3E : C2 02                      	LDC	R0,@RR2		; Get byte
 2277/ F40 : A6 E0 41                   	CP	R0,#'A'		; < 'a' ?
 2278/ F43 : FB 01                      	JR	NC,$+3
 2279/ F45 : AF                         	RET			; Carry set if not letter
 2280/ F46 : A6 E0 5B                   	CP	R0,#'Z'+1	; > 'z' ?
 2281/ F49 : EF                         	CCF
 2282/ F4A : AF                         	RET			; Carry set if not letter
 2283/ F4B :                            ;
 2284/ F4B :                            FPSINT:
 2285/ F4B : D6 0D AD                   	CALL	GETCHR		; Get next character
 2286/ F4E :                            POSINT:
 2287/ F4E : D6 16 7D                   	CALL	GETNUM		; Get integer 0 to 32767
 2288/ F51 :                            DEPINT:
 2289/ F51 : D6 2B 76                   	CALL	TSTSGN		; Test sign of FPREG
 2290/ F54 : 5D 0F 7B                   	JP	MI,FCERR	; Negative - ?FC Error
 2291/ F57 :                            DEINT:
 2292/ F57 : 8C 81                      	LD	R8,#hi(FPEXP)
 2293/ F59 : 9C 34                      	LD	R9,#lo(FPEXP)
 2294/ F5B : C2 08                      	LDC	R0,@RR8		; Get integer value to DE
 2295/ F5D : A6 E0 90                   	CP	R0,#80H+16	; Exponent in range (16 bits)?
 2296/ F60 : 7D 2C BC                   	JP	C,FPINT		; Yes - convert it
 2297/ F63 : 4C 90                      	LD	R4,#hi(9080H)
 2298/ F65 : 5C 80                      	LD	R5,#lo(9080H)	; BCDE = -32768
 2299/ F67 : 6C 00                      	LD	R6,#hi(0000H)
 2300/ F69 : 7C 00                      	LD	R7,#lo(0000H)
 2301/ F6B : 70 E3                      	PUSH	R3
 2302/ F6D : 70 E2                      	PUSH	R2		; Save code string address
 2303/ F6F : D6 2C 5A                   	CALL	CMPNUM		; Compare FPREG with BCDE
 2304/ F72 : 50 E2                      	POP	R2
 2305/ F74 : 50 E3                      	POP	R3		; Restore code string address
 2306/ F76 : 68 E5                      	LD	R6,R5		; MSB to D
 2307/ F78 : EB 01                      	JR	NZ,$+3
 2308/ F7A : AF                         	RET			; Return if in range
 2309/ F7B :                            FCERR:
 2310/ F7B : 7C 08                      	LD	R7,#FC		; ?FC Error
 2311/ F7D : 8D 05 19                   	JP	ERROR		; Output error-
 2312/ F80 :                            ;
 2313/ F80 :                            ATOH:
 2314/ F80 : 18 FC                      	LD	R1,FLAGS
 2315/ F82 : 80 E2                      	DECW	RR2		; ASCII number to DE binary
 2316/ F84 : 19 FC                      	LD	FLAGS,R1
 2317/ F86 :                            GETLN:
 2318/ F86 : 6C 00                      	LD	R6,#hi(0)
 2319/ F88 : 7C 00                      	LD	R7,#lo(0)	; Get number to DE
 2320/ F8A :                            GTLNLP:
 2321/ F8A : D6 0D AD                   	CALL	GETCHR		; Get next character
 2322/ F8D : 7B 01                      	JR	C,$+3
 2323/ F8F : AF                         	RET			; Exit if not a digit
 2324/ F90 : 70 E3                      	PUSH	R3
 2325/ F92 : 70 E2                      	PUSH	R2		; Save code string address
 2326/ F94 :                            ;	LD	R1,FLAGS
 2327/ F94 :                            ;	PUSH	R1
 2328/ F94 : 70 E0                      	PUSH	R0		; Save digit
 2329/ F96 : 2C 19                      	LD	R2,#hi(65529/10)
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 40 - 2023/10/26 22時18分50秒


 2330/ F98 : 3C 98                      	LD	R3,#lo(65529/10); Largest number 65529
 2331/ F9A : D6 0A 3D                   	CALL	CPDEHL		; Number in range?
 2332/ F9D : 7D 04 FF                   	JP	C,SNERR		; No - ?SN Error
 2333/ FA0 : 28 E6                      	LD	R2,R6		; HL = Number
 2334/ FA2 : 38 E7                      	LD	R3,R7
 2335/ FA4 : 02 37                      	ADD	R3,R7
 2336/ FA6 : 12 26                      	ADC	R2,R6		; Times 2
 2337/ FA8 : 02 33                      	ADD	R3,R3
 2338/ FAA : 12 22                      	ADC	R2,R2		; Times 4
 2339/ FAC : 02 37                      	ADD	R3,R7
 2340/ FAE : 12 26                      	ADC	R2,R6		; Times 5
 2341/ FB0 : 02 33                      	ADD	R3,R3
 2342/ FB2 : 12 22                      	ADC	R2,R2		; Times 10
 2343/ FB4 : 50 E0                      	POP	R0		; Restore digit
 2344/ FB6 :                            ;	POP	R1
 2345/ FB6 :                            ;	LD	FLAGS,R1
 2346/ FB6 : 26 E0 30                   	SUB	R0,#'0'		; Make it 0 to 9
 2347/ FB9 : 78 E0                      	LD	R7,R0		; DE = Value of digit
 2348/ FBB : 6C 00                      	LD	R6,#0
 2349/ FBD : 02 37                      	ADD	R3,R7
 2350/ FBF : 12 26                      	ADC	R2,R6		; Add to number
 2351/ FC1 : 88 E6                      	LD	R8,R6
 2352/ FC3 : 98 E7                      	LD	R9,R7
 2353/ FC5 : 68 E2                      	LD	R6,R2
 2354/ FC7 : 78 E3                      	LD	R7,R3
 2355/ FC9 : 28 E8                      	LD	R2,R8
 2356/ FCB : 38 E9                      	LD	R3,R9		; Number to DE
 2357/ FCD : 50 E2                      	POP	R2
 2358/ FCF : 50 E3                      	POP	R3		; Restore code string address
 2359/ FD1 : 8D 0F 8A                   	JP	GTLNLP		; Go to next character
 2360/ FD4 :                            ;
 2361/ FD4 :                            CLEAR:
 2362/ FD4 : 6D 07 4F                   	JP	Z,INTVAR	; Just "CLEAR" Keep parameters
 2363/ FD7 : D6 0F 4E                   	CALL	POSINT		; Get integer 0 to 32767 to DE
 2364/ FDA : 80 E2                      	DECW	RR2		; Cancel increment
 2365/ FDC : D6 0D AD                   	CALL	GETCHR		; Get next character
 2366/ FDF : 70 E3                      	PUSH	R3
 2367/ FE1 : 70 E2                      	PUSH	R2		; Save code string address
 2368/ FE3 : 8C 80                      	LD	R8,#hi(LSTRAM)
 2369/ FE5 : 9C FC                      	LD	R9,#lo(LSTRAM)
 2370/ FE7 : C2 28                      	LDC	R2,@RR8
 2371/ FE9 : 18 FC                      	LD	R1,FLAGS
 2372/ FEB : A0 E8                      	INCW	RR8
 2373/ FED : 19 FC                      	LD	FLAGS,R1
 2374/ FEF : C2 38                      	LDC	R3,@RR8		; Get end of RAM
 2375/ FF1 : 6D 10 23                   	JP	Z,STORED	; No value given - Use stored
 2376/ FF4 : 50 E2                      	POP	R2
 2377/ FF6 : 50 E3                      	POP	R3		; Restore code string address
 2378/ FF8 : D6 0A 49                   	CALL	CHKSYN		; Check for comma
 2379/ FFB : 2C                         	DB	','
 2380/ FFC : 70 E7                      	PUSH	R7
 2381/ FFE : 70 E6                      	PUSH	R6		; Save number
 2382/1000 : D6 0F 4E                   	CALL	POSINT		; Get integer 0 to 32767
 2383/1003 : 80 E2                      	DECW	RR2		; Cancel increment
 2384/1005 : D6 0D AD                   	CALL	GETCHR		; Get next character
 2385/1008 : ED 04 FF                   	JP	NZ,SNERR	; ?SN Error if more on line
 2386/100B : 50 E8                      	POP	R8
 2387/100D : 50 E9                      	POP	R9
 2388/100F : 70 E3                      	PUSH	R3
 2389/1011 : 70 E2                      	PUSH	R2
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 41 - 2023/10/26 22時18分50秒


 2390/1013 : 28 E8                      	LD	R2,R8
 2391/1015 : 38 E9                      	LD	R3,R9		; Save code string address
 2392/1017 : 88 E6                      	LD	R8,R6
 2393/1019 : 98 E7                      	LD	R9,R7
 2394/101B : 68 E2                      	LD	R6,R2
 2395/101D : 78 E3                      	LD	R7,R3
 2396/101F : 28 E8                      	LD	R2,R8
 2397/1021 : 38 E9                      	LD	R3,R9		; Number to DE
 2398/1023 :                            STORED:
 2399/1023 : 08 E3                      	LD	R0,R3		; Get LSB of new RAM top
 2400/1025 : 22 07                      	SUB	R0,R7		; Subtract LSB of string space
 2401/1027 : 78 E0                      	LD	R7,R0		; Save LSB
 2402/1029 : 08 E2                      	LD	R0,R2		; Get MSB of new RAM top
 2403/102B : 32 06                      	SBC	R0,R6		; Subtract MSB of string space
 2404/102D : 68 E0                      	LD	R6,R0		; Save MSB
 2405/102F : 7D 04 E6                   	JP	C,OMERR		; ?OM Error if not enough mem
 2406/1032 : 70 E3                      	PUSH	R3
 2407/1034 : 70 E2                      	PUSH	R2		; Save RAM top
 2408/1036 : 8C 81                      	LD	R8,#hi(PROGND)
 2409/1038 : 9C 23                      	LD	R9,#lo(PROGND)
 2410/103A : C2 28                      	LDC	R2,@RR8
 2411/103C : A0 E8                      	INCW	RR8
 2412/103E : C2 38                      	LDC	R3,@RR8		; Get program end
 2413/1040 : 4C 00                      	LD	R4,#hi(40)
 2414/1042 : 5C 28                      	LD	R5,#lo(40)	; 40 Bytes minimum working RAM
 2415/1044 : 02 35                      	ADD	R3,R5
 2416/1046 : 12 24                      	ADC	R2,R4		; Get lowest address
 2417/1048 : D6 0A 3D                   	CALL	CPDEHL		; Enough memory?
 2418/104B : FD 04 E6                   	JP	NC,OMERR	; No - ?OM Error
 2419/104E : 88 E6                      	LD	R8,R6
 2420/1050 : 98 E7                      	LD	R9,R7
 2421/1052 : 68 E2                      	LD	R6,R2
 2422/1054 : 78 E3                      	LD	R7,R3
 2423/1056 : 28 E8                      	LD	R2,R8
 2424/1058 : 38 E9                      	LD	R3,R9		; RAM top to HL
 2425/105A : 8C 80                      	LD	R8,#hi(STRSPC)
 2426/105C : 9C A7                      	LD	R9,#lo(STRSPC)
 2427/105E : D2 28                      	LDC	@RR8,R2
 2428/1060 : A0 E8                      	INCW	RR8
 2429/1062 : D2 38                      	LDC	@RR8,R3		; Set new string space
 2430/1064 : 50 E2                      	POP	R2
 2431/1066 : 50 E3                      	POP	R3		; End of memory to use
 2432/1068 : 8C 80                      	LD	R8,#hi(LSTRAM)
 2433/106A : 9C FC                      	LD	R9,#lo(LSTRAM)
 2434/106C : D2 28                      	LDC	@RR8,R2
 2435/106E : A0 E8                      	INCW	RR8
 2436/1070 : D2 38                      	LDC	@RR8,R3		; Set new top of RAM
 2437/1072 : 50 E2                      	POP	R2
 2438/1074 : 50 E3                      	POP	R3		; Restore code string address
 2439/1076 : 8D 07 4F                   	JP	INTVAR		; Initialise variables
 2440/1079 :                            ;
 2441/1079 :                            RUN:
 2442/1079 : 6D 07 43                   	JP	Z,RUNFST	; RUN from start if just RUN
 2443/107C : D6 07 4F                   	CALL	INTVAR		; Initialise variables
 2444/107F : 4C 0D                      	LD	R4,#hi(RUNCNT)
 2445/1081 : 5C 12                      	LD	R5,#lo(RUNCNT)	; Execution driver loop
 2446/1083 : 8D 10 B1                   	JP	RUNLIN		; RUN from line number
 2447/1086 :                            ;
 2448/1086 :                            GOSUB:
 2449/1086 : 5C 03                      	LD	R5,#3		; 3 Levels of stack needed
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 42 - 2023/10/26 22時18分50秒


 2450/1088 : D6 04 AC                   	CALL	CHKSTK		; Check for 3 levels of stack
 2451/108B : 50 E4                      	POP	R4
 2452/108D : 50 E5                      	POP	R5		; Get return address
 2453/108F : 70 E3                      	PUSH	R3
 2454/1091 : 70 E2                      	PUSH	R2		; Save code string for RETURN
 2455/1093 : 70 E3                      	PUSH	R3
 2456/1095 : 70 E2                      	PUSH	R2		; And for GOSUB routine
 2457/1097 : 8C 80                      	LD	R8,#hi(LINEAT)
 2458/1099 : 9C A9                      	LD	R9,#lo(LINEAT)
 2459/109B : C2 28                      	LDC	R2,@RR8
 2460/109D : A0 E8                      	INCW	RR8
 2461/109F : C2 38                      	LDC	R3,@RR8		; Get current line
 2462/10A1 : 50 E8                      	POP	R8
 2463/10A3 : 50 E9                      	POP	R9
 2464/10A5 : 70 E3                      	PUSH	R3
 2465/10A7 : 70 E2                      	PUSH	R2
 2466/10A9 : 28 E8                      	LD	R2,R8
 2467/10AB : 38 E9                      	LD	R3,R9		; Into stack - Code string out
 2468/10AD : 0C 8C                      	LD	R0,#ZGOSUB	; "GOSUB" token
 2469/10AF :                            ;	LD	R1,FLAGS
 2470/10AF :                            ;	PUSH	R1
 2471/10AF : 70 E0                      	PUSH	R0		; Save token
 2472/10B1 :                            ;	ADD	SPL,#1		; Don't save flags
 2473/10B1 :                            ;	ADC	SPH,#0
 2474/10B1 :                            ;
 2475/10B1 :                            RUNLIN:
 2476/10B1 : 70 E5                      	PUSH	R5
 2477/10B3 : 70 E4                      	PUSH	R4		; Save return address
 2478/10B5 :                            GOTO:
 2479/10B5 : D6 0F 80                   	CALL	ATOH		; ASCII number to DE binary
 2480/10B8 : D6 11 42                   	CALL	REM		; Get end of line
 2481/10BB : 70 E3                      	PUSH	R3
 2482/10BD : 70 E2                      	PUSH	R2		; Save end of line
 2483/10BF : 8C 80                      	LD	R8,#hi(LINEAT)
 2484/10C1 : 9C A9                      	LD	R9,#lo(LINEAT)
 2485/10C3 : C2 28                      	LDC	R2,@RR8
 2486/10C5 : A0 E8                      	INCW	RR8
 2487/10C7 : C2 38                      	LDC	R3,@RR8		; Get current line
 2488/10C9 : D6 0A 3D                   	CALL	CPDEHL		; Line after current?
 2489/10CC : 50 E2                      	POP	R2
 2490/10CE : 50 E3                      	POP	R3		; Restore end of line
 2491/10D0 : 18 FC                      	LD	R1,FLAGS
 2492/10D2 : A0 E2                      	INCW	RR2		; Start of next line
 2493/10D4 : 19 FC                      	LD	FLAGS,R1
 2494/10D6 : FB 03                      	JR	NC,$+5
 2495/10D8 : D6 06 E3                   	CALL	SRCHLP		; Line is after current line
 2496/10DB : 7B 03                      	JR	C,$+5
 2497/10DD : D6 06 D9                   	CALL	SRCHLN		; Line is before current line
 2498/10E0 : 28 E4                      	LD	R2,R4		; Set up code string address
 2499/10E2 : 38 E5                      	LD	R3,R5
 2500/10E4 : 18 FC                      	LD	R1,FLAGS
 2501/10E6 : 80 E2                      	DECW	RR2		; Incremented after
 2502/10E8 : 19 FC                      	LD	FLAGS,R1
 2503/10EA : FB 01                      	JR	NC,$+3
 2504/10EC : AF                         	RET			; Line found
 2505/10ED :                            ULERR:
 2506/10ED : 7C 0E                      	LD	R7,#UL		; ?UL Error
 2507/10EF : 8D 05 19                   	JP	ERROR		; Output error message
 2508/10F2 :                            ;
 2509/10F2 :                            RETURN:
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 43 - 2023/10/26 22時18分50秒


 2510/10F2 : 6B 01                      	JR	Z,$+3
 2511/10F4 : AF                         	RET			; Return if not just RETURN
 2512/10F5 : 6C FF                      	LD	R6,#-1		; Flag "GOSUB" search
 2513/10F7 : D6 04 28                   	CALL	BAKSTK		; Look "GOSUB" block
 2514/10FA : 29 FE                      	LD	SPH,R2
 2515/10FC : 39 FF                      	LD	SPL,R3		; Kill all FORs in subroutine
 2516/10FE : A6 E0 8C                   	CP	R0,#ZGOSUB	; Test for "GOSUB" token
 2517/1101 : 7C 04                      	LD	R7,#RG		; ?RG Error
 2518/1103 : ED 05 19                   	JP	NZ,ERROR	; Error if no "GOSUB" found
 2519/1106 : 50 E2                      	POP	R2
 2520/1108 : 50 E3                      	POP	R3		; Get RETURN line number
 2521/110A : 8C 80                      	LD	R8,#hi(LINEAT)
 2522/110C : 9C A9                      	LD	R9,#lo(LINEAT)
 2523/110E : D2 28                      	LDC	@RR8,R2
 2524/1110 : A0 E8                      	INCW	RR8
 2525/1112 : D2 38                      	LDC	@RR8,R3		; Save as current
 2526/1114 : A0 E2                      	INCW	RR2		; Was it from direct statement?
 2527/1116 : 08 E2                      	LD	R0,R2
 2528/1118 : 42 03                      	OR	R0,R3		; Return to line
 2529/111A : ED 11 28                   	JP	NZ,RETLIN	; No - Return to line
 2530/111D : 8C 81                      	LD	R8,#hi(LSTBIN)
 2531/111F : 9C 19                      	LD	R9,#lo(LSTBIN)
 2532/1121 : C2 08                      	LDC	R0,@RR8		; Any INPUT in subroutine?
 2533/1123 : 42 00                      	OR	R0,R0		; If so buffer is corrupted
 2534/1125 : ED 05 66                   	JP	NZ,POPNOK	; Yes - Go to command mode
 2535/1128 :                            RETLIN:
 2536/1128 : 2C 0D                      	LD	R2,#hi(RUNCNT)
 2537/112A : 3C 12                      	LD	R3,#lo(RUNCNT)	; Execution driver loop
 2538/112C : 50 E8                      	POP	R8
 2539/112E : 50 E9                      	POP	R9
 2540/1130 : 70 E3                      	PUSH	R3
 2541/1132 : 70 E2                      	PUSH	R2
 2542/1134 : 28 E8                      	LD	R2,R8
 2543/1136 : 38 E9                      	LD	R3,R9		; Into stack - Code string out
 2544/1138 : 8B 04                      	JR	DATA		; Skip "POP HL"
 2545/113A :                            NXTDTA:
 2546/113A : 50 E2                      	POP	R2
 2547/113C : 50 E3                      	POP	R3		; Restore code string address
 2548/113E :                            ;
 2549/113E :                            DATA:
 2550/113E : 5C 3A                      	LD	R5,#':'		; ':' End of statement
 2551/1140 : 8B 02                      	JR	REM1
 2552/1142 :                            REM:
 2553/1142 : 5C 00                      	LD	R5,#0		; 00	End of statement
 2554/1144 :                            REM1:
 2555/1144 : 4C 00                      	LD	R4,#0
 2556/1146 :                            NXTSTL:
 2557/1146 : 08 E5                      	LD	R0,R5		; Statement and byte
 2558/1148 : 58 E4                      	LD	R5,R4
 2559/114A : 48 E0                      	LD	R4,R0		; Statement end byte
 2560/114C :                            NXTSTT:
 2561/114C : C2 02                      	LDC	R0,@RR2		; Get byte
 2562/114E : 42 00                      	OR	R0,R0		; End of line?
 2563/1150 : EB 01                      	JR	NZ,$+3
 2564/1152 : AF                         	RET			; Yes - Exit
 2565/1153 : A2 04                      	CP	R0,R4		; End of statement?
 2566/1155 : EB 01                      	JR	NZ,$+3
 2567/1157 : AF                         	RET			; Yes - Exit
 2568/1158 : A0 E2                      	INCW	RR2		; Next byte
 2569/115A : A6 E0 22                   	CP	R0,#'"'		; Literal string?
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 44 - 2023/10/26 22時18分50秒


 2570/115D : 6D 11 46                   	JP	Z,NXTSTL	; Yes - Look for another '"'
 2571/1160 : 8D 11 4C                   	JP	NXTSTT		; Keep looking
 2572/1163 :                            ;
 2573/1163 :                            LET:
 2574/1163 : D6 1A 60                   	CALL	GETVAR		; Get variable name
 2575/1166 : D6 0A 49                   	CALL	CHKSYN		; Make sure "=" follows
 2576/1169 : B4                         	DB	ZEQUAL		; "=" token
 2577/116A : 70 E7                      	PUSH	R7
 2578/116C : 70 E6                      	PUSH	R6		; Save address of variable
 2579/116E : 8C 80                      	LD	R8,#hi(TYPE)
 2580/1170 : 9C FA                      	LD	R9,#lo(TYPE)
 2581/1172 : C2 08                      	LDC	R0,@RR8		; Get data type
 2582/1174 : 18 FC                      	LD	R1,FLAGS
 2583/1176 : 70 E1                      	PUSH	R1
 2584/1178 : 70 E0                      	PUSH	R0		; Save type
 2585/117A : D6 16 B8                   	CALL	EVAL		; Evaluate expression
 2586/117D : 50 E0                      	POP	R0		; Restore type
 2587/117F : 50 E1                      	POP	R1
 2588/1181 : 19 FC                      	LD	FLAGS,R1
 2589/1183 : 50 E8                      	POP	R8
 2590/1185 : 50 E9                      	POP	R9
 2591/1187 : 70 E3                      	PUSH	R3
 2592/1189 : 70 E2                      	PUSH	R2
 2593/118B : 28 E8                      	LD	R2,R8
 2594/118D : 38 E9                      	LD	R3,R9		; Save code - Get var addr
 2595/118F : 8C 81                      	LD	R8,#hi(BRKLIN)
 2596/1191 : 9C 1B                      	LD	R9,#lo(BRKLIN)
 2597/1193 : D2 28                      	LDC	@RR8,R2
 2598/1195 : 18 FC                      	LD	R1,FLAGS
 2599/1197 : A0 E8                      	INCW	RR8
 2600/1199 : 19 FC                      	LD	FLAGS,R1
 2601/119B : D2 38                      	LDC	@RR8,R3		; Save address of variable
 2602/119D : C0 E0                      	RRC	R0		; Adjust type
 2603/119F : D6 16 86                   	CALL	CHKTYP		; Check types are the same
 2604/11A2 : 6D 12 16                   	JP	Z,LETNUM	; Numeric - Move value
 2605/11A5 :                            LETSTR:
 2606/11A5 : 70 E3                      	PUSH	R3
 2607/11A7 : 70 E2                      	PUSH	R2		; Save address of string var
 2608/11A9 : 8C 81                      	LD	R8,#hi(FPREG)
 2609/11AB : 9C 31                      	LD	R9,#lo(FPREG)
 2610/11AD :                            ;	LDC	R2,@RR8
 2611/11AD :                            ;	LD	R1,FLAGS
 2612/11AD :                            ;	INCW	RR8
 2613/11AD :                            ;	LD	FLAGS,R1
 2614/11AD :                            ;	LDC	R3,@RR8		; Pointer to string entry
 2615/11AD : C2 38                      	LDC	R3,@RR8
 2616/11AF : A0 E8                      	INCW	RR8
 2617/11B1 : C2 28                      	LDC	R2,@RR8		; Pointer to string entry
 2618/11B3 :                            
 2619/11B3 : 70 E3                      	PUSH	R3
 2620/11B5 : 70 E2                      	PUSH	R2		; Save it on stack
 2621/11B7 : A0 E2                      	INCW	RR2		; Skip over length
 2622/11B9 : A0 E2                      	INCW	RR2
 2623/11BB : C2 72                      	LDC	R7,@RR2		; LSB of string address
 2624/11BD : A0 E2                      	INCW	RR2
 2625/11BF : C2 62                      	LDC	R6,@RR2		; MSB of string address
 2626/11C1 : 8C 80                      	LD	R8,#hi(BASTXT)
 2627/11C3 : 9C AB                      	LD	R9,#lo(BASTXT)
 2628/11C5 : C2 28                      	LDC	R2,@RR8
 2629/11C7 : A0 E8                      	INCW	RR8
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 45 - 2023/10/26 22時18分50秒


 2630/11C9 : C2 38                      	LDC	R3,@RR8		; Point to start of program
 2631/11CB : D6 0A 3D                   	CALL	CPDEHL		; Is string before program?
 2632/11CE : FD 11 F1                   	JP	NC,CRESTR	; Yes - Create string entry
 2633/11D1 : 8C 80                      	LD	R8,#hi(STRSPC)
 2634/11D3 : 9C A7                      	LD	R9,#lo(STRSPC)
 2635/11D5 : C2 28                      	LDC	R2,@RR8
 2636/11D7 : A0 E8                      	INCW	RR8
 2637/11D9 : C2 38                      	LDC	R3,@RR8		; Point to string space
 2638/11DB : D6 0A 3D                   	CALL	CPDEHL		; Is string literal in program?
 2639/11DE : 50 E6                      	POP	R6
 2640/11E0 : 50 E7                      	POP	R7		; Restore address of string
 2641/11E2 : FD 12 07                   	JP	NC,MVSTPT	; Yes - Set up pointer
 2642/11E5 : 2C 81                      	LD	R2,#hi(TMPSTR)
 2643/11E7 : 3C 0C                      	LD	R3,#lo(TMPSTR)	; Temporary string pool
 2644/11E9 : D6 0A 3D                   	CALL	CPDEHL		; Is string in temporary pool?
 2645/11EC : FD 12 07                   	JP	NC,MVSTPT	; No - Set up pointer
 2646/11EF : 8B 04                      	JR	CRESTR1		; Skip "POP DE"
 2647/11F1 :                            CRESTR:
 2648/11F1 : 50 E6                      	POP	R6
 2649/11F3 : 50 E7                      	POP	R7		; Restore address of string
 2650/11F5 :                            CRESTR1:
 2651/11F5 : D6 24 C5                   	CALL	BAKTMP		; Back to last tmp-str entry
 2652/11F8 : 88 E6                      	LD	R8,R6
 2653/11FA : 98 E7                      	LD	R9,R7
 2654/11FC : 68 E2                      	LD	R6,R2
 2655/11FE : 78 E3                      	LD	R7,R3
 2656/1200 : 28 E8                      	LD	R2,R8
 2657/1202 : 38 E9                      	LD	R3,R9		; Address of string entry
 2658/1204 : D6 20 33                   	CALL	SAVSTR		; Save string in string area
 2659/1207 :                            MVSTPT:
 2660/1207 : D6 24 C5                   	CALL	BAKTMP		; Back to last tmp-str entry
 2661/120A : 50 E2                      	POP	R2
 2662/120C : 50 E3                      	POP	R3		; Get string pointer
 2663/120E : D6 2C 24                   	CALL	DETHL4		; Move string pointer to var
 2664/1211 : 50 E2                      	POP	R2
 2665/1213 : 50 E3                      	POP	R3		; Restore code string address
 2666/1215 : AF                         	RET
 2667/1216 :                            ;
 2668/1216 :                            LETNUM:
 2669/1216 : 70 E3                      	PUSH	R3
 2670/1218 : 70 E2                      	PUSH	R2		; Save address of variable
 2671/121A : D6 2C 20                   	CALL	FPTHL		; Move value to variable
 2672/121D : 50 E6                      	POP	R6
 2673/121F : 50 E7                      	POP	R7		; Restore address of variable
 2674/1221 : 50 E2                      	POP	R2
 2675/1223 : 50 E3                      	POP	R3		; Restore code string address
 2676/1225 : AF                         	RET
 2677/1226 :                            ;
 2678/1226 :                            ON:
 2679/1226 : D6 26 EB                   	CALL	GETINT		; Get integer 0-255
 2680/1229 : C2 02                      	LDC	R0,@RR2		; Get "GOTO" or "GOSUB" token
 2681/122B : 48 E0                      	LD	R4,R0		; Save in B
 2682/122D : A6 E0 8C                   	CP	R0,#ZGOSUB	; "GOSUB" token?
 2683/1230 : 6D 12 39                   	JP	Z,ONGO		; Yes - Find line number
 2684/1233 : D6 0A 49                   	CALL	CHKSYN		; Make sure it's "GOTO"
 2685/1236 : 88                         	DB	ZGOTO		; "GOTO" token
 2686/1237 : 80 E2                      	DECW	RR2		; Cancel increment
 2687/1239 :                            ONGO:
 2688/1239 : 58 E7                      	LD	R5,R7		; Integer of branch value
 2689/123B :                            ONGOLP:
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 46 - 2023/10/26 22時18分50秒


 2690/123B : 00 E5                      	DEC	R5		; Count branches
 2691/123D : 08 E4                      	LD	R0,R4		; Get "GOTO" or "GOSUB" token
 2692/123F : 6D 0D 71                   	JP	Z,ONJMP		; Go to that line if right one
 2693/1242 : D6 0F 86                   	CALL	GETLN		; Get line number to DE
 2694/1245 : A6 E0 2C                   	CP	R0,#','		; Another line number?
 2695/1248 : 6B 01                      	JR	Z,$+3
 2696/124A : AF                         	RET			; No - Drop through
 2697/124B : 8D 12 3B                   	JP	ONGOLP		; Yes - loop
 2698/124E :                            ;
 2699/124E :                            IF:
 2700/124E : D6 16 B8                   	CALL	EVAL		; Evaluate expression
 2701/1251 : C2 02                      	LDC	R0,@RR2		; Get token
 2702/1253 : A6 E0 88                   	CP	R0,#ZGOTO	; "GOTO" token?
 2703/1256 : 6D 12 5F                   	JP	Z,IFGO		; Yes - Get line
 2704/1259 : D6 0A 49                   	CALL	CHKSYN		; Make sure it's "THEN"
 2705/125C : A9                         	DB	ZTHEN		; "THEN" token
 2706/125D : 80 E2                      	DECW	RR2		; Cancel increment
 2707/125F :                            IFGO:
 2708/125F : D6 16 80                   	CALL	TSTNUM		; Make sure it's numeric
 2709/1262 : D6 2B 76                   	CALL	TSTSGN		; Test state of expression
 2710/1265 : 6D 11 42                   	JP	Z,REM		; False - Drop through
 2711/1268 : D6 0D AD                   	CALL	GETCHR		; Get next character
 2712/126B : 7D 10 B5                   	JP	C,GOTO		; Number - GOTO that line
 2713/126E : 8D 0D 6E                   	JP	IFJMP		; Otherwise do statement
 2714/1271 :                            ;
 2715/1271 :                            MRPRNT:
 2716/1271 : 80 E2                      	DECW	RR2		; DEC 'cos GETCHR INCs
 2717/1273 : D6 0D AD                   	CALL	GETCHR		; Get next character
 2718/1276 :                            PRINT:
 2719/1276 : 6D 13 1B                   	JP	Z,PRCRLF	; CRLF if just PRINT
 2720/1279 :                            PRNTLP:
 2721/1279 : EB 01                      	JR	NZ,$+3
 2722/127B : AF                         	RET			; End of list - Exit
 2723/127C : A6 E0 A5                   	CP	R0,#ZTAB	; "TAB(" token?
 2724/127F : 6D 13 71                   	JP	Z,DOTAB		; Yes - Do TAB routine
 2725/1282 : A6 E0 A8                   	CP	R0,#ZSPC	; "SPC(" token?
 2726/1285 : 6D 13 71                   	JP	Z,DOTAB		; Yes - Do SPC routine
 2727/1288 : 70 E3                      	PUSH	R3
 2728/128A : 70 E2                      	PUSH	R2		; Save code string address
 2729/128C : A6 E0 2C                   	CP	R0,#','		; Comma?
 2730/128F : 6D 13 4E                   	JP	Z,DOCOM		; Yes - Move to next zone
 2731/1292 : A6 E0 3B                   	CP	R0,#';'		; Semi-colon?
 2732/1295 : 6D 13 AA                   	JP	Z,NEXITM	; Do semi-colon routine
 2733/1298 : 50 E4                      	POP	R4
 2734/129A : 50 E5                      	POP	R5		; Code string address to BC
 2735/129C : D6 16 B8                   	CALL	EVAL		; Evaluate expression
 2736/129F : 70 E3                      	PUSH	R3
 2737/12A1 : 70 E2                      	PUSH	R2		; Save code string address
 2738/12A3 : 8C 80                      	LD	R8,#hi(TYPE)
 2739/12A5 : 9C FA                      	LD	R9,#lo(TYPE)
 2740/12A7 : C2 08                      	LDC	R0,@RR8		; Get variable type
 2741/12A9 : 42 00                      	OR	R0,R0
 2742/12AB : CF                         	RCF			; Is it a string variable?
 2743/12AC : ED 12 F8                   	JP	NZ,PRNTST	; Yes - Output string contents
 2744/12AF : D6 2E A8                   	CALL	NUMASC		; Convert number to text
 2745/12B2 : D6 20 77                   	CALL	CRTST		; Create temporary string
 2746/12B5 : 1C 20                      	LD	R1,#' '
 2747/12B7 : D2 12                      	LDC	@RR2,R1		; Followed by a space
 2748/12B9 : 8C 81                      	LD	R8,#hi(FPREG)
 2749/12BB : 9C 31                      	LD	R9,#lo(FPREG)
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 47 - 2023/10/26 22時18分50秒


 2750/12BD :                            ;	LDC	R2,@RR8
 2751/12BD :                            ;	LD	R1,FLAGS
 2752/12BD :                            ;	INCW	RR8
 2753/12BD :                            ;	LD	FLAGS,R1
 2754/12BD :                            ;	LDC	R3,@RR8		; Get length of output
 2755/12BD : C2 38                      	LDC	R3,@RR8
 2756/12BF : A0 E8                      	INCW	RR8
 2757/12C1 : C2 28                      	LDC	R2,@RR8		; Get length of output
 2758/12C3 :                            
 2759/12C3 : C2 82                      	LDC	R8,@RR2
 2760/12C5 : 8E                         	INC	R8
 2761/12C6 : D2 82                      	LDC	@RR2,R8		; Plus 1 for the space
 2762/12C8 : 8C 81                      	LD	R8,#hi(FPREG)
 2763/12CA : 9C 31                      	LD	R9,#lo(FPREG)
 2764/12CC :                            ;	LDC	R2,@RR8
 2765/12CC :                            ;	LD	R1,FLAGS
 2766/12CC :                            ;	INCW	RR8
 2767/12CC :                            ;	LD	FLAGS,R1
 2768/12CC :                            ;	LDC	R3,@RR8		; < Not needed >
 2769/12CC : C2 38                      	LDC	R3,@RR8
 2770/12CE : A0 E8                      	INCW	RR8
 2771/12D0 : C2 28                      	LDC	R2,@RR8		; < Not needed >
 2772/12D2 :                            
 2773/12D2 : 8C 80                      	LD	R8,#hi(LWIDTH)
 2774/12D4 : 9C 8F                      	LD	R9,#lo(LWIDTH)
 2775/12D6 : C2 08                      	LDC	R0,@RR8		; Get width of line
 2776/12D8 : 48 E0                      	LD	R4,R0		; To B
 2777/12DA : 4E                         	INC	R4		; Width 255 (No limit)?
 2778/12DB : 6D 12 F2                   	JP	Z,PRNTNB	; Yes - Output number string
 2779/12DE : 4E                         	INC	R4		; Adjust it
 2780/12DF : 8C 80                      	LD	R8,#hi(CURPOS)
 2781/12E1 : 9C F8                      	LD	R9,#lo(CURPOS)
 2782/12E3 : C2 08                      	LDC	R0,@RR8		; Get cursor position
 2783/12E5 : C2 82                      	LDC	R8,@RR2
 2784/12E7 : 02 08                      	ADD	R0,R8		; Add length of string
 2785/12E9 : 00 E0                      	DEC	R0		; Adjust it
 2786/12EB : A2 04                      	CP	R0,R4		; Will output fit on this line?
 2787/12ED : 7B 03                      	JR	C,$+5
 2788/12EF : D6 13 1B                   	CALL	PRCRLF		; No - CRLF first
 2789/12F2 :                            PRNTNB:
 2790/12F2 : D6 21 05                   	CALL	PRS1		; Output string at (HL)
 2791/12F5 : B2 00                      	XOR	R0,R0
 2792/12F7 : CF                         	RCF			; Skip CALL by setting 'z' flag
 2793/12F8 :                            PRNTST:
 2794/12F8 : 6B 03                      	JR	Z,$+5
 2795/12FA : D6 21 05                   	CALL	PRS1		; Output string at (HL)
 2796/12FD : 50 E2                      	POP	R2
 2797/12FF : 50 E3                      	POP	R3		; Restore code string address
 2798/1301 : 8D 12 71                   	JP	MRPRNT		; See if more to PRINT
 2799/1304 :                            ;
 2800/1304 :                            STTLIN:
 2801/1304 : 8C 80                      	LD	R8,#hi(CURPOS)
 2802/1306 : 9C F8                      	LD	R9,#lo(CURPOS)
 2803/1308 : C2 08                      	LDC	R0,@RR8		; Make sure on new line
 2804/130A : 42 00                      	OR	R0,R0
 2805/130C : CF                         	RCF			; Already at start?
 2806/130D : EB 01                      	JR	NZ,$+3
 2807/130F : AF                         	RET			; Yes - Do nothing
 2808/1310 : 8D 13 1B                   	JP	PRCRLF		; Start a new line
 2809/1313 :                            ;
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 48 - 2023/10/26 22時18分50秒


 2810/1313 :                            ENDINP:
 2811/1313 : 1C 00                      	LD	R1,#0
 2812/1315 : D2 12                      	LDC	@RR2,R1		; Mark end of buffer
 2813/1317 : 2C 80                      	LD	R2,#hi(BUFFER-1)
 2814/1319 : 3C AD                      	LD	R3,#lo(BUFFER-1); Point to buffer
 2815/131B :                            PRCRLF:
 2816/131B : 0C 0D                      	LD	R0,#CR		; Load a CR
 2817/131D : D6 0A 6F                   	CALL	OUTC		; Output character
 2818/1320 : 0C 0A                      	LD	R0,#LF		; Load a LF
 2819/1322 : D6 0A 6F                   	CALL	OUTC		; Output character
 2820/1325 :                            DONULL:
 2821/1325 : B2 00                      	XOR	R0,R0
 2822/1327 : CF                         	RCF			; Set to position 0
 2823/1328 : 8C 80                      	LD	R8,#hi(CURPOS)
 2824/132A : 9C F8                      	LD	R9,#lo(CURPOS)
 2825/132C : D2 08                      	LDC	@RR8,R0		; Store it
 2826/132E : 8C 80                      	LD	R8,#hi(NULLS)
 2827/1330 : 9C 8E                      	LD	R9,#lo(NULLS)
 2828/1332 : C2 08                      	LDC	R0,@RR8		; Get number of nulls
 2829/1334 :                            NULLP:
 2830/1334 : 00 E0                      	DEC	R0		; Count them
 2831/1336 : EB 01                      	JR	NZ,$+3
 2832/1338 : AF                         	RET			; Return if done
 2833/1339 : 18 FC                      	LD	R1,FLAGS
 2834/133B : 70 E1                      	PUSH	R1
 2835/133D : 70 E0                      	PUSH	R0		; Save count
 2836/133F : B2 00                      	XOR	R0,R0
 2837/1341 : CF                         	RCF			; Load a null
 2838/1342 : D6 0A 6F                   	CALL	OUTC		; Output it
 2839/1345 : 50 E0                      	POP	R0		; Restore count
 2840/1347 : 50 E1                      	POP	R1
 2841/1349 : 19 FC                      	LD	FLAGS,R1
 2842/134B : 8D 13 34                   	JP	NULLP		; Keep counting
 2843/134E :                            ;
 2844/134E :                            DOCOM:
 2845/134E : 8C 80                      	LD	R8,#hi(COMMAN)
 2846/1350 : 9C 90                      	LD	R9,#lo(COMMAN)
 2847/1352 : C2 08                      	LDC	R0,@RR8		; Get comma width
 2848/1354 : 48 E0                      	LD	R4,R0		; Save in B
 2849/1356 : 8C 80                      	LD	R8,#hi(CURPOS)
 2850/1358 : 9C F8                      	LD	R9,#lo(CURPOS)
 2851/135A : C2 08                      	LDC	R0,@RR8		; Get current position
 2852/135C : A2 04                      	CP	R0,R4		; Within the limit?
 2853/135E : 7B 03                      	JR	C,$+5
 2854/1360 : D6 13 1B                   	CALL	PRCRLF		; No - output CRLF
 2855/1363 : FD 13 AA                   	JP	NC,NEXITM	; Get next item
 2856/1366 :                            ZONELP:
 2857/1366 : 26 E0 0E                   	SUB	R0,#14		; Next zone of 14 characters
 2858/1369 : FD 13 66                   	JP	NC,ZONELP	; Repeat if more zones
 2859/136C : 60 E0                      	COM	R0		; Number of spaces to output
 2860/136E : 8D 13 9D                   	JP	ASPCS		; Output them
 2861/1371 :                            ;
 2862/1371 :                            DOTAB:
 2863/1371 : 18 FC                      	LD	R1,FLAGS
 2864/1373 : 70 E1                      	PUSH	R1
 2865/1375 : 70 E0                      	PUSH	R0		; Save token
 2866/1377 : D6 26 E8                   	CALL	FNDNUM		; Evaluate expression
 2867/137A : D6 0A 49                   	CALL	CHKSYN		; Make sure ")" follows
 2868/137D : 29                         	DB	")"
 2869/137E : 80 E2                      	DECW	RR2		; Back space on to ")"
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 49 - 2023/10/26 22時18分50秒


 2870/1380 : 50 E0                      	POP	R0		; Restore token
 2871/1382 : 50 E1                      	POP	R1
 2872/1384 : 19 FC                      	LD	FLAGS,R1
 2873/1386 : 26 E0 A8                   	SUB	R0,#ZSPC	; Was it "SPC(" ?
 2874/1389 : 70 E3                      	PUSH	R3
 2875/138B : 70 E2                      	PUSH	R2		; Save code string address
 2876/138D : 6D 13 96                   	JP	Z,DOSPC		; Yes - Do 'E' spaces
 2877/1390 : 8C 80                      	LD	R8,#hi(CURPOS)
 2878/1392 : 9C F8                      	LD	R9,#lo(CURPOS)
 2879/1394 : C2 08                      	LDC	R0,@RR8		; Get current position
 2880/1396 :                            DOSPC:
 2881/1396 : 60 E0                      	COM	R0		; Number of spaces to print to
 2882/1398 : 02 07                      	ADD	R0,R7		; Total number to print
 2883/139A : FD 13 AA                   	JP	NC,NEXITM	; TAB < Current POS(X)
 2884/139D :                            ASPCS:
 2885/139D : 0E                         	INC	R0		; Output A spaces
 2886/139E : 48 E0                      	LD	R4,R0		; Save number to print
 2887/13A0 : 0C 20                      	LD	R0,#' '		; Space
 2888/13A2 :                            SPCLP:
 2889/13A2 : D6 0A 6F                   	CALL	OUTC		; Output character in A
 2890/13A5 : 00 E4                      	DEC	R4		; Count them
 2891/13A7 : ED 13 A2                   	JP	NZ,SPCLP	; Repeat if more
 2892/13AA :                            NEXITM:
 2893/13AA : 50 E2                      	POP	R2
 2894/13AC : 50 E3                      	POP	R3		; Restore code string address
 2895/13AE : D6 0D AD                   	CALL	GETCHR		; Get next character
 2896/13B1 : 8D 12 79                   	JP	PRNTLP		; More to print
 2897/13B4 :                            ;
 2898/13B4 :                            REDO:
 2899/13B4 : 3F 52 65 64 6F 20 66 72 6F 	DB	"?Redo from start",CR,LF,0
      13BD : 6D 20 73 74 61 72 74 0D 0A
      13C6 : 00                        
 2900/13C7 :                            ;
 2901/13C7 :                            BADINP:
 2902/13C7 : 8C 81                      	LD	R8,#hi(READFG)
 2903/13C9 : 9C 1A                      	LD	R9,#lo(READFG)
 2904/13CB : C2 08                      	LDC	R0,@RR8		; READ or INPUT?
 2905/13CD : 42 00                      	OR	R0,R0
 2906/13CF : CF                         	RCF
 2907/13D0 : ED 04 EB                   	JP	NZ,DATSNR	; READ - ?SN Error
 2908/13D3 : 50 E4                      	POP	R4
 2909/13D5 : 50 E5                      	POP	R5		; Throw away code string addr
 2910/13D7 : 2C 13                      	LD	R2,#hi(REDO)
 2911/13D9 : 3C B4                      	LD	R3,#lo(REDO)	; "Redo from start" message
 2912/13DB : D6 21 02                   	CALL	PRS		; Output string
 2913/13DE : 8D 07 D8                   	JP	DOAGN		; Do last INPUT again
 2914/13E1 :                            ;
 2915/13E1 :                            INPUT:
 2916/13E1 : D6 1F E7                   	CALL	IDTEST		; Test for illegal direct
 2917/13E4 : C2 02                      	LDC	R0,@RR2		; Get character after "INPUT"
 2918/13E6 : A6 E0 22                   	CP	R0,#'"'		; Is there a prompt string?
 2919/13E9 : 0C 00                      	LD	R0,#0		; Clear A and leave flags
 2920/13EB : 8C 80                      	LD	R8,#hi(CTLOFG)
 2921/13ED : 9C 92                      	LD	R9,#lo(CTLOFG)
 2922/13EF : D2 08                      	LDC	@RR8,R0		; Enable output
 2923/13F1 : ED 14 04                   	JP	NZ,NOPMPT	; No prompt - get input
 2924/13F4 : D6 20 79                   	CALL	QTSTR		; Get string terminated by '"'
 2925/13F7 : D6 0A 49                   	CALL	CHKSYN		; Check for ';' after prompt
 2926/13FA : 3B                         	DB	';'
 2927/13FB : 70 E3                      	PUSH	R3
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 50 - 2023/10/26 22時18分50秒


 2928/13FD : 70 E2                      	PUSH	R2		; Save code string address
 2929/13FF : D6 21 05                   	CALL	PRS1		; Output prompt string
 2930/1402 : 8B 04                      	JR	NOPMPT1		; Skip "PUSH HL"
 2931/1404 :                            NOPMPT:
 2932/1404 : 70 E3                      	PUSH	R3
 2933/1406 : 70 E2                      	PUSH	R2		; Save code string address
 2934/1408 :                            NOPMPT1:
 2935/1408 : D6 07 E3                   	CALL	PROMPT		; Get input with "? " prompt
 2936/140B : 50 E4                      	POP	R4
 2937/140D : 50 E5                      	POP	R5		; Restore code string address
 2938/140F : 7D 0E 68                   	JP	C,INPBRK	; Break pressed - Exit
 2939/1412 : A0 E2                      	INCW	RR2		; Next byte
 2940/1414 : C2 02                      	LDC	R0,@RR2		; Get it
 2941/1416 : 80 E2                      	DECW	RR2		; Back again
 2942/1418 : 42 00                      	OR	R0,R0		; End of line?
 2943/141A : 70 E5                      	PUSH	R5
 2944/141C : 70 E4                      	PUSH	R4		; Re-save code string address
 2945/141E : 6D 11 3A                   	JP	Z,NXTDTA	; Yes - Find next DATA stmt
 2946/1421 : 1C 2C                      	LD	R1,#','
 2947/1423 : D2 12                      	LDC	@RR2,R1		; Store comma as separator
 2948/1425 : 8D 14 3B                   	JP	NXTITM		; Get next item
 2949/1428 :                            ;
 2950/1428 :                            READ:
 2951/1428 : 70 E3                      	PUSH	R3
 2952/142A : 70 E2                      	PUSH	R2		; Save code string address
 2953/142C : 8C 81                      	LD	R8,#hi(NXTDAT)
 2954/142E : 9C 29                      	LD	R9,#lo(NXTDAT)
 2955/1430 : C2 28                      	LDC	R2,@RR8
 2956/1432 : A0 E8                      	INCW	RR8
 2957/1434 : C2 38                      	LDC	R3,@RR8		; Next DATA statement
 2958/1436 : 46 E0 AF                   	OR	R0,#0AFH	; Flag "READ"
 2959/1439 : 8B 02                      	JR	NXTITM1
 2960/143B :                            NXTITM:
 2961/143B : B2 00                      	XOR	R0,R0		; Flag "INPUT"
 2962/143D :                            NXTITM1:
 2963/143D : 8C 81                      	LD	R8,#hi(READFG)
 2964/143F : 9C 1A                      	LD	R9,#lo(READFG)
 2965/1441 : D2 08                      	LDC	@RR8,R0		; Save "READ"/"INPUT" flag
 2966/1443 : 50 E8                      	POP	R8
 2967/1445 : 50 E9                      	POP	R9
 2968/1447 : 70 E3                      	PUSH	R3
 2969/1449 : 70 E2                      	PUSH	R2
 2970/144B : 28 E8                      	LD	R2,R8
 2971/144D : 38 E9                      	LD	R3,R9		; Get code str' , Save pointer
 2972/144F : 8D 14 56                   	JP	GTVLUS		; Get values
 2973/1452 :                            ;
 2974/1452 :                            NEDMOR:
 2975/1452 : D6 0A 49                   	CALL	CHKSYN		; Check for comma between items
 2976/1455 : 2C                         	DB	','
 2977/1456 :                            GTVLUS:
 2978/1456 : D6 1A 60                   	CALL	GETVAR		; Get variable name
 2979/1459 : 50 E8                      	POP	R8
 2980/145B : 50 E9                      	POP	R9
 2981/145D : 70 E3                      	PUSH	R3
 2982/145F : 70 E2                      	PUSH	R2
 2983/1461 : 28 E8                      	LD	R2,R8
 2984/1463 : 38 E9                      	LD	R3,R9		; Save code str" , Get pointer
 2985/1465 : 70 E7                      	PUSH	R7
 2986/1467 : 70 E6                      	PUSH	R6		; Save variable address
 2987/1469 : C2 02                      	LDC	R0,@RR2		; Get next "INPUT"/"DATA" byte
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 51 - 2023/10/26 22時18分50秒


 2988/146B : A6 E0 2C                   	CP	R0,#','		; Comma?
 2989/146E : 6D 14 A3                   	JP	Z,ANTVLU	; Yes - Get another value
 2990/1471 : 8C 81                      	LD	R8,#hi(READFG)
 2991/1473 : 9C 1A                      	LD	R9,#lo(READFG)
 2992/1475 : C2 08                      	LDC	R0,@RR8		; Is it READ?
 2993/1477 : 42 00                      	OR	R0,R0
 2994/1479 : CF                         	RCF
 2995/147A : ED 15 71                   	JP	NZ,FDTLP	; Yes - Find next DATA stmt
 2996/147D : 0C 3F                      	LD	R0,#'?'		; More INPUT needed
 2997/147F : D6 0A 6F                   	CALL	OUTC		; Output character
 2998/1482 : D6 07 E3                   	CALL	PROMPT		; Get INPUT with prompt
 2999/1485 : 50 E6                      	POP	R6
 3000/1487 : 50 E7                      	POP	R7		; Variable address
 3001/1489 : 50 E4                      	POP	R4
 3002/148B : 50 E5                      	POP	R5		; Code string address
 3003/148D : 7D 0E 68                   	JP	C,INPBRK	; Break pressed
 3004/1490 : A0 E2                      	INCW	RR2		; Point to next DATA byte
 3005/1492 : C2 02                      	LDC	R0,@RR2		; Get byte
 3006/1494 : 80 E2                      	DECW	RR2		; Back space INPUT pointer
 3007/1496 : 42 00                      	OR	R0,R0		; Is it zero (No input) ?
 3008/1498 : 70 E5                      	PUSH	R5
 3009/149A : 70 E4                      	PUSH	R4		; Save code string address
 3010/149C : 6D 11 3A                   	JP	Z,NXTDTA	; Find end of buffer
 3011/149F : 70 E7                      	PUSH	R7
 3012/14A1 : 70 E6                      	PUSH	R6		; Save variable address
 3013/14A3 :                            ANTVLU:
 3014/14A3 : 8C 80                      	LD	R8,#hi(TYPE)
 3015/14A5 : 9C FA                      	LD	R9,#lo(TYPE)
 3016/14A7 : C2 08                      	LDC	R0,@RR8		; Check data type
 3017/14A9 : 42 00                      	OR	R0,R0		; Is it numeric?
 3018/14AB : 6D 14 F4                   	JP	Z,INPBIN	; Yes - Convert to binary
 3019/14AE : D6 0D AD                   	CALL	GETCHR		; Get next character
 3020/14B1 : 68 E0                      	LD	R6,R0		; Save input character
 3021/14B3 : 48 E0                      	LD	R4,R0		; Again
 3022/14B5 : A6 E0 22                   	CP	R0,#'"'		; Start of literal sting?
 3023/14B8 : 6D 14 CE                   	JP	Z,STRENT	; Yes - Create string entry
 3024/14BB : 8C 81                      	LD	R8,#hi(READFG)
 3025/14BD : 9C 1A                      	LD	R9,#lo(READFG)
 3026/14BF : C2 08                      	LDC	R0,@RR8		; "READ" or "INPUT" ?
 3027/14C1 : 42 00                      	OR	R0,R0
 3028/14C3 : 68 E0                      	LD	R6,R0		; Save 00 if "INPUT"
 3029/14C5 : 6D 14 CA                   	JP	Z,ITMSEP	; "INPUT" - End with 00
 3030/14C8 : 6C 3A                      	LD	R6,#':'		; "DATA" - End with 00 or ':'
 3031/14CA :                            ITMSEP:
 3032/14CA : 4C 2C                      	LD	R4,#','		; Item separator
 3033/14CC : 80 E2                      	DECW	RR2		; Back space for DTSTR
 3034/14CE :                            STRENT:
 3035/14CE : D6 20 7D                   	CALL	DTSTR		; Get string terminated by D
 3036/14D1 : 88 E6                      	LD	R8,R6
 3037/14D3 : 98 E7                      	LD	R9,R7
 3038/14D5 : 68 E2                      	LD	R6,R2
 3039/14D7 : 78 E3                      	LD	R7,R3
 3040/14D9 : 28 E8                      	LD	R2,R8
 3041/14DB : 38 E9                      	LD	R3,R9		; String address to DE
 3042/14DD : 2C 15                      	LD	R2,#hi(LTSTND)
 3043/14DF : 3C 0D                      	LD	R3,#lo(LTSTND)	; Where to go after LETSTR
 3044/14E1 : 50 E8                      	POP	R8
 3045/14E3 : 50 E9                      	POP	R9
 3046/14E5 : 70 E3                      	PUSH	R3
 3047/14E7 : 70 E2                      	PUSH	R2
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 52 - 2023/10/26 22時18分50秒


 3048/14E9 : 28 E8                      	LD	R2,R8
 3049/14EB : 38 E9                      	LD	R3,R9		; Save HL , get input pointer
 3050/14ED : 70 E7                      	PUSH	R7
 3051/14EF : 70 E6                      	PUSH	R6		; Save address of string
 3052/14F1 : 8D 11 A5                   	JP	LETSTR		; Assign string to variable
 3053/14F4 :                            ;
 3054/14F4 :                            INPBIN:
 3055/14F4 : D6 0D AD                   	CALL	GETCHR		; Get next character
 3056/14F7 : D6 2D 7E                   	CALL	ASCTFP		; Convert ASCII to FP number
 3057/14FA : 50 E8                      	POP	R8
 3058/14FC : 50 E9                      	POP	R9
 3059/14FE : 70 E3                      	PUSH	R3
 3060/1500 : 70 E2                      	PUSH	R2
 3061/1502 : 28 E8                      	LD	R2,R8
 3062/1504 : 38 E9                      	LD	R3,R9		; Save input ptr, Get var addr
 3063/1506 : D6 2C 20                   	CALL	FPTHL		; Move FPREG to variable
 3064/1509 : 50 E2                      	POP	R2
 3065/150B : 50 E3                      	POP	R3		; Restore input pointer
 3066/150D :                            LTSTND:
 3067/150D : 80 E2                      	DECW	RR2		; DEC 'cos GETCHR INCs
 3068/150F : D6 0D AD                   	CALL	GETCHR		; Get next character
 3069/1512 : 6D 15 1B                   	JP	Z,MORDT		; End of line - More needed?
 3070/1515 : A6 E0 2C                   	CP	R0,#','		; Another value?
 3071/1518 : ED 13 C7                   	JP	NZ,BADINP	; No - Bad input
 3072/151B :                            MORDT:
 3073/151B : 50 E8                      	POP	R8
 3074/151D : 50 E9                      	POP	R9
 3075/151F : 70 E3                      	PUSH	R3
 3076/1521 : 70 E2                      	PUSH	R2
 3077/1523 : 28 E8                      	LD	R2,R8
 3078/1525 : 38 E9                      	LD	R3,R9		; Get code string address
 3079/1527 : 80 E2                      	DECW	RR2		; DEC 'cos GETCHR INCs
 3080/1529 : D6 0D AD                   	CALL	GETCHR		; Get next character
 3081/152C : ED 14 52                   	JP	NZ,NEDMOR	; More needed - Get it
 3082/152F : 50 E6                      	POP	R6
 3083/1531 : 50 E7                      	POP	R7		; Restore DATA pointer
 3084/1533 : 8C 81                      	LD	R8,#hi(READFG)
 3085/1535 : 9C 1A                      	LD	R9,#lo(READFG)
 3086/1537 : C2 08                      	LDC	R0,@RR8		; "READ" or "INPUT" ?
 3087/1539 : 42 00                      	OR	R0,R0
 3088/153B : 88 E6                      	LD	R8,R6
 3089/153D : 98 E7                      	LD	R9,R7
 3090/153F : 68 E2                      	LD	R6,R2
 3091/1541 : 78 E3                      	LD	R7,R3
 3092/1543 : 28 E8                      	LD	R2,R8
 3093/1545 : 38 E9                      	LD	R3,R9		; DATA pointer to HL
 3094/1547 : ED 0E 05                   	JP	NZ,UPDATA	; Update DATA pointer if "READ"
 3095/154A : 70 E7                      	PUSH	R7
 3096/154C : 70 E6                      	PUSH	R6		; Save code string address
 3097/154E : C2 12                      	LDC	R1,@RR2
 3098/1550 : 42 01                      	OR	R0,R1		; More input given?
 3099/1552 : 2C 15                      	LD	R2,#hi(EXTIG)
 3100/1554 : 3C 60                      	LD	R3,#lo(EXTIG)	; "?Extra ignored" message
 3101/1556 : 6B 03                      	JR	Z,$+5
 3102/1558 : D6 21 02                   	CALL	PRS		; Output string if extra given
 3103/155B : 50 E2                      	POP	R2
 3104/155D : 50 E3                      	POP	R3		; Restore code string address
 3105/155F : AF                         	RET
 3106/1560 :                            ;
 3107/1560 :                            EXTIG:
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 53 - 2023/10/26 22時18分50秒


 3108/1560 : 3F 45 78 74 72 61 20 69 67 	DB	"?Extra ignored",CR,LF,0
      1569 : 6E 6F 72 65 64 0D 0A 00   
 3109/1571 :                            ;
 3110/1571 :                            FDTLP:
 3111/1571 : D6 11 3E                   	CALL	DATA		; Get next statement
 3112/1574 : 42 00                      	OR	R0,R0		; End of line?
 3113/1576 : ED 15 B2                   	JP	NZ,FANDT	; No - See if DATA statement
 3114/1579 : A0 E2                      	INCW	RR2
 3115/157B : C2 02                      	LDC	R0,@RR2		; End of program?
 3116/157D : A0 E2                      	INCW	RR2
 3117/157F : C2 12                      	LDC	R1,@RR2
 3118/1581 : 42 01                      	OR	R0,R1		; 00 00 Ends program
 3119/1583 : 7C 06                      	LD	R7,#OD		; ?OD Error
 3120/1585 : 6D 05 19                   	JP	Z,ERROR		; Yes - Out of DATA
 3121/1588 : A0 E2                      	INCW	RR2
 3122/158A : C2 72                      	LDC	R7,@RR2		; LSB of line number
 3123/158C : A0 E2                      	INCW	RR2
 3124/158E : C2 62                      	LDC	R6,@RR2		; MSB of line number
 3125/1590 : 88 E6                      	LD	R8,R6
 3126/1592 : 98 E7                      	LD	R9,R7
 3127/1594 : 68 E2                      	LD	R6,R2
 3128/1596 : 78 E3                      	LD	R7,R3
 3129/1598 : 28 E8                      	LD	R2,R8
 3130/159A : 38 E9                      	LD	R3,R9
 3131/159C : 8C 81                      	LD	R8,#hi(DATLIN)
 3132/159E : 9C 16                      	LD	R9,#lo(DATLIN)
 3133/15A0 : D2 28                      	LDC	@RR8,R2
 3134/15A2 : A0 E8                      	INCW	RR8
 3135/15A4 : D2 38                      	LDC	@RR8,R3		; Set line of current DATA item
 3136/15A6 : 88 E6                      	LD	R8,R6
 3137/15A8 : 98 E7                      	LD	R9,R7
 3138/15AA : 68 E2                      	LD	R6,R2
 3139/15AC : 78 E3                      	LD	R7,R3
 3140/15AE : 28 E8                      	LD	R2,R8
 3141/15B0 : 38 E9                      	LD	R3,R9
 3142/15B2 :                            FANDT:
 3143/15B2 : D6 0D AD                   	CALL	GETCHR		; Get next character
 3144/15B5 : A6 E0 83                   	CP	R0,#ZDATA	; "DATA" token
 3145/15B8 : ED 15 71                   	JP	NZ,FDTLP	; No "DATA" - Keep looking
 3146/15BB : 8D 14 A3                   	JP	ANTVLU		; Found - Convert input
 3147/15BE :                            ;
 3148/15BE :                            NEXT:
 3149/15BE : 6C 00                      	LD	R6,#hi(0)
 3150/15C0 : 7C 00                      	LD	R7,#lo(0)	; In case no index given
 3151/15C2 :                            NEXT1:
 3152/15C2 : 6B 03                      	JR	Z,$+5
 3153/15C4 : D6 1A 60                   	CALL	GETVAR		; Get index address
 3154/15C7 : 8C 81                      	LD	R8,#hi(BRKLIN)
 3155/15C9 : 9C 1B                      	LD	R9,#lo(BRKLIN)
 3156/15CB : D2 28                      	LDC	@RR8,R2
 3157/15CD : A0 E8                      	INCW	RR8
 3158/15CF : D2 38                      	LDC	@RR8,R3		; Save code string address
 3159/15D1 : D6 04 28                   	CALL	BAKSTK		; Look for "FOR" block
 3160/15D4 : ED 05 07                   	JP	NZ,NFERR	; No "FOR" - ?NF Error
 3161/15D7 : 29 FE                      	LD	SPH,R2		; Clear nested loops
 3162/15D9 : 39 FF                      	LD	SPL,R3
 3163/15DB :                            
 3164/15DB : 88 E6                      	LD	R8,R6		; @@@ SWAP DE
 3165/15DD : 68 E7                      	LD	R6,R7
 3166/15DF : 78 E8                      	LD	R7,R8
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 54 - 2023/10/26 22時18分50秒


 3167/15E1 :                            
 3168/15E1 : 70 E7                      	PUSH	R7
 3169/15E3 : 70 E6                      	PUSH	R6		; Save index address
 3170/15E5 : C2 02                      	LDC	R0,@RR2		; Get sign of STEP
 3171/15E7 : 18 FC                      	LD	R1,FLAGS
 3172/15E9 : A0 E2                      	INCW	RR2
 3173/15EB : 19 FC                      	LD	FLAGS,R1
 3174/15ED : 18 FC                      	LD	R1,FLAGS
 3175/15EF : 70 E1                      	PUSH	R1
 3176/15F1 : 70 E0                      	PUSH	R0		; Save sign of STEP
 3177/15F3 : 70 E7                      	PUSH	R7
 3178/15F5 : 70 E6                      	PUSH	R6		; Save index address
 3179/15F7 : D6 2B EB                   	CALL	PHLTFP		; Move index value to FPREG
 3180/15FA : 50 E8                      	POP	R8
 3181/15FC : 50 E9                      	POP	R9
 3182/15FE : 70 E3                      	PUSH	R3
 3183/1600 : 70 E2                      	PUSH	R2
 3184/1602 : 28 E8                      	LD	R2,R8
 3185/1604 : 38 E9                      	LD	R3,R9		; Save address of TO value
 3186/1606 :                            
 3187/1606 : 88 E2                      	LD	R8,R2		; @@@ SWAP HL
 3188/1608 : 28 E3                      	LD	R2,R3
 3189/160A : 38 E8                      	LD	R3,R8
 3190/160C :                            
 3191/160C : 70 E3                      	PUSH	R3
 3192/160E : 70 E2                      	PUSH	R2		; Save address of index
 3193/1610 : D6 27 25                   	CALL	ADDPHL		; Add STEP to index value
 3194/1613 : 50 E2                      	POP	R2
 3195/1615 : 50 E3                      	POP	R3		; Restore address of index
 3196/1617 : D6 2C 20                   	CALL	FPTHL		; Move value to index variable
 3197/161A : 50 E2                      	POP	R2
 3198/161C : 50 E3                      	POP	R3		; Restore address of TO value
 3199/161E : D6 2C 07                   	CALL	LOADFP		; Move TO value to BCDE
 3200/1621 : 70 E3                      	PUSH	R3
 3201/1623 : 70 E2                      	PUSH	R2		; Save address of line of FOR
 3202/1625 : D6 2C 5A                   	CALL	CMPNUM		; Compare index with TO value
 3203/1628 : 50 E2                      	POP	R2
 3204/162A : 50 E3                      	POP	R3		; Restore address of line num
 3205/162C : 50 E4                      	POP	R4
 3206/162E : 50 E5                      	POP	R5		; Address of sign of STEP
 3207/1630 : 22 04                      	SUB	R0,R4		; Compare with expected sign
 3208/1632 : D6 2C 07                   	CALL	LOADFP		; BC = Loop stmt,DE = Line num
 3209/1635 :                            
 3210/1635 :                            
 3211/1635 : 88 E4                      	LD	R8,R4		; @@@ SWAP BC
 3212/1637 : 48 E5                      	LD	R4,R5
 3213/1639 : 58 E8                      	LD	R5,R8
 3214/163B : 88 E6                      	LD	R8,R6		; @@@ SWAP DE
 3215/163D : 68 E7                      	LD	R6,R7
 3216/163F : 78 E8                      	LD	R7,R8
 3217/1641 :                            
 3218/1641 : 6D 16 61                   	JP	Z,KILFOR	; Loop finished - Terminate it
 3219/1644 : 88 E6                      	LD	R8,R6
 3220/1646 : 98 E7                      	LD	R9,R7
 3221/1648 : 68 E2                      	LD	R6,R2
 3222/164A : 78 E3                      	LD	R7,R3
 3223/164C : 28 E8                      	LD	R2,R8
 3224/164E : 38 E9                      	LD	R3,R9		; Loop statement line number
 3225/1650 : 8C 80                      	LD	R8,#hi(LINEAT)
 3226/1652 : 9C A9                      	LD	R9,#lo(LINEAT)
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 55 - 2023/10/26 22時18分50秒


 3227/1654 : D2 28                      	LDC	@RR8,R2
 3228/1656 : A0 E8                      	INCW	RR8
 3229/1658 : D2 38                      	LDC	@RR8,R3		; Set loop line number
 3230/165A : 38 E5                      	LD	R3,R5		; Set code string to loop
 3231/165C : 28 E4                      	LD	R2,R4
 3232/165E : 8D 0D 0E                   	JP	PUTFID		; Put back "FOR" and continue
 3233/1661 :                            ;
 3234/1661 :                            KILFOR:
 3235/1661 : 29 FE                      	LD	SPH,R2
 3236/1663 : 39 FF                      	LD	SPL,R3		; Remove "FOR" block
 3237/1665 : 8C 81                      	LD	R8,#hi(BRKLIN)
 3238/1667 : 9C 1B                      	LD	R9,#lo(BRKLIN)
 3239/1669 : C2 28                      	LDC	R2,@RR8
 3240/166B : A0 E8                      	INCW	RR8
 3241/166D : C2 38                      	LDC	R3,@RR8		; Code string after "NEXT"
 3242/166F : C2 02                      	LDC	R0,@RR2		; Get next byte in code string
 3243/1671 : A6 E0 2C                   	CP	R0,#','		; More NEXTs ?
 3244/1674 : ED 0D 12                   	JP	NZ,RUNCNT	; No - Do next statement
 3245/1677 : D6 0D AD                   	CALL	GETCHR		; Position to index name
 3246/167A : D6 15 C2                   	CALL	NEXT1		; Re-enter NEXT routine
 3247/167D :                            ; < will not RETurn to here , Exit to RUNCNT or Loop >
 3248/167D :                            ;
 3249/167D :                            GETNUM:
 3250/167D : D6 16 B8                   	CALL	EVAL		; Get a numeric expression
 3251/1680 :                            TSTNUM:
 3252/1680 : 42 00                      	OR	R0,R0
 3253/1682 : CF                         	RCF			; Clear carry (numeric)
 3254/1683 : 8B 01                      	JR	CHKTYP
 3255/1685 :                            TSTSTR:
 3256/1685 : DF                         	SCF			; Set carry (string)
 3257/1686 :                            CHKTYP:
 3258/1686 : 8C 80                      	LD	R8,#hi(TYPE)
 3259/1688 : 9C FA                      	LD	R9,#lo(TYPE)
 3260/168A : C2 08                      	LDC	R0,@RR8		; Check types match
 3261/168C : 12 00                      	ADC	R0,R0		; Expected + actual
 3262/168E :                            
 3263/168E : 18 E0                      	LD	R1,R0		; @@@
 3264/1690 : C0 E1                      	RRC	R1
 3265/1692 : C0 E1                      	RRC	R1
 3266/1694 : C0 E1                      	RRC	R1
 3267/1696 : C0 E1                      	RRC	R1
 3268/1698 : B2 10                      	XOR	R1,R0
 3269/169A : 88 E1                      	LD	R8,R1
 3270/169C : C0 E1                      	RRC	R1
 3271/169E : C0 E1                      	RRC	R1
 3272/16A0 : B2 18                      	XOR	R1,R8
 3273/16A2 : 88 E1                      	LD	R8,R1
 3274/16A4 : C0 E1                      	RRC	R1
 3275/16A6 : B2 18                      	XOR	R1,R8
 3276/16A8 : 56 E1 01                   	AND	R1,#01H
 3277/16AB : EB 04                      	JR	NZ,CHKTYP1
 3278/16AD : 42 00                      	OR	R0,R0		; Clear carry , set parity
 3279/16AF : CF                         	RCF
 3280/16B0 : AF                         	RET
 3281/16B1 :                            ; RET	PE			; Even parity - Types match
 3282/16B1 :                            CHKTYP1:
 3283/16B1 : 8D 05 17                   	JP	TMERR		; Different types - Error
 3284/16B4 :                            ;
 3285/16B4 :                            OPNPAR:
 3286/16B4 : D6 0A 49                   	CALL	CHKSYN		; Make sure "(" follows
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 56 - 2023/10/26 22時18分50秒


 3287/16B7 : 28                         	DB	"("
 3288/16B8 :                            EVAL:
 3289/16B8 : 80 E2                      	DECW	RR2		; Evaluate expression & save
 3290/16BA : 6C 00                      	LD	R6,#0		; Precedence value
 3291/16BC :                            EVAL1:
 3292/16BC : 70 E7                      	PUSH	R7
 3293/16BE : 70 E6                      	PUSH	R6		; Save precedence
 3294/16C0 : 5C 01                      	LD	R5,#1
 3295/16C2 : D6 04 AC                   	CALL	CHKSTK		; Check for 1 level of stack
 3296/16C5 : D6 17 95                   	CALL	OPRND		; Get next expression value
 3297/16C8 :                            EVAL2:
 3298/16C8 : 8C 81                      	LD	R8,#hi(NXTOPR)
 3299/16CA : 9C 1D                      	LD	R9,#lo(NXTOPR)
 3300/16CC : D2 28                      	LDC	@RR8,R2
 3301/16CE : A0 E8                      	INCW	RR8
 3302/16D0 : D2 38                      	LDC	@RR8,R3		; Save address of next operator
 3303/16D2 :                            EVAL3:
 3304/16D2 : 8C 81                      	LD	R8,#hi(NXTOPR)
 3305/16D4 : 9C 1D                      	LD	R9,#lo(NXTOPR)
 3306/16D6 : C2 28                      	LDC	R2,@RR8
 3307/16D8 : A0 E8                      	INCW	RR8
 3308/16DA : C2 38                      	LDC	R3,@RR8		; Restore address of next opr
 3309/16DC : 50 E4                      	POP	R4
 3310/16DE : 50 E5                      	POP	R5		; Precedence value and operator
 3311/16E0 : 08 E4                      	LD	R0,R4		; Get precedence value
 3312/16E2 : A6 E0 78                   	CP	R0,#78H		; "AND" or "OR" ?
 3313/16E5 : 7B 03                      	JR	C,$+5
 3314/16E7 : D6 16 80                   	CALL	TSTNUM		; No - Make sure it's a number
 3315/16EA : C2 02                      	LDC	R0,@RR2		; Get next operator / function
 3316/16EC : 6C 00                      	LD	R6,#0		; Clear Last relation
 3317/16EE :                            RLTLP:
 3318/16EE : 26 E0 B3                   	SUB	R0,#ZGTR	; ">" Token
 3319/16F1 : 7D 17 18                   	JP	C,FOPRND	; + - * / ^ AND OR - Test it
 3320/16F4 : A6 E0 03                   	CP	R0,#ZLTH+1-ZGTR	; < = >
 3321/16F7 : FD 17 18                   	JP	NC,FOPRND	; Function - Call it
 3322/16FA : A6 E0 01                   	CP	R0,#ZEQUAL-ZGTR	; "="
 3323/16FD : 10 E0                      	RLC	R0		; <- Test for legal
 3324/16FF : B2 06                      	XOR	R0,R6		; <- combinations of < = >
 3325/1701 : A2 06                      	CP	R0,R6		; <- by combining last token
 3326/1703 : 68 E0                      	LD	R6,R0		; <- with current one
 3327/1705 : 7D 04 FF                   	JP	C,SNERR		; Error if "<<' '==" or ">>"
 3328/1708 : 8C 81                      	LD	R8,#hi(CUROPR)
 3329/170A : 9C 12                      	LD	R9,#lo(CUROPR)
 3330/170C : D2 28                      	LDC	@RR8,R2
 3331/170E : A0 E8                      	INCW	RR8
 3332/1710 : D2 38                      	LDC	@RR8,R3		; Save address of current token
 3333/1712 : D6 0D AD                   	CALL	GETCHR		; Get next character
 3334/1715 : 8D 16 EE                   	JP	RLTLP		; Treat the two as one
 3335/1718 :                            ;
 3336/1718 :                            FOPRND:
 3337/1718 : 08 E6                      	LD	R0,R6		; < = > found ?
 3338/171A : 42 00                      	OR	R0,R0
 3339/171C : ED 19 71                   	JP	NZ,TSTRED	; Yes - Test for reduction
 3340/171F : C2 02                      	LDC	R0,@RR2		; Get operator token
 3341/1721 : 8C 81                      	LD	R8,#hi(CUROPR)
 3342/1723 : 9C 12                      	LD	R9,#lo(CUROPR)
 3343/1725 : D2 28                      	LDC	@RR8,R2
 3344/1727 : A0 E8                      	INCW	RR8
 3345/1729 : D2 38                      	LDC	@RR8,R3		; Save operator address
 3346/172B : 26 E0 AC                   	SUB	R0,#ZPLUS	; Operator or function?
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 57 - 2023/10/26 22時18分50秒


 3347/172E : FB 01                      	JR	NC,$+3
 3348/1730 : AF                         	RET			; Neither - Exit
 3349/1731 : A6 E0 07                   	CP	R0,#ZOR+1-ZPLUS	; Is it + - * / ^ AND OR ?
 3350/1734 : 7B 01                      	JR	C,$+3
 3351/1736 : AF                         	RET			; No - Exit
 3352/1737 : 78 E0                      	LD	R7,R0		; Coded operator
 3353/1739 : 8C 80                      	LD	R8,#hi(TYPE)
 3354/173B : 9C FA                      	LD	R9,#lo(TYPE)
 3355/173D : C2 08                      	LDC	R0,@RR8		; Get data type
 3356/173F : 00 E0                      	DEC	R0		; FF = numeric , 00 = string
 3357/1741 : 42 07                      	OR	R0,R7
 3358/1743 : CF                         	RCF			; Combine with coded operator
 3359/1744 : 08 E7                      	LD	R0,R7		; Get coded operator
 3360/1746 : 6D 23 99                   	JP	Z,CONCAT	; String concatenation
 3361/1749 : 90 E0                      	RL	R0		; Times 2
 3362/174B : 02 07                      	ADD	R0,R7		; Times 3
 3363/174D : 78 E0                      	LD	R7,R0		; To DE (D is 0)
 3364/174F : 2C 03                      	LD	R2,#hi(PRITAB)
 3365/1751 : 3C 69                      	LD	R3,#lo(PRITAB)	; Precedence table
 3366/1753 : 02 37                      	ADD	R3,R7
 3367/1755 : 12 26                      	ADC	R2,R6		; To the operator concerned
 3368/1757 : 08 E4                      	LD	R0,R4		; Last operator precedence
 3369/1759 : C2 62                      	LDC	R6,@RR2		; Get evaluation precedence
 3370/175B : A2 06                      	CP	R0,R6		; Compare with eval precedence
 3371/175D : 7B 01                      	JR	C,$+3
 3372/175F : AF                         	RET			; Exit if higher precedence
 3373/1760 : A0 E2                      	INCW	RR2		; Point to routine address
 3374/1762 : D6 16 80                   	CALL	TSTNUM		; Make sure it's a number
 3375/1765 :                            ;
 3376/1765 :                            STKTHS:
 3377/1765 : 70 E5                      	PUSH	R5
 3378/1767 : 70 E4                      	PUSH	R4		; Save last precedence & token
 3379/1769 : 4C 16                      	LD	R4,#hi(EVAL3)
 3380/176B : 5C D2                      	LD	R5,#lo(EVAL3)	; Where to go on prec' break
 3381/176D : 70 E5                      	PUSH	R5
 3382/176F : 70 E4                      	PUSH	R4		; Save on stack for return
 3383/1771 : 48 E7                      	LD	R4,R7		; Save operator
 3384/1773 : 58 E6                      	LD	R5,R6		; Save precedence
 3385/1775 : D6 2B C8                   	CALL	STAKFP		; Move value to stack
 3386/1778 : 78 E4                      	LD	R7,R4		; Restore operator
 3387/177A : 68 E5                      	LD	R6,R5		; Restore precedence
 3388/177C :                            
 3389/177C :                            ;	LDC	R5,@RR2		; Get LSB of routine address
 3390/177C : C2 42                      	LDC	R4,@RR2		; Get MSB of routine address
 3391/177E :                            
 3392/177E : A0 E2                      	INCW	RR2
 3393/1780 :                            
 3394/1780 :                            ;	LDC	R4,@RR2		; Get MSB of routine address
 3395/1780 : C2 52                      	LDC	R5,@RR2		; Get LSB of routine address
 3396/1782 :                            
 3397/1782 : A0 E2                      	INCW	RR2
 3398/1784 : 70 E5                      	PUSH	R5
 3399/1786 : 70 E4                      	PUSH	R4		; Save routine address
 3400/1788 : 8C 81                      	LD	R8,#hi(CUROPR)
 3401/178A : 9C 12                      	LD	R9,#lo(CUROPR)
 3402/178C : C2 28                      	LDC	R2,@RR8
 3403/178E : A0 E8                      	INCW	RR8
 3404/1790 : C2 38                      	LDC	R3,@RR8		; Address of current operator
 3405/1792 : 8D 16 BC                   	JP	EVAL1		; Loop until prec' break
 3406/1795 :                            ;
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 58 - 2023/10/26 22時18分50秒


 3407/1795 :                            OPRND:
 3408/1795 : B2 00                      	XOR	R0,R0		; Get operand routine
 3409/1797 : CF                         	RCF
 3410/1798 : 8C 80                      	LD	R8,#hi(TYPE)
 3411/179A : 9C FA                      	LD	R9,#lo(TYPE)
 3412/179C : D2 08                      	LDC	@RR8,R0		; Set numeric expected
 3413/179E : D6 0D AD                   	CALL	GETCHR		; Get next character
 3414/17A1 : 7C 24                      	LD	R7,#MO		; ?MO Error
 3415/17A3 : 6D 05 19                   	JP	Z,ERROR		; No operand - Error
 3416/17A6 : 7D 2D 7E                   	JP	C,ASCTFP	; Number - Get value
 3417/17A9 : D6 0F 3E                   	CALL	CHKLTR		; See if a letter
 3418/17AC : FB 66                      	JR	NC,CONVAR	; Letter - Find variable
 3419/17AE : A6 E0 26                   	CP	R0,#'&'		; &H = HEX, &B = BINARY
 3420/17B1 : EB 14                      	JR	NZ,NOTAMP
 3421/17B3 : D6 0D AD                   	CALL	GETCHR		; Get next character
 3422/17B6 : A6 E0 48                   	CP	R0,#'H'		; Hex number indicated? [function added]
 3423/17B9 : 6D 34 FB                   	JP	Z,HEXTFP	; Convert Hex to FPREG
 3424/17BC : A6 E0 42                   	CP	R0,#'B'		; Binary number indicated? [function added]
 3425/17BF : 6D 35 B9                   	JP	Z,BINTFP	; Convert Bin to FPREG
 3426/17C2 : 7C 02                      	LD	R7,#SN		; If neither then a ?SN Error
 3427/17C4 : 6D 05 19                   	JP	Z,ERROR
 3428/17C7 :                            NOTAMP:
 3429/17C7 : A6 E0 AC                   	CP	R0,#ZPLUS	; '+' Token ?
 3430/17CA : 6B C9                      	JR	Z,OPRND		; Yes - Look for operand
 3431/17CC : A6 E0 2E                   	CP	R0,#'.'		; '.' ?
 3432/17CF : 6D 2D 7E                   	JP	Z,ASCTFP	; Yes - Create FP number
 3433/17D2 : A6 E0 AD                   	CP	R0,#ZMINUS	; '-' Token ?
 3434/17D5 : 6B 1F                      	JR	Z,MINUS		; Yes - Do minus
 3435/17D7 : A6 E0 22                   	CP	R0,#'"'		; Literal string ?
 3436/17DA : 6D 20 79                   	JP	Z,QTSTR		; Get string terminated by '"'
 3437/17DD : A6 E0 AA                   	CP	R0,#ZNOT	; "NOT" Token ?
 3438/17E0 : 6D 1A 27                   	JP	Z,EVNOT		; Yes - Eval NOT expression
 3439/17E3 : A6 E0 A7                   	CP	R0,#ZFN		; "FN" Token ?
 3440/17E6 : 6D 1F 2D                   	JP	Z,DOFN		; Yes - Do FN routine
 3441/17E9 : 26 E0 B6                   	SUB	R0,#ZSGN	; Is it a function?
 3442/17EC : FB 56                      	JR	NC,FNOFST	; Yes - Evaluate function
 3443/17EE :                            EVLPAR:
 3444/17EE : D6 16 B4                   	CALL	OPNPAR		; Evaluate expression in "()"
 3445/17F1 : D6 0A 49                   	CALL	CHKSYN		; Make sure ")" follows
 3446/17F4 : 29                         	DB	")"
 3447/17F5 : AF                         	RET
 3448/17F6 :                            ;
 3449/17F6 :                            MINUS:
 3450/17F6 : 6C 7D                      	LD	R6,#7DH		; '-' precedence
 3451/17F8 : D6 16 BC                   	CALL	EVAL1		; Evaluate until prec' break
 3452/17FB : 8C 81                      	LD	R8,#hi(NXTOPR)
 3453/17FD : 9C 1D                      	LD	R9,#lo(NXTOPR)
 3454/17FF : C2 28                      	LDC	R2,@RR8
 3455/1801 : A0 E8                      	INCW	RR8
 3456/1803 : C2 38                      	LDC	R3,@RR8		; Get next operator address
 3457/1805 : 70 E3                      	PUSH	R3
 3458/1807 : 70 E2                      	PUSH	R2		; Save next operator address
 3459/1809 : D6 2B BC                   	CALL	INVSGN		; Negate value
 3460/180C :                            RETNUM:
 3461/180C : D6 16 80                   	CALL	TSTNUM		; Make sure it's a number
 3462/180F : 50 E2                      	POP	R2
 3463/1811 : 50 E3                      	POP	R3		; Restore next operator address
 3464/1813 : AF                         	RET
 3465/1814 :                            ;
 3466/1814 :                            CONVAR:
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 59 - 2023/10/26 22時18分50秒


 3467/1814 : D6 1A 60                   	CALL	GETVAR		; Get variable address to DE
 3468/1817 :                            FRMEVL:
 3469/1817 : 70 E3                      	PUSH	R3
 3470/1819 : 70 E2                      	PUSH	R2		; Save code string address
 3471/181B : 88 E6                      	LD	R8,R6
 3472/181D : 98 E7                      	LD	R9,R7
 3473/181F : 68 E2                      	LD	R6,R2
 3474/1821 : 78 E3                      	LD	R7,R3
 3475/1823 : 28 E8                      	LD	R2,R8
 3476/1825 : 38 E9                      	LD	R3,R9		; Variable address to HL
 3477/1827 : 8C 81                      	LD	R8,#hi(FPREG)
 3478/1829 : 9C 31                      	LD	R9,#lo(FPREG)
 3479/182B :                            
 3480/182B :                            ;	LDC	@RR8,R2
 3481/182B :                            ;	LD	R1,FLAGS
 3482/182B :                            ;	INCW	RR8
 3483/182B :                            ;	LD	FLAGS,R1
 3484/182B :                            ;	LDC	@RR8,R3		; Save address of variable
 3485/182B : D2 38                      	LDC	@RR8,R3		; @@@ SWAP HL
 3486/182D : A0 E8                      	INCW	RR8
 3487/182F : D2 28                      	LDC	@RR8,R2		; Save address of variable
 3488/1831 :                            
 3489/1831 : 8C 80                      	LD	R8,#hi(TYPE)
 3490/1833 : 9C FA                      	LD	R9,#lo(TYPE)
 3491/1835 : C2 08                      	LDC	R0,@RR8		; Get type
 3492/1837 : 42 00                      	OR	R0,R0
 3493/1839 : CF                         	RCF			; Numeric?
 3494/183A : EB 03                      	JR	NZ,$+5
 3495/183C : D6 2B EB                   	CALL	PHLTFP		; Yes - Move contents to FPREG
 3496/183F : 50 E2                      	POP	R2
 3497/1841 : 50 E3                      	POP	R3		; Restore code string address
 3498/1843 : AF                         	RET
 3499/1844 :                            ;
 3500/1844 :                            FNOFST:
 3501/1844 : 4C 00                      	LD	R4,#0		; Get address of function
 3502/1846 : 90 E0                      	RL	R0		; Double function offset
 3503/1848 : 58 E0                      	LD	R5,R0		; BC = Offset in function table
 3504/184A : 70 E5                      	PUSH	R5
 3505/184C : 70 E4                      	PUSH	R4		; Save adjusted token value
 3506/184E : D6 0D AD                   	CALL	GETCHR		; Get next character
 3507/1851 : 08 E5                      	LD	R0,R5		; Get adjusted token value
 3508/1853 : A6 E0 31                   	CP	R0,#2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
 3509/1856 : 7D 18 B3                   	JP	C,FNVAL		; No - Do function
 3510/1859 : D6 16 B4                   	CALL	OPNPAR		; Evaluate expression	(X,...
 3511/185C : D6 0A 49                   	CALL	CHKSYN		; Make sure ',' follows
 3512/185F : 2C                         	DB	','
 3513/1860 : D6 16 85                   	CALL	TSTSTR		; Make sure it's a string
 3514/1863 : 88 E6                      	LD	R8,R6
 3515/1865 : 98 E7                      	LD	R9,R7
 3516/1867 : 68 E2                      	LD	R6,R2
 3517/1869 : 78 E3                      	LD	R7,R3
 3518/186B : 28 E8                      	LD	R2,R8
 3519/186D : 38 E9                      	LD	R3,R9		; Save code string address
 3520/186F : 8C 81                      	LD	R8,#hi(FPREG)
 3521/1871 : 9C 31                      	LD	R9,#lo(FPREG)
 3522/1873 :                            
 3523/1873 :                            ;	LDC	R2,@RR8
 3524/1873 :                            ;	LD	R1,FLAGS
 3525/1873 :                            ;	INCW	RR8
 3526/1873 :                            ;	LD	FLAGS,R1
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 60 - 2023/10/26 22時18分50秒


 3527/1873 :                            ;	LDC	R3,@RR8		; Get address of string
 3528/1873 : C2 38                      	LDC	R3,@RR8		; @@@ SWAP HL
 3529/1875 : A0 E8                      	INCW	RR8
 3530/1877 : C2 28                      	LDC	R2,@RR8		; Get address of string
 3531/1879 :                            
 3532/1879 : 50 E8                      	POP	R8
 3533/187B : 50 E9                      	POP	R9
 3534/187D : 70 E3                      	PUSH	R3
 3535/187F : 70 E2                      	PUSH	R2
 3536/1881 : 28 E8                      	LD	R2,R8
 3537/1883 : 38 E9                      	LD	R3,R9		; Save address of string
 3538/1885 : 70 E3                      	PUSH	R3
 3539/1887 : 70 E2                      	PUSH	R2		; Save adjusted token value
 3540/1889 : 88 E6                      	LD	R8,R6
 3541/188B : 98 E7                      	LD	R9,R7
 3542/188D : 68 E2                      	LD	R6,R2
 3543/188F : 78 E3                      	LD	R7,R3
 3544/1891 : 28 E8                      	LD	R2,R8
 3545/1893 : 38 E9                      	LD	R3,R9		; Restore code string address
 3546/1895 : D6 26 EB                   	CALL	GETINT		; Get integer 0-255
 3547/1898 : 88 E6                      	LD	R8,R6
 3548/189A : 98 E7                      	LD	R9,R7
 3549/189C : 68 E2                      	LD	R6,R2
 3550/189E : 78 E3                      	LD	R7,R3
 3551/18A0 : 28 E8                      	LD	R2,R8
 3552/18A2 : 38 E9                      	LD	R3,R9		; Save code string address
 3553/18A4 : 50 E8                      	POP	R8
 3554/18A6 : 50 E9                      	POP	R9
 3555/18A8 : 70 E3                      	PUSH	R3
 3556/18AA : 70 E2                      	PUSH	R2
 3557/18AC : 28 E8                      	LD	R2,R8
 3558/18AE : 38 E9                      	LD	R3,R9		; Save integer,HL = adj' token
 3559/18B0 : 8D 18 CA                   	JP	GOFUNC		; Jump to string function
 3560/18B3 :                            ;
 3561/18B3 :                            FNVAL:
 3562/18B3 : D6 17 EE                   	CALL	EVLPAR		; Evaluate expression
 3563/18B6 : 50 E8                      	POP	R8
 3564/18B8 : 50 E9                      	POP	R9
 3565/18BA : 70 E3                      	PUSH	R3
 3566/18BC : 70 E2                      	PUSH	R2
 3567/18BE : 28 E8                      	LD	R2,R8
 3568/18C0 : 38 E9                      	LD	R3,R9		; HL = Adjusted token value
 3569/18C2 : 6C 18                      	LD	R6,#hi(RETNUM)
 3570/18C4 : 7C 0C                      	LD	R7,#lo(RETNUM)	; Return number from function
 3571/18C6 : 70 E7                      	PUSH	R7
 3572/18C8 : 70 E6                      	PUSH	R6		; Save on stack
 3573/18CA :                            GOFUNC:
 3574/18CA : 4C 01                      	LD	R4,#hi(FNCTAB)
 3575/18CC : 5C C8                      	LD	R5,#lo(FNCTAB)	; Function routine addresses
 3576/18CE : 02 35                      	ADD	R3,R5
 3577/18D0 : 12 24                      	ADC	R2,R4		; Point to right address
 3578/18D2 :                            
 3579/18D2 :                            ;	LDC	R5,@RR2		; Get LSB of address
 3580/18D2 : C2 42                      	LDC	R4,@RR2		; Get LSB of address
 3581/18D4 :                            
 3582/18D4 : A0 E2                      	INCW	RR2
 3583/18D6 :                            
 3584/18D6 :                            ;	LDC	R2,@RR2		; Get MSB of address
 3585/18D6 : C2 32                      	LDC	R3,@RR2		; Get MSB of address
 3586/18D8 :                            ;	LD	R3,R5		; Address to HL
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 61 - 2023/10/26 22時18分50秒


 3587/18D8 : 28 E4                      	LD	R2,R4		; Address to HL
 3588/18DA : 30 E2                      	JP	@RR2		; Jump to function
 3589/18DC :                            ;
 3590/18DC :                            SGNEXP:
 3591/18DC : 00 E6                      	DEC	R6		; Dee to flag negative exponent
 3592/18DE : A6 E0 AD                   	CP	R0,#ZMINUS	; '-' token ?
 3593/18E1 : EB 01                      	JR	NZ,$+3
 3594/18E3 : AF                         	RET			; Yes - Return
 3595/18E4 : A6 E0 2D                   	CP	R0,#'-'		; '-' ASCII ?
 3596/18E7 : EB 01                      	JR	NZ,$+3
 3597/18E9 : AF                         	RET			; Yes - Return
 3598/18EA : 6E                         	INC	R6		; Inc to flag positive exponent
 3599/18EB : A6 E0 2B                   	CP	R0,#'+'		; '+' ASCII ?
 3600/18EE : EB 01                      	JR	NZ,$+3
 3601/18F0 : AF                         	RET			; Yes - Return
 3602/18F1 : A6 E0 AC                   	CP	R0,#ZPLUS	; '+' token ?
 3603/18F4 : EB 01                      	JR	NZ,$+3
 3604/18F6 : AF                         	RET			; Yes - Return
 3605/18F7 :                            ;	LD	R1,FLAGS
 3606/18F7 : 80 E2                      	DECW	RR2		; DEC 'cos GETCHR INCs
 3607/18F9 :                            ;	LD	FLAGS,R1
 3608/18F9 : AF                         	RET			; Return "NZ"
 3609/18FA :                            ;
 3610/18FA :                            POR:
 3611/18FA : 46 E0 AF                   	OR	R0,#0AFH	; Flag "OR"
 3612/18FD : CF                         	RCF
 3613/18FE : 8B 03                      	JR	PAND1
 3614/1900 :                            PAND:
 3615/1900 : B2 00                      	XOR	R0,R0		; Flag "AND"
 3616/1902 : CF                         	RCF
 3617/1903 :                            PAND1:
 3618/1903 : 18 FC                      	LD	R1,FLAGS
 3619/1905 : 70 E1                      	PUSH	R1
 3620/1907 : 70 E0                      	PUSH	R0		; Save "AND" / "OR" flag
 3621/1909 : D6 16 80                   	CALL	TSTNUM		; Make sure it's a number
 3622/190C : D6 0F 57                   	CALL	DEINT		; Get integer -32768 to 32767
 3623/190F : 50 E0                      	POP	R0		; Restore "AND" / "OR" flag
 3624/1911 : 50 E1                      	POP	R1
 3625/1913 : 19 FC                      	LD	FLAGS,R1
 3626/1915 : 88 E6                      	LD	R8,R6
 3627/1917 : 98 E7                      	LD	R9,R7
 3628/1919 : 68 E2                      	LD	R6,R2
 3629/191B : 78 E3                      	LD	R7,R3
 3630/191D : 28 E8                      	LD	R2,R8
 3631/191F : 38 E9                      	LD	R3,R9		; <- Get last
 3632/1921 : 50 E4                      	POP	R4
 3633/1923 : 50 E5                      	POP	R5		; <- value
 3634/1925 : 50 E8                      	POP	R8
 3635/1927 : 50 E9                      	POP	R9
 3636/1929 : 70 E3                      	PUSH	R3
 3637/192B : 70 E2                      	PUSH	R2
 3638/192D : 28 E8                      	LD	R2,R8
 3639/192F : 38 E9                      	LD	R3,R9		; <- from
 3640/1931 : 88 E6                      	LD	R8,R6
 3641/1933 : 98 E7                      	LD	R9,R7
 3642/1935 : 68 E2                      	LD	R6,R2
 3643/1937 : 78 E3                      	LD	R7,R3
 3644/1939 : 28 E8                      	LD	R2,R8
 3645/193B : 38 E9                      	LD	R3,R9		; <- stack
 3646/193D : D6 2B EE                   	CALL	FPBCDE		; Move last value to FPREG
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 62 - 2023/10/26 22時18分50秒


 3647/1940 : 18 FC                      	LD	R1,FLAGS
 3648/1942 : 70 E1                      	PUSH	R1
 3649/1944 : 70 E0                      	PUSH	R0		; Save "AND" / "OR" flag
 3650/1946 : D6 0F 57                   	CALL	DEINT		; Get integer -32768 to 32767
 3651/1949 : 50 E0                      	POP	R0		; Restore "AND" / "OR" flag
 3652/194B : 50 E1                      	POP	R1
 3653/194D : 19 FC                      	LD	FLAGS,R1
 3654/194F : 50 E4                      	POP	R4
 3655/1951 : 50 E5                      	POP	R5		; Get value
 3656/1953 : 08 E5                      	LD	R0,R5		; Get LSB
 3657/1955 : 2C 1E                      	LD	R2,#hi(ACPASS)	; Address of save AC as current
 3658/1957 : 3C B1                      	LD	R3,#lo(ACPASS)
 3659/1959 : ED 19 66                   	JP	NZ,POR1		; Jump if OR
 3660/195C : 52 07                      	AND	R0,R7		; "AND" LSBs
 3661/195E : 58 E0                      	LD	R5,R0		; Save LSB
 3662/1960 : 08 E4                      	LD	R0,R4		; Get MBS
 3663/1962 : 52 06                      	AND	R0,R6		; "AND" MSBs
 3664/1964 : 30 E2                      	JP	@RR2		; Save AC as current (ACPASS)
 3665/1966 :                            ;
 3666/1966 :                            POR1:
 3667/1966 : 42 07                      	OR	R0,R7		; "OR" LSBs
 3668/1968 : 58 E0                      	LD	R5,R0		; Save LSB
 3669/196A : 08 E4                      	LD	R0,R4		; Get MSB
 3670/196C : 42 06                      	OR	R0,R6		; "OR" MSBs
 3671/196E : CF                         	RCF
 3672/196F : 30 E2                      	JP	@RR2		; Save AC as current (ACPASS)
 3673/1971 :                            ;
 3674/1971 :                            TSTRED:
 3675/1971 : 2C 19                      	LD	R2,#hi(CMPLOG)	; Logical compare routine
 3676/1973 : 3C 8F                      	LD	R3,#lo(CMPLOG)
 3677/1975 : 8C 80                      	LD	R8,#hi(TYPE)
 3678/1977 : 9C FA                      	LD	R9,#lo(TYPE)
 3679/1979 : C2 08                      	LDC	R0,@RR8		; Get data type
 3680/197B : C0 E0                      	RRC	R0		; Carry set = string
 3681/197D : 08 E6                      	LD	R0,R6		; Get last precedence value
 3682/197F : 10 E0                      	RLC	R0		; Times 2 plus carry
 3683/1981 : 78 E0                      	LD	R7,R0		; To E
 3684/1983 : 6C 64                      	LD	R6,#64H		; Relational precedence
 3685/1985 : 08 E4                      	LD	R0,R4		; Get current precedence
 3686/1987 : A2 06                      	CP	R0,R6		; Compare with last
 3687/1989 : 7B 01                      	JR	C,$+3
 3688/198B : AF                         	RET			; Eval if last was rel' or log'
 3689/198C : 8D 17 65                   	JP	STKTHS		; Stack this one and get next
 3690/198F :                            ;
 3691/198F :                            CMPLOG:
 3692/198F : 19 91                      	DW	CMPLG1		; Compare two values / strings
 3693/1991 :                            CMPLG1:
 3694/1991 : 08 E5                      	LD	R0,R5		; Get data type
 3695/1993 : 42 00                      	OR	R0,R0
 3696/1995 : CF                         	RCF
 3697/1996 : C0 E0                      	RRC	R0
 3698/1998 : 50 E4                      	POP	R4
 3699/199A : 50 E5                      	POP	R5		; Get last expression to BCDE
 3700/199C : 50 E6                      	POP	R6
 3701/199E : 50 E7                      	POP	R7
 3702/19A0 : 18 FC                      	LD	R1,FLAGS
 3703/19A2 : 70 E1                      	PUSH	R1
 3704/19A4 : 70 E0                      	PUSH	R0		; Save status
 3705/19A6 : D6 16 86                   	CALL	CHKTYP		; Check that types match
 3706/19A9 : 2C 1A                      	LD	R2,#hi(CMPRES)	; Result to comparison
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 63 - 2023/10/26 22時18分50秒


 3707/19AB : 3C 16                      	LD	R3,#lo(CMPRES)
 3708/19AD : 70 E3                      	PUSH	R3
 3709/19AF : 70 E2                      	PUSH	R2		; Save for RETurn
 3710/19B1 : 6D 2C 5A                   	JP	Z,CMPNUM	; Compare values if numeric
 3711/19B4 : B2 00                      	XOR	R0,R0		; Compare two strings
 3712/19B6 : CF                         	RCF
 3713/19B7 : 8C 80                      	LD	R8,#hi(TYPE)
 3714/19B9 : 9C FA                      	LD	R9,#lo(TYPE)
 3715/19BB : D2 08                      	LDC	@RR8,R0		; Set type to numeric
 3716/19BD : 70 E7                      	PUSH	R7
 3717/19BF : 70 E6                      	PUSH	R6		; Save string name
 3718/19C1 : D6 24 68                   	CALL	GSTRCU		; Get current string
 3719/19C4 : C2 02                      	LDC	R0,@RR2		; Get length of string
 3720/19C6 : A0 E2                      	INCW	RR2
 3721/19C8 : A0 E2                      	INCW	RR2
 3722/19CA : C2 52                      	LDC	R5,@RR2		; Get LSB of address
 3723/19CC : A0 E2                      	INCW	RR2
 3724/19CE : C2 42                      	LDC	R4,@RR2		; Get MSB of address
 3725/19D0 : 50 E6                      	POP	R6
 3726/19D2 : 50 E7                      	POP	R7		; Restore string name
 3727/19D4 : 70 E5                      	PUSH	R5
 3728/19D6 : 70 E4                      	PUSH	R4		; Save address of string
 3729/19D8 :                            ;	LD	R1,FLAGS
 3730/19D8 :                            ;	PUSH	R1
 3731/19D8 : 70 E0                      	PUSH	R0		; Save length of string
 3732/19DA : D6 24 7E                   	CALL	GSTRDE		; Get second string
 3733/19DD : D6 2C 07                   	CALL	LOADFP		; Get address of second string
 3734/19E0 : 50 E0                      	POP	R0		; Restore length of string 1
 3735/19E2 :                            ;	POP	R1
 3736/19E2 :                            ;	LD	FLAGS,R1
 3737/19E2 : 68 E0                      	LD	R6,R0		; Length to D
 3738/19E4 : 50 E2                      	POP	R2
 3739/19E6 : 50 E3                      	POP	R3		; Restore address of string 1
 3740/19E8 :                            CMPSTR:
 3741/19E8 : 08 E7                      	LD	R0,R7		; Bytes of string 2 to do
 3742/19EA : 42 06                      	OR	R0,R6
 3743/19EC : CF                         	RCF			; Bytes of string 1 to do
 3744/19ED : EB 01                      	JR	NZ,$+3
 3745/19EF : AF                         	RET			; Exit if all bytes compared
 3746/19F0 : 08 E6                      	LD	R0,R6		; Get bytes of string 1 to do
 3747/19F2 : 26 E0 01                   	SUB	R0,#1
 3748/19F5 : FB 01                      	JR	NC,$+3
 3749/19F7 : AF                         	RET			; Exit if end of string 1
 3750/19F8 : B2 00                      	XOR	R0,R0
 3751/19FA : CF                         	RCF
 3752/19FB : A2 07                      	CP	R0,R7		; Bytes of string 2 to do
 3753/19FD : 0E                         	INC	R0
 3754/19FE : 7B 01                      	JR	C,$+3
 3755/1A00 : AF                         	RET			; Exit if end of string 2
 3756/1A01 : 00 E6                      	DEC	R6		; Count bytes in string 1
 3757/1A03 : 00 E7                      	DEC	R7		; Count bytes in string 2
 3758/1A05 : C2 04                      	LDC	R0,@RR4		; Byte in string 2
 3759/1A07 : C2 82                      	LDC	R8,@RR2
 3760/1A09 : A0 E2                      	INCW	RR2		; Move up string 1
 3761/1A0B : A0 E4                      	INCW	RR4		; Move up string 2
 3762/1A0D : A2 08                      	CP	R0,R8		; Compare to byte in string 1
 3763/1A0F : 6D 19 E8                   	JP	Z,CMPSTR	; Same - Try next bytes
 3764/1A12 : EF                         	CCF			; Flag difference (">" or "<")
 3765/1A13 : 8D 2B 91                   	JP	FLGDIF		; "<" gives -1 , ">" gives +1
 3766/1A16 :                            ;
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 64 - 2023/10/26 22時18分50秒


 3767/1A16 :                            CMPRES:
 3768/1A16 : 0E                         	INC	R0		; Increment current value
 3769/1A17 : 12 00                      	ADC	R0,R0		; Double plus carry
 3770/1A19 : 50 E4                      	POP	R4
 3771/1A1B : 50 E5                      	POP	R5		; Get other value
 3772/1A1D : 52 04                      	AND	R0,R4		; Combine them
 3773/1A1F : 06 E0 FF                   	ADD	R0,#-1		; Carry set if different
 3774/1A22 : 32 00                      	SBC	R0,R0		; 00 - Equal , FF - Different
 3775/1A24 : 8D 2B 9B                   	JP	FLGREL		; Set current value & continue
 3776/1A27 :                            ;
 3777/1A27 :                            EVNOT:
 3778/1A27 : 6C 5A                      	LD	R6,#5AH		; Precedence value for "NOT"
 3779/1A29 : D6 16 BC                   	CALL	EVAL1		; Eval until precedence break
 3780/1A2C : D6 16 80                   	CALL	TSTNUM		; Make sure it's a number
 3781/1A2F : D6 0F 57                   	CALL	DEINT		; Get integer -32768 - 32767
 3782/1A32 : 08 E7                      	LD	R0,R7		; Get LSB
 3783/1A34 : 60 E0                      	COM	R0		; Invert LSB
 3784/1A36 : 58 E0                      	LD	R5,R0		; Save "NOT" of LSB
 3785/1A38 : 08 E6                      	LD	R0,R6		; Get MSB
 3786/1A3A : 60 E0                      	COM	R0		; Invert MSB
 3787/1A3C : D6 1E B1                   	CALL	ACPASS		; Save AC as current
 3788/1A3F : 50 E4                      	POP	R4
 3789/1A41 : 50 E5                      	POP	R5		; Clean up stack
 3790/1A43 : 8D 16 D2                   	JP	EVAL3		; Continue evaluation
 3791/1A46 :                            ;
 3792/1A46 :                            DIMRET:
 3793/1A46 : 80 E2                      	DECW	RR2		; DEC 'cos GETCHR INCs
 3794/1A48 : D6 0D AD                   	CALL	GETCHR		; Get next character
 3795/1A4B : EB 01                      	JR	NZ,$+3
 3796/1A4D : AF                         	RET			; End of DIM statement
 3797/1A4E : D6 0A 49                   	CALL	CHKSYN		; Make sure ',' follows
 3798/1A51 : 2C                         	DB	','
 3799/1A52 :                            DIM:
 3800/1A52 : 4C 1A                      	LD	R4,#hi(DIMRET)
 3801/1A54 : 5C 46                      	LD	R5,#lo(DIMRET)	; Return to "DIMRET"
 3802/1A56 : 70 E5                      	PUSH	R5
 3803/1A58 : 70 E4                      	PUSH	R4		; Save on stack
 3804/1A5A : 46 E0 AF                   	OR	R0,#0AFH
 3805/1A5D : CF                         	RCF			; Flag "Create" variable
 3806/1A5E : 8B 03                      	JR	GETVAR1
 3807/1A60 :                            GETVAR:
 3808/1A60 : B2 00                      	XOR	R0,R0
 3809/1A62 : CF                         	RCF			; Find variable address,to DE
 3810/1A63 :                            GETVAR1:
 3811/1A63 : 8C 80                      	LD	R8,#hi(LCRFLG)
 3812/1A65 : 9C F9                      	LD	R9,#lo(LCRFLG)
 3813/1A67 : D2 08                      	LDC	@RR8,R0		; Set locate / create flag
 3814/1A69 : C2 42                      	LDC	R4,@RR2		; Get First byte of name
 3815/1A6B :                            GTFNAM:
 3816/1A6B : D6 0F 3E                   	CALL	CHKLTR		; See if a letter
 3817/1A6E : 7D 04 FF                   	JP	C,SNERR		; ?SN Error if not a letter
 3818/1A71 : B2 00                      	XOR	R0,R0
 3819/1A73 : CF                         	RCF
 3820/1A74 : 58 E0                      	LD	R5,R0		; Clear second byte of name
 3821/1A76 : 8C 80                      	LD	R8,#hi(TYPE)
 3822/1A78 : 9C FA                      	LD	R9,#lo(TYPE)
 3823/1A7A : D2 08                      	LDC	@RR8,R0		; Set type to numeric
 3824/1A7C : D6 0D AD                   	CALL	GETCHR		; Get next character
 3825/1A7F : 7D 1A 88                   	JP	C,SVNAM2	; Numeric - Save in name
 3826/1A82 : D6 0F 3E                   	CALL	CHKLTR		; See if a letter
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 65 - 2023/10/26 22時18分50秒


 3827/1A85 : 7D 1A 96                   	JP	C,CHARTY	; Not a letter - Check type
 3828/1A88 :                            SVNAM2:
 3829/1A88 : 58 E0                      	LD	R5,R0		; Save second byte of name
 3830/1A8A :                            ENDNAM:
 3831/1A8A : D6 0D AD                   	CALL	GETCHR		; Get next character
 3832/1A8D : 7D 1A 8A                   	JP	C,ENDNAM	; Numeric - Get another
 3833/1A90 : D6 0F 3E                   	CALL	CHKLTR		; See if a letter
 3834/1A93 : FD 1A 8A                   	JP	NC,ENDNAM	; Letter - Get another
 3835/1A96 :                            CHARTY:
 3836/1A96 : 26 E0 24                   	SUB	R0,#'$'		; String variable?
 3837/1A99 : ED 1A AC                   	JP	NZ,NOTSTR	; No - Numeric variable
 3838/1A9C : 0E                         	INC	R0		; A = 1 (string type)
 3839/1A9D : 8C 80                      	LD	R8,#hi(TYPE)
 3840/1A9F : 9C FA                      	LD	R9,#lo(TYPE)
 3841/1AA1 : D2 08                      	LDC	@RR8,R0		; Set type to string
 3842/1AA3 : E0 E0                      	RR	R0		; A = 80H , Flag for string
 3843/1AA5 : 02 05                      	ADD	R0,R5		; 2nd byte of name has bit 7 on
 3844/1AA7 : 58 E0                      	LD	R5,R0		; Resave second byte on name
 3845/1AA9 : D6 0D AD                   	CALL	GETCHR		; Get next character
 3846/1AAC :                            NOTSTR:
 3847/1AAC : 8C 81                      	LD	R8,#hi(FORFLG)
 3848/1AAE : 9C 18                      	LD	R9,#lo(FORFLG)
 3849/1AB0 : C2 08                      	LDC	R0,@RR8		; Array name needed ?
 3850/1AB2 : 00 E0                      	DEC	R0
 3851/1AB4 : 6D 1C 6D                   	JP	Z,ARLDSV	; Yes - Get array name
 3852/1AB7 : DD 1A C2                   	JP	PL,NSCFOR	; No array with "FOR" or "FN"
 3853/1ABA : C2 02                      	LDC	R0,@RR2		; Get byte again
 3854/1ABC : 26 E0 28                   	SUB	R0,#'('		; Subscripted variable?
 3855/1ABF : 6D 1B EB                   	JP	Z,SBSCPT	; Yes - Sort out subscript
 3856/1AC2 :                            ;
 3857/1AC2 :                            NSCFOR:
 3858/1AC2 : B2 00                      	XOR	R0,R0
 3859/1AC4 : CF                         	RCF			; Simple variable
 3860/1AC5 : 8C 81                      	LD	R8,#hi(FORFLG)
 3861/1AC7 : 9C 18                      	LD	R9,#lo(FORFLG)
 3862/1AC9 : D2 08                      	LDC	@RR8,R0		; Clear "FOR" flag
 3863/1ACB : 70 E3                      	PUSH	R3
 3864/1ACD : 70 E2                      	PUSH	R2		; Save code string address
 3865/1ACF : 68 E4                      	LD	R6,R4		; DE = Variable name to find
 3866/1AD1 : 78 E5                      	LD	R7,R5
 3867/1AD3 : 8C 81                      	LD	R8,#hi(FNRGNM)
 3868/1AD5 : 9C 2B                      	LD	R9,#lo(FNRGNM)
 3869/1AD7 : C2 28                      	LDC	R2,@RR8
 3870/1AD9 : A0 E8                      	INCW	RR8
 3871/1ADB : C2 38                      	LDC	R3,@RR8		; FN argument name
 3872/1ADD : D6 0A 3D                   	CALL	CPDEHL		; Is it the FN argument?
 3873/1AE0 : 6C 81                      	LD	R6,#hi(FNARG)
 3874/1AE2 : 7C 2D                      	LD	R7,#lo(FNARG)	; Point to argument value
 3875/1AE4 : 6D 2A 1C                   	JP	Z,POPHRT	; Yes - Return FN argument value
 3876/1AE7 : 8C 81                      	LD	R8,#hi(VAREND)
 3877/1AE9 : 9C 25                      	LD	R9,#lo(VAREND)
 3878/1AEB : C2 28                      	LDC	R2,@RR8
 3879/1AED : A0 E8                      	INCW	RR8
 3880/1AEF : C2 38                      	LDC	R3,@RR8		; End of variables
 3881/1AF1 : 88 E6                      	LD	R8,R6
 3882/1AF3 : 98 E7                      	LD	R9,R7
 3883/1AF5 : 68 E2                      	LD	R6,R2
 3884/1AF7 : 78 E3                      	LD	R7,R3
 3885/1AF9 : 28 E8                      	LD	R2,R8
 3886/1AFB : 38 E9                      	LD	R3,R9		; Address of end of search
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 66 - 2023/10/26 22時18分50秒


 3887/1AFD : 8C 81                      	LD	R8,#hi(PROGND)
 3888/1AFF : 9C 23                      	LD	R9,#lo(PROGND)
 3889/1B01 : C2 28                      	LDC	R2,@RR8
 3890/1B03 : A0 E8                      	INCW	RR8
 3891/1B05 : C2 38                      	LDC	R3,@RR8		; Start of variables address
 3892/1B07 :                            FNDVAR:
 3893/1B07 : D6 0A 3D                   	CALL	CPDEHL		; End of variable list table?
 3894/1B0A : 6D 1B 32                   	JP	Z,CFEVAL	; Yes - Called from EVAL?
 3895/1B0D : 08 E5                      	LD	R0,R5		; Get second byte of name
 3896/1B0F : C2 82                      	LDC	R8,@RR2
 3897/1B11 : A0 E2                      	INCW	RR2		; Move on to first byte
 3898/1B13 : 22 08                      	SUB	R0,R8		; Compare with name in list
 3899/1B15 : ED 1B 1E                   	JP	NZ,FNTHR	; Different - Find another
 3900/1B18 : 08 E4                      	LD	R0,R4		; Get first byte of name
 3901/1B1A : C2 82                      	LDC	R8,@RR2
 3902/1B1C : 22 08                      	SUB	R0,R8		; Compare with name in list
 3903/1B1E :                            FNTHR:
 3904/1B1E : 18 FC                      	LD	R1,FLAGS
 3905/1B20 : A0 E2                      	INCW	RR2		; Move on to LSB of value
 3906/1B22 : 19 FC                      	LD	FLAGS,R1
 3907/1B24 : 6D 1B BD                   	JP	Z,RETADR	; Found - Return address
 3908/1B27 : A0 E2                      	INCW	RR2		; <- Skip
 3909/1B29 : A0 E2                      	INCW	RR2		; <- over
 3910/1B2B : A0 E2                      	INCW	RR2		; <- F.P.
 3911/1B2D : A0 E2                      	INCW	RR2		; <- value
 3912/1B2F : 8D 1B 07                   	JP	FNDVAR		; Keep looking
 3913/1B32 :                            ;
 3914/1B32 :                            CFEVAL:
 3915/1B32 : 50 E2                      	POP	R2
 3916/1B34 : 50 E3                      	POP	R3		; Restore code string address
 3917/1B36 : 50 E8                      	POP	R8
 3918/1B38 : 50 E9                      	POP	R9
 3919/1B3A : 70 E3                      	PUSH	R3
 3920/1B3C : 70 E2                      	PUSH	R2
 3921/1B3E : 28 E8                      	LD	R2,R8
 3922/1B40 : 38 E9                      	LD	R3,R9		; Get return address
 3923/1B42 : 70 E7                      	PUSH	R7
 3924/1B44 : 70 E6                      	PUSH	R6		; Save address of variable
 3925/1B46 : 6C 18                      	LD	R6,#hi(FRMEVL)
 3926/1B48 : 7C 17                      	LD	R7,#lo(FRMEVL)	; Return address in EVAL
 3927/1B4A : D6 0A 3D                   	CALL	CPDEHL		; Called from EVAL ?
 3928/1B4D : 50 E6                      	POP	R6
 3929/1B4F : 50 E7                      	POP	R7		; Restore address of variable
 3930/1B51 : 6D 1B CE                   	JP	Z,RETNUL	; Yes - Return null variable
 3931/1B54 : 50 E8                      	POP	R8
 3932/1B56 : 50 E9                      	POP	R9
 3933/1B58 : 70 E3                      	PUSH	R3
 3934/1B5A : 70 E2                      	PUSH	R2
 3935/1B5C : 28 E8                      	LD	R2,R8
 3936/1B5E : 38 E9                      	LD	R3,R9		; Put back return
 3937/1B60 : 70 E3                      	PUSH	R3
 3938/1B62 : 70 E2                      	PUSH	R2		; Save code string address
 3939/1B64 : 70 E5                      	PUSH	R5
 3940/1B66 : 70 E4                      	PUSH	R4		; Save variable name
 3941/1B68 : 4C 00                      	LD	R4,#hi(6)
 3942/1B6A : 5C 06                      	LD	R5,#lo(6)	; 2 byte name plus 4 byte data
 3943/1B6C : 8C 81                      	LD	R8,#hi(ARREND)
 3944/1B6E : 9C 27                      	LD	R9,#lo(ARREND)
 3945/1B70 : C2 28                      	LDC	R2,@RR8
 3946/1B72 : A0 E8                      	INCW	RR8
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 67 - 2023/10/26 22時18分50秒


 3947/1B74 : C2 38                      	LDC	R3,@RR8		; End of arrays
 3948/1B76 : 70 E3                      	PUSH	R3
 3949/1B78 : 70 E2                      	PUSH	R2		; Save end of arrays
 3950/1B7A : 02 35                      	ADD	R3,R5
 3951/1B7C : 12 24                      	ADC	R2,R4		; Move up 6 bytes
 3952/1B7E : 50 E4                      	POP	R4
 3953/1B80 : 50 E5                      	POP	R5		; Source address in BC
 3954/1B82 : 70 E3                      	PUSH	R3
 3955/1B84 : 70 E2                      	PUSH	R2		; Save new end address
 3956/1B86 : D6 04 84                   	CALL	MOVUP		; Move arrays up
 3957/1B89 : 50 E2                      	POP	R2
 3958/1B8B : 50 E3                      	POP	R3		; Restore new end address
 3959/1B8D : 8C 81                      	LD	R8,#hi(ARREND)
 3960/1B8F : 9C 27                      	LD	R9,#lo(ARREND)
 3961/1B91 : D2 28                      	LDC	@RR8,R2
 3962/1B93 : A0 E8                      	INCW	RR8
 3963/1B95 : D2 38                      	LDC	@RR8,R3		; Set new end address
 3964/1B97 : 28 E4                      	LD	R2,R4		; End of variables to HL
 3965/1B99 : 38 E5                      	LD	R3,R5
 3966/1B9B : 8C 81                      	LD	R8,#hi(VAREND)
 3967/1B9D : 9C 25                      	LD	R9,#lo(VAREND)
 3968/1B9F : D2 28                      	LDC	@RR8,R2
 3969/1BA1 : A0 E8                      	INCW	RR8
 3970/1BA3 : D2 38                      	LDC	@RR8,R3		; Set new end address
 3971/1BA5 :                            ;
 3972/1BA5 :                            ZEROLP:
 3973/1BA5 : 80 E2                      	DECW	RR2		; Back through to zero variable
 3974/1BA7 : 1C 00                      	LD	R1,#0
 3975/1BA9 : D2 12                      	LDC	@RR2,R1		; Zero byte in variable
 3976/1BAB : D6 0A 3D                   	CALL	CPDEHL		; Done them all?
 3977/1BAE : ED 1B A5                   	JP	NZ,ZEROLP	; No - Keep on going
 3978/1BB1 : 50 E6                      	POP	R6
 3979/1BB3 : 50 E7                      	POP	R7		; Get variable name
 3980/1BB5 : D2 72                      	LDC	@RR2,R7		; Store second character
 3981/1BB7 :                            ;	LD	R1,FLAGS
 3982/1BB7 : A0 E2                      	INCW	RR2
 3983/1BB9 : D2 62                      	LDC	@RR2,R6		; Store first character
 3984/1BBB : A0 E2                      	INCW	RR2
 3985/1BBD :                            ;	LD	FLAGS,R1
 3986/1BBD :                            RETADR:
 3987/1BBD : 88 E6                      	LD	R8,R6
 3988/1BBF : 98 E7                      	LD	R9,R7
 3989/1BC1 : 68 E2                      	LD	R6,R2
 3990/1BC3 : 78 E3                      	LD	R7,R3
 3991/1BC5 : 28 E8                      	LD	R2,R8
 3992/1BC7 : 38 E9                      	LD	R3,R9		; Address of variable in DE
 3993/1BC9 : 50 E2                      	POP	R2
 3994/1BCB : 50 E3                      	POP	R3		; Restore code string address
 3995/1BCD : AF                         	RET
 3996/1BCE :                            ;
 3997/1BCE :                            RETNUL:
 3998/1BCE : 8C 81                      	LD	R8,#hi(FPEXP)
 3999/1BD0 : 9C 34                      	LD	R9,#lo(FPEXP)
 4000/1BD2 : D2 08                      	LDC	@RR8,R0		; Set result to zero
 4001/1BD4 : 2C 04                      	LD	R2,#hi(ZERBYT)
 4002/1BD6 : 3C 1B                      	LD	R3,#lo(ZERBYT)	; Also set a null string
 4003/1BD8 : 8C 81                      	LD	R8,#hi(FPREG)
 4004/1BDA : 9C 31                      	LD	R9,#lo(FPREG)
 4005/1BDC :                            
 4006/1BDC :                            ;	LDC	@RR8,R2
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 68 - 2023/10/26 22時18分50秒


 4007/1BDC :                            ;	LD	R1,FLAGS
 4008/1BDC :                            ;	INCW	RR8
 4009/1BDC :                            ;	LD	FLAGS,R1
 4010/1BDC :                            ;	LDC	@RR8,R3		; Save for EVAL
 4011/1BDC : D2 38                      	LDC	@RR8,R3		; @@@ SWAP HL
 4012/1BDE : 18 FC                      	LD	R1,FLAGS
 4013/1BE0 : A0 E8                      	INCW	RR8
 4014/1BE2 : 19 FC                      	LD	FLAGS,R1
 4015/1BE4 : D2 28                      	LDC	@RR8,R2		; Save for EVAL
 4016/1BE6 :                            
 4017/1BE6 : 50 E2                      	POP	R2
 4018/1BE8 : 50 E3                      	POP	R3		; Restore code string address
 4019/1BEA : AF                         	RET
 4020/1BEB :                            ;
 4021/1BEB :                            SBSCPT:
 4022/1BEB : 70 E3                      	PUSH	R3
 4023/1BED : 70 E2                      	PUSH	R2		; Save code string address
 4024/1BEF : 8C 80                      	LD	R8,#hi(LCRFLG)
 4025/1BF1 : 9C F9                      	LD	R9,#lo(LCRFLG)
 4026/1BF3 : C2 28                      	LDC	R2,@RR8
 4027/1BF5 : A0 E8                      	INCW	RR8
 4028/1BF7 : C2 38                      	LDC	R3,@RR8		; Locate/Create and Type
 4029/1BF9 : 50 E8                      	POP	R8
 4030/1BFB : 50 E9                      	POP	R9
 4031/1BFD : 70 E3                      	PUSH	R3
 4032/1BFF : 70 E2                      	PUSH	R2
 4033/1C01 : 28 E8                      	LD	R2,R8
 4034/1C03 : 38 E9                      	LD	R3,R9		; Save and get code string
 4035/1C05 : 68 E0                      	LD	R6,R0		; Zero number of dimensions
 4036/1C07 :                            SCPTLP:
 4037/1C07 :                            ;	PUSH	R7
 4038/1C07 : 70 E6                      	PUSH	R6		; Save number of dimensions
 4039/1C09 : 70 E5                      	PUSH	R5
 4040/1C0B : 70 E4                      	PUSH	R4		; Save array name
 4041/1C0D : D6 0F 4B                   	CALL	FPSINT		; Get subscript (0-32767)
 4042/1C10 : 50 E4                      	POP	R4
 4043/1C12 : 50 E5                      	POP	R5		; Restore array name
 4044/1C14 : 50 E0                      	POP	R0		; Get number of dimensions
 4045/1C16 :                            ;	POP	R1
 4046/1C16 :                            ;	LD	FLAGS,R1
 4047/1C16 : 88 E6                      	LD	R8,R6
 4048/1C18 : 98 E7                      	LD	R9,R7
 4049/1C1A : 68 E2                      	LD	R6,R2
 4050/1C1C : 78 E3                      	LD	R7,R3
 4051/1C1E : 28 E8                      	LD	R2,R8
 4052/1C20 : 38 E9                      	LD	R3,R9
 4053/1C22 : 50 E8                      	POP	R8
 4054/1C24 : 50 E9                      	POP	R9
 4055/1C26 : 70 E3                      	PUSH	R3
 4056/1C28 : 70 E2                      	PUSH	R2
 4057/1C2A : 28 E8                      	LD	R2,R8
 4058/1C2C : 38 E9                      	LD	R3,R9		; Save subscript value
 4059/1C2E : 70 E3                      	PUSH	R3
 4060/1C30 : 70 E2                      	PUSH	R2		; Save LCRFLG and TYPE
 4061/1C32 : 88 E6                      	LD	R8,R6
 4062/1C34 : 98 E7                      	LD	R9,R7
 4063/1C36 : 68 E2                      	LD	R6,R2
 4064/1C38 : 78 E3                      	LD	R7,R3
 4065/1C3A : 28 E8                      	LD	R2,R8
 4066/1C3C : 38 E9                      	LD	R3,R9
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 69 - 2023/10/26 22時18分50秒


 4067/1C3E : 0E                         	INC	R0		; Count dimensions
 4068/1C3F : 68 E0                      	LD	R6,R0		; Save in D
 4069/1C41 : C2 02                      	LDC	R0,@RR2		; Get next byte in code string
 4070/1C43 : A6 E0 2C                   	CP	R0,#','		; Comma (more to come)?
 4071/1C46 : 6D 1C 07                   	JP	Z,SCPTLP	; Yes - More subscripts
 4072/1C49 : D6 0A 49                   	CALL	CHKSYN		; Make sure ")" follows
 4073/1C4C : 29                         	DB	")"
 4074/1C4D : 8C 81                      	LD	R8,#hi(NXTOPR)
 4075/1C4F : 9C 1D                      	LD	R9,#lo(NXTOPR)
 4076/1C51 : D2 28                      	LDC	@RR8,R2
 4077/1C53 : A0 E8                      	INCW	RR8
 4078/1C55 : D2 38                      	LDC	@RR8,R3		; Save code string address
 4079/1C57 : 50 E2                      	POP	R2
 4080/1C59 : 50 E3                      	POP	R3		; Get LCRFLG and TYPE
 4081/1C5B : 8C 80                      	LD	R8,#hi(LCRFLG)
 4082/1C5D : 9C F9                      	LD	R9,#lo(LCRFLG)
 4083/1C5F : D2 28                      	LDC	@RR8,R2
 4084/1C61 : A0 E8                      	INCW	RR8
 4085/1C63 : D2 38                      	LDC	@RR8,R3		; Restore Locate/create & type
 4086/1C65 : 7C 00                      	LD	R7,#0		; Flag not CSAVE* or CLOAD*
 4087/1C67 : 70 E7                      	PUSH	R7
 4088/1C69 : 70 E6                      	PUSH	R6		; Save number of dimensions (D)
 4089/1C6B : 8B 0A                      	JR	ARLDSV1		; Skip "PUSH HL" and "PUSH AF'
 4090/1C6D :                            ;
 4091/1C6D :                            ARLDSV:
 4092/1C6D : 70 E3                      	PUSH	R3
 4093/1C6F : 70 E2                      	PUSH	R2		; Save code string address
 4094/1C71 : 18 FC                      	LD	R1,FLAGS
 4095/1C73 : 70 E1                      	PUSH	R1
 4096/1C75 : 70 E0                      	PUSH	R0		; A = 00 , Flags set = Z,N
 4097/1C77 :                            ARLDSV1:
 4098/1C77 : 8C 81                      	LD	R8,#hi(VAREND)
 4099/1C79 : 9C 25                      	LD	R9,#lo(VAREND)
 4100/1C7B : C2 28                      	LDC	R2,@RR8
 4101/1C7D : A0 E8                      	INCW	RR8
 4102/1C7F : C2 38                      	LDC	R3,@RR8		; Start of arrays
 4103/1C81 : 8B 04                      	JR	FNDARY1		; Skip "ADD HL,DE"
 4104/1C83 :                            FNDARY:
 4105/1C83 : 02 37                      	ADD	R3,R7
 4106/1C85 : 12 26                      	ADC	R2,R6		; Move to next array start
 4107/1C87 :                            FNDARY1:
 4108/1C87 : 88 E6                      	LD	R8,R6
 4109/1C89 : 98 E7                      	LD	R9,R7
 4110/1C8B : 68 E2                      	LD	R6,R2
 4111/1C8D : 78 E3                      	LD	R7,R3
 4112/1C8F : 28 E8                      	LD	R2,R8
 4113/1C91 : 38 E9                      	LD	R3,R9
 4114/1C93 : 8C 81                      	LD	R8,#hi(ARREND)
 4115/1C95 : 9C 27                      	LD	R9,#lo(ARREND)
 4116/1C97 : C2 28                      	LDC	R2,@RR8
 4117/1C99 : A0 E8                      	INCW	RR8
 4118/1C9B : C2 38                      	LDC	R3,@RR8		; End of arrays
 4119/1C9D : 88 E6                      	LD	R8,R6
 4120/1C9F : 98 E7                      	LD	R9,R7
 4121/1CA1 : 68 E2                      	LD	R6,R2
 4122/1CA3 : 78 E3                      	LD	R7,R3
 4123/1CA5 : 28 E8                      	LD	R2,R8
 4124/1CA7 : 38 E9                      	LD	R3,R9		; Current array pointer
 4125/1CA9 : D6 0A 3D                   	CALL	CPDEHL		; End of arrays found?
 4126/1CAC : 6D 1C F2                   	JP	Z,CREARY	; Yes - Create array
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 70 - 2023/10/26 22時18分50秒


 4127/1CAF : C2 02                      	LDC	R0,@RR2		; Get second byte of name
 4128/1CB1 : A0 E2                      	INCW	RR2		; Move on
 4129/1CB3 : A2 05                      	CP	R0,R5		; Compare with name given
 4130/1CB5 : ED 1C BC                   	JP	NZ,NXTARY	; Different - Find next array
 4131/1CB8 : C2 02                      	LDC	R0,@RR2		; Get first byte of name
 4132/1CBA : A2 04                      	CP	R0,R4		; Compare with name given
 4133/1CBC :                            NXTARY:
 4134/1CBC : 18 FC                      	LD	R1,FLAGS
 4135/1CBE : A0 E2                      	INCW	RR2		; Move on
 4136/1CC0 : C2 72                      	LDC	R7,@RR2		; Get LSB of next array address
 4137/1CC2 : A0 E2                      	INCW	RR2
 4138/1CC4 : C2 62                      	LDC	R6,@RR2		; Get MSB of next array address
 4139/1CC6 : A0 E2                      	INCW	RR2
 4140/1CC8 : 19 FC                      	LD	FLAGS,R1
 4141/1CCA : ED 1C 83                   	JP	NZ,FNDARY	; Not found - Keep looking
 4142/1CCD : 8C 80                      	LD	R8,#hi(LCRFLG)
 4143/1CCF : 9C F9                      	LD	R9,#lo(LCRFLG)
 4144/1CD1 : C2 08                      	LDC	R0,@RR8		; Found Locate or Create it?
 4145/1CD3 : 42 00                      	OR	R0,R0
 4146/1CD5 : CF                         	RCF
 4147/1CD6 : ED 05 0B                   	JP	NZ,DDERR	; Create - ?DD Error
 4148/1CD9 : 50 E0                      	POP	R0		; Locate - Get number of dim'ns
 4149/1CDB : 50 E1                      	POP	R1
 4150/1CDD : 19 FC                      	LD	FLAGS,R1
 4151/1CDF : 48 E2                      	LD	R4,R2		; BC Points to array dim'ns
 4152/1CE1 : 58 E3                      	LD	R5,R3
 4153/1CE3 : 6D 2A 1C                   	JP	Z,POPHRT	; Jump if array load/save
 4154/1CE6 : C2 82                      	LDC	R8,@RR2
 4155/1CE8 : 22 08                      	SUB	R0,R8		; Same number of dimensions?
 4156/1CEA : 6D 1D E6                   	JP	Z,FINDEL	; Yes - Find element
 4157/1CED :                            BSERR:
 4158/1CED : 7C 10                      	LD	R7,#BS		; ?BS Error
 4159/1CEF : 8D 05 19                   	JP	ERROR		; Output error
 4160/1CF2 :                            ;
 4161/1CF2 :                            CREARY:
 4162/1CF2 : 6C 00                      	LD	R6,#hi(4)
 4163/1CF4 : 7C 04                      	LD	R7,#lo(4)	; 4 Bytes per entry
 4164/1CF6 : 50 E0                      	POP	R0		; Array to save or 0 dim'ns?
 4165/1CF8 : 50 E1                      	POP	R1
 4166/1CFA : 19 FC                      	LD	FLAGS,R1
 4167/1CFC : 6D 0F 7B                   	JP	Z,FCERR		; Yes - ?FC Error
 4168/1CFF : D2 52                      	LDC	@RR2,R5		; Save second byte of name
 4169/1D01 : A0 E2                      	INCW	RR2
 4170/1D03 : D2 42                      	LDC	@RR2,R4		; Save first byte of name
 4171/1D05 : A0 E2                      	INCW	RR2
 4172/1D07 : 58 E0                      	LD	R5,R0		; Number of dimensions to C
 4173/1D09 : D6 04 AC                   	CALL	CHKSTK		; Check if enough memory
 4174/1D0C : A0 E2                      	INCW	RR2		; Point to number of dimensions
 4175/1D0E : A0 E2                      	INCW	RR2
 4176/1D10 : 8C 81                      	LD	R8,#hi(CUROPR)
 4177/1D12 : 9C 12                      	LD	R9,#lo(CUROPR)
 4178/1D14 : D2 28                      	LDC	@RR8,R2
 4179/1D16 : A0 E8                      	INCW	RR8
 4180/1D18 : D2 38                      	LDC	@RR8,R3		; Save address of pointer
 4181/1D1A : D2 52                      	LDC	@RR2,R5		; Set number of dimensions
 4182/1D1C : A0 E2                      	INCW	RR2
 4183/1D1E : 8C 80                      	LD	R8,#hi(LCRFLG)
 4184/1D20 : 9C F9                      	LD	R9,#lo(LCRFLG)
 4185/1D22 : C2 08                      	LDC	R0,@RR8		; Locate of Create?
 4186/1D24 : 10 E0                      	RLC	R0		; Carry set = Create
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 71 - 2023/10/26 22時18分50秒


 4187/1D26 : 08 E5                      	LD	R0,R5		; Get number of dimensions
 4188/1D28 :                            CRARLP:
 4189/1D28 : 4C 00                      	LD	R4,#hi(10+1)
 4190/1D2A : 5C 0B                      	LD	R5,#lo(10+1)	; Default dimension size 10
 4191/1D2C : FD 1D 35                   	JP	NC,DEFSIZ	; Locate - Set default size
 4192/1D2F : 50 E4                      	POP	R4
 4193/1D31 : 50 E5                      	POP	R5		; Get specified dimension size
 4194/1D33 : A0 E4                      	INCW	RR4		; Include zero element
 4195/1D35 :                            DEFSIZ:
 4196/1D35 : D2 52                      	LDC	@RR2,R5		; Save LSB of dimension size
 4197/1D37 : A0 E2                      	INCW	RR2
 4198/1D39 : D2 42                      	LDC	@RR2,R4		; Save MSB of dimension size
 4199/1D3B : A0 E2                      	INCW	RR2
 4200/1D3D : 18 FC                      	LD	R1,FLAGS
 4201/1D3F : 70 E1                      	PUSH	R1
 4202/1D41 : 70 E0                      	PUSH	R0		; Save num' of dim'ns an status
 4203/1D43 : 70 E3                      	PUSH	R3
 4204/1D45 : 70 E2                      	PUSH	R2		; Save address of dim'n size
 4205/1D47 : D6 2D 3D                   	CALL	MLDEBC		; Multiply DE by BC to find
 4206/1D4A : 88 E6                      	LD	R8,R6
 4207/1D4C : 98 E7                      	LD	R9,R7
 4208/1D4E : 68 E2                      	LD	R6,R2
 4209/1D50 : 78 E3                      	LD	R7,R3
 4210/1D52 : 28 E8                      	LD	R2,R8
 4211/1D54 : 38 E9                      	LD	R3,R9		; amount of mem needed (to DE)
 4212/1D56 : 50 E2                      	POP	R2
 4213/1D58 : 50 E3                      	POP	R3		; Restore address of dimension
 4214/1D5A : 50 E0                      	POP	R0		; Restore number of dimensions
 4215/1D5C : 50 E1                      	POP	R1
 4216/1D5E : 19 FC                      	LD	FLAGS,R1
 4217/1D60 : 00 E0                      	DEC	R0		; Count them
 4218/1D62 : ED 1D 28                   	JP	NZ,CRARLP	; Do next dimension if more
 4219/1D65 : 18 FC                      	LD	R1,FLAGS
 4220/1D67 : 70 E1                      	PUSH	R1
 4221/1D69 : 70 E0                      	PUSH	R0		; Save locate/create flag
 4222/1D6B : 48 E6                      	LD	R4,R6		; MSB of memory needed
 4223/1D6D : 58 E7                      	LD	R5,R7		; LSB of memory needed
 4224/1D6F : 88 E6                      	LD	R8,R6
 4225/1D71 : 98 E7                      	LD	R9,R7
 4226/1D73 : 68 E2                      	LD	R6,R2
 4227/1D75 : 78 E3                      	LD	R7,R3
 4228/1D77 : 28 E8                      	LD	R2,R8
 4229/1D79 : 38 E9                      	LD	R3,R9
 4230/1D7B : 02 37                      	ADD	R3,R7
 4231/1D7D : 12 26                      	ADC	R2,R6		; Add bytes to array start
 4232/1D7F : 7D 04 E6                   	JP	C,OMERR		; Too big - Error
 4233/1D82 : D6 04 C6                   	CALL	ENFMEM		; See if enough memory
 4234/1D85 : 8C 81                      	LD	R8,#hi(ARREND)
 4235/1D87 : 9C 27                      	LD	R9,#lo(ARREND)
 4236/1D89 : D2 28                      	LDC	@RR8,R2
 4237/1D8B : A0 E8                      	INCW	RR8
 4238/1D8D : D2 38                      	LDC	@RR8,R3		; Save new end of array
 4239/1D8F :                            ;
 4240/1D8F :                            ZERARY:
 4241/1D8F : 80 E2                      	DECW	RR2		; Back through array data
 4242/1D91 : 1C 00                      	LD	R1,#0
 4243/1D93 : D2 12                      	LDC	@RR2,R1		; Set array element to zero
 4244/1D95 : D6 0A 3D                   	CALL	CPDEHL		; All elements zeroed?
 4245/1D98 : ED 1D 8F                   	JP	NZ,ZERARY	; No - Keep on going
 4246/1D9B : A0 E4                      	INCW	RR4		; Number of bytes + 1
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 72 - 2023/10/26 22時18分50秒


 4247/1D9D : 68 E0                      	LD	R6,R0		; A=0
 4248/1D9F : 8C 81                      	LD	R8,#hi(CUROPR)
 4249/1DA1 : 9C 12                      	LD	R9,#lo(CUROPR)
 4250/1DA3 : C2 28                      	LDC	R2,@RR8
 4251/1DA5 : A0 E8                      	INCW	RR8
 4252/1DA7 : C2 38                      	LDC	R3,@RR8		; Get address of array
 4253/1DA9 : C2 72                      	LDC	R7,@RR2		; Number of dimensions
 4254/1DAB : 88 E6                      	LD	R8,R6
 4255/1DAD : 98 E7                      	LD	R9,R7
 4256/1DAF : 68 E2                      	LD	R6,R2
 4257/1DB1 : 78 E3                      	LD	R7,R3
 4258/1DB3 : 28 E8                      	LD	R2,R8
 4259/1DB5 : 38 E9                      	LD	R3,R9		; To HL
 4260/1DB7 : 02 33                      	ADD	R3,R3
 4261/1DB9 : 12 22                      	ADC	R2,R2		; Two bytes per dimension size
 4262/1DBB : 02 35                      	ADD	R3,R5
 4263/1DBD : 12 24                      	ADC	R2,R4		; Add number of bytes
 4264/1DBF : 88 E6                      	LD	R8,R6
 4265/1DC1 : 98 E7                      	LD	R9,R7
 4266/1DC3 : 68 E2                      	LD	R6,R2
 4267/1DC5 : 78 E3                      	LD	R7,R3
 4268/1DC7 : 28 E8                      	LD	R2,R8
 4269/1DC9 : 38 E9                      	LD	R3,R9		; Bytes needed to DE
 4270/1DCB : 18 FC                      	LD	R1,FLAGS
 4271/1DCD : 80 E2                      	DECW	RR2
 4272/1DCF : 80 E2                      	DECW	RR2
 4273/1DD1 : 19 FC                      	LD	FLAGS,R1
 4274/1DD3 : D2 72                      	LDC	@RR2,R7		; Save LSB of bytes needed
 4275/1DD5 : A0 E2                      	INCW	RR2
 4276/1DD7 : D2 62                      	LDC	@RR2,R6		; Save MSB of bytes needed
 4277/1DD9 : A0 E2                      	INCW	RR2
 4278/1DDB : 19 FC                      	LD	FLAGS,R1
 4279/1DDD : 50 E0                      	POP	R0
 4280/1DDF : 50 E1                      	POP	R1		; Locate / Create?
 4281/1DE1 : 19 FC                      	LD	FLAGS,R1
 4282/1DE3 : 7D 1E 46                   	JP	C,ENDDIM	; A is 0 , End if create
 4283/1DE6 :                            FINDEL:
 4284/1DE6 : 48 E0                      	LD	R4,R0		; Find array element
 4285/1DE8 : 58 E0                      	LD	R5,R0
 4286/1DEA : C2 02                      	LDC	R0,@RR2		; Number of dimensions
 4287/1DEC : A0 E2                      	INCW	RR2
 4288/1DEE : 8B 04                      	JR	FNDELP1		; Skip "POP HL"
 4289/1DF0 :                            FNDELP:
 4290/1DF0 : 50 E2                      	POP	R2
 4291/1DF2 : 50 E3                      	POP	R3		; Address of next dim' size
 4292/1DF4 :                            FNDELP1:
 4293/1DF4 : C2 72                      	LDC	R7,@RR2		; Get LSB of dim'n size
 4294/1DF6 : A0 E2                      	INCW	RR2
 4295/1DF8 : C2 62                      	LDC	R6,@RR2		; Get MSB of dim'n size
 4296/1DFA : A0 E2                      	INCW	RR2
 4297/1DFC : 50 E8                      	POP	R8
 4298/1DFE : 50 E9                      	POP	R9
 4299/1E00 : 70 E3                      	PUSH	R3
 4300/1E02 : 70 E2                      	PUSH	R2
 4301/1E04 : 28 E8                      	LD	R2,R8
 4302/1E06 : 38 E9                      	LD	R3,R9		; Save address - Get index
 4303/1E08 :                            ;	LD	R1,FLAGS
 4304/1E08 :                            ;	PUSH	R1
 4305/1E08 : 70 E0                      	PUSH	R0		; Save number of dim'ns
 4306/1E0A : D6 0A 3D                   	CALL	CPDEHL		; Dimension too large?
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 73 - 2023/10/26 22時18分50秒


 4307/1E0D : FD 1C ED                   	JP	NC,BSERR	; Yes - ?BS Error
 4308/1E10 : 70 E3                      	PUSH	R3
 4309/1E12 : 70 E2                      	PUSH	R2		; Save index
 4310/1E14 : D6 2D 3D                   	CALL	MLDEBC		; Multiply previous by size
 4311/1E17 : 50 E6                      	POP	R6
 4312/1E19 : 50 E7                      	POP	R7		; Index supplied to DE
 4313/1E1B : 02 37                      	ADD	R3,R7
 4314/1E1D : 12 26                      	ADC	R2,R6		; Add index to pointer
 4315/1E1F : 50 E0                      	POP	R0		; Number of dimensions
 4316/1E21 :                            ;	POP	R1
 4317/1E21 :                            ;	LD	FLAGS,R1
 4318/1E21 : 00 E0                      	DEC	R0		; Count them
 4319/1E23 : 48 E2                      	LD	R4,R2		; MSB of pointer
 4320/1E25 : 58 E3                      	LD	R5,R3		; LSB of pointer
 4321/1E27 : ED 1D F0                   	JP	NZ,FNDELP	; More - Keep going
 4322/1E2A : 02 33                      	ADD	R3,R3
 4323/1E2C : 12 22                      	ADC	R2,R2		; 4 Bytes per element
 4324/1E2E : 02 33                      	ADD	R3,R3
 4325/1E30 : 12 22                      	ADC	R2,R2
 4326/1E32 : 50 E4                      	POP	R4
 4327/1E34 : 50 E5                      	POP	R5		; Start of array
 4328/1E36 : 02 35                      	ADD	R3,R5
 4329/1E38 : 12 24                      	ADC	R2,R4		; Point to element
 4330/1E3A : 88 E6                      	LD	R8,R6
 4331/1E3C : 98 E7                      	LD	R9,R7
 4332/1E3E : 68 E2                      	LD	R6,R2
 4333/1E40 : 78 E3                      	LD	R7,R3
 4334/1E42 : 28 E8                      	LD	R2,R8
 4335/1E44 : 38 E9                      	LD	R3,R9		; Address of element to DE
 4336/1E46 :                            ENDDIM:
 4337/1E46 : 8C 81                      	LD	R8,#hi(NXTOPR)
 4338/1E48 : 9C 1D                      	LD	R9,#lo(NXTOPR)
 4339/1E4A : C2 28                      	LDC	R2,@RR8
 4340/1E4C : 18 FC                      	LD	R1,FLAGS
 4341/1E4E : A0 E8                      	INCW	RR8
 4342/1E50 : 19 FC                      	LD	FLAGS,R1
 4343/1E52 : C2 38                      	LDC	R3,@RR8		; Got code string address
 4344/1E54 : AF                         	RET
 4345/1E55 :                            ;
 4346/1E55 :                            FRE:
 4347/1E55 : 8C 81                      	LD	R8,#hi(ARREND)
 4348/1E57 : 9C 27                      	LD	R9,#lo(ARREND)
 4349/1E59 : C2 28                      	LDC	R2,@RR8
 4350/1E5B : A0 E8                      	INCW	RR8
 4351/1E5D : C2 38                      	LDC	R3,@RR8		; Start of free memory
 4352/1E5F : 88 E6                      	LD	R8,R6
 4353/1E61 : 98 E7                      	LD	R9,R7
 4354/1E63 : 68 E2                      	LD	R6,R2
 4355/1E65 : 78 E3                      	LD	R7,R3
 4356/1E67 : 28 E8                      	LD	R2,R8
 4357/1E69 : 38 E9                      	LD	R3,R9		; To DE
 4358/1E6B : 2C 00                      	LD	R2,#hi(0)
 4359/1E6D : 3C 00                      	LD	R3,#lo(0)	; End of free memory
 4360/1E6F : 04 FF E3                   	ADD	R3,SPL
 4361/1E72 : 14 FE E2                   	ADC	R2,SPH		; Current stack value
 4362/1E75 : 8C 80                      	LD	R8,#hi(TYPE)
 4363/1E77 : 9C FA                      	LD	R9,#lo(TYPE)
 4364/1E79 : C2 08                      	LDC	R0,@RR8		; Dummy argument type
 4365/1E7B : 42 00                      	OR	R0,R0
 4366/1E7D : CF                         	RCF
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 74 - 2023/10/26 22時18分50秒


 4367/1E7E : 6D 1E A7                   	JP	Z,FRENUM	; Numeric - Free variable space
 4368/1E81 : D6 24 68                   	CALL	GSTRCU		; Current string to pool
 4369/1E84 : D6 21 9F                   	CALL	GARBGE		; Garbage collection
 4370/1E87 : 8C 80                      	LD	R8,#hi(STRSPC)
 4371/1E89 : 9C A7                      	LD	R9,#lo(STRSPC)
 4372/1E8B : C2 28                      	LDC	R2,@RR8
 4373/1E8D : A0 E8                      	INCW	RR8
 4374/1E8F : C2 38                      	LDC	R3,@RR8		; Bottom of string space in use
 4375/1E91 : 88 E6                      	LD	R8,R6
 4376/1E93 : 98 E7                      	LD	R9,R7
 4377/1E95 : 68 E2                      	LD	R6,R2
 4378/1E97 : 78 E3                      	LD	R7,R3
 4379/1E99 : 28 E8                      	LD	R2,R8
 4380/1E9B : 38 E9                      	LD	R3,R9		; To DE
 4381/1E9D : 8C 81                      	LD	R8,#hi(STRBOT)
 4382/1E9F : 9C 10                      	LD	R9,#lo(STRBOT)
 4383/1EA1 : C2 28                      	LDC	R2,@RR8
 4384/1EA3 : A0 E8                      	INCW	RR8
 4385/1EA5 : C2 38                      	LDC	R3,@RR8		; Bottom of string space
 4386/1EA7 :                            FRENUM:
 4387/1EA7 : 08 E3                      	LD	R0,R3		; Get LSB of end
 4388/1EA9 : 22 07                      	SUB	R0,R7		; Subtract LSB of beginning
 4389/1EAB : 58 E0                      	LD	R5,R0		; Save difference if C
 4390/1EAD : 08 E2                      	LD	R0,R2		; Get MSB of end
 4391/1EAF : 32 06                      	SBC	R0,R6		; Subtract MSB of beginning
 4392/1EB1 :                            ACPASS:
 4393/1EB1 : 48 E5                      	LD	R4,R5		; Return integer AC
 4394/1EB3 :                            ABPASS:
 4395/1EB3 : 68 E4                      	LD	R6,R4		; Return integer AB
 4396/1EB5 : 7C 00                      	LD	R7,#0
 4397/1EB7 : 2C 80                      	LD	R2,#hi(TYPE)
 4398/1EB9 : 3C FA                      	LD	R3,#lo(TYPE)	; Point to type
 4399/1EBB : D2 72                      	LDC	@RR2,R7		; Set type to numeric
 4400/1EBD : 4C 90                      	LD	R4,#80H+16	; 16 bit integer
 4401/1EBF : 8D 2B A1                   	JP	RETINT		; Return the integr
 4402/1EC2 :                            ;
 4403/1EC2 :                            POS:
 4404/1EC2 : 8C 80                      	LD	R8,#hi(CURPOS)
 4405/1EC4 : 9C F8                      	LD	R9,#lo(CURPOS)
 4406/1EC6 : C2 08                      	LDC	R0,@RR8		; Get cursor position
 4407/1EC8 :                            PASSA:
 4408/1EC8 : 48 E0                      	LD	R4,R0		; Put A into AB
 4409/1ECA : B2 00                      	XOR	R0,R0
 4410/1ECC : CF                         	RCF			; Zero A
 4411/1ECD : 8D 1E B3                   	JP	ABPASS		; Return integer AB
 4412/1ED0 :                            ;
 4413/1ED0 :                            DEF:
 4414/1ED0 : D6 20 07                   	CALL	CHEKFN		; Get "FN" and name
 4415/1ED3 : D6 1F E7                   	CALL	IDTEST		; Test for illegal direct
 4416/1ED6 : 4C 11                      	LD	R4,#hi(DATA)
 4417/1ED8 : 5C 3E                      	LD	R5,#lo(DATA)	; To get next statement
 4418/1EDA : 70 E5                      	PUSH	R5
 4419/1EDC : 70 E4                      	PUSH	R4		; Save address for RETurn
 4420/1EDE : 70 E7                      	PUSH	R7
 4421/1EE0 : 70 E6                      	PUSH	R6		; Save address of function ptr
 4422/1EE2 : D6 0A 49                   	CALL	CHKSYN		; Make sure "(" follows
 4423/1EE5 : 28                         	DB	"("
 4424/1EE6 : D6 1A 60                   	CALL	GETVAR		; Get argument variable name
 4425/1EE9 : 70 E3                      	PUSH	R3
 4426/1EEB : 70 E2                      	PUSH	R2		; Save code string address
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 75 - 2023/10/26 22時18分50秒


 4427/1EED : 88 E6                      	LD	R8,R6
 4428/1EEF : 98 E7                      	LD	R9,R7
 4429/1EF1 : 68 E2                      	LD	R6,R2
 4430/1EF3 : 78 E3                      	LD	R7,R3
 4431/1EF5 : 28 E8                      	LD	R2,R8
 4432/1EF7 : 38 E9                      	LD	R3,R9		; Argument address to HL
 4433/1EF9 : 80 E2                      	DECW	RR2
 4434/1EFB : C2 62                      	LDC	R6,@RR2		; Get first byte of arg name
 4435/1EFD : 80 E2                      	DECW	RR2
 4436/1EFF : C2 72                      	LDC	R7,@RR2		; Get second byte of arg name
 4437/1F01 : 50 E2                      	POP	R2
 4438/1F03 : 50 E3                      	POP	R3		; Restore code string address
 4439/1F05 : D6 16 80                   	CALL	TSTNUM		; Make sure numeric argument
 4440/1F08 : D6 0A 49                   	CALL	CHKSYN		; Make sure ")" follows
 4441/1F0B : 29                         	DB	")"
 4442/1F0C : D6 0A 49                   	CALL	CHKSYN		; Make sure "=" follows
 4443/1F0F : B4                         	DB	ZEQUAL		; "=" token
 4444/1F10 : 48 E2                      	LD	R4,R2		; Code string address to BC
 4445/1F12 : 58 E3                      	LD	R5,R3
 4446/1F14 : 50 E8                      	POP	R8
 4447/1F16 : 50 E9                      	POP	R9
 4448/1F18 : 70 E3                      	PUSH	R3
 4449/1F1A : 70 E2                      	PUSH	R2
 4450/1F1C : 28 E8                      	LD	R2,R8
 4451/1F1E : 38 E9                      	LD	R3,R9		; Save code str , Get FN ptr
 4452/1F20 : D2 52                      	LDC	@RR2,R5		; Save LSB of FN code string
 4453/1F22 : 18 FC                      	LD	R1,FLAGS
 4454/1F24 : A0 E2                      	INCW	RR2
 4455/1F26 : 19 FC                      	LD	FLAGS,R1
 4456/1F28 : D2 42                      	LDC	@RR2,R4		; Save MSB of FN code string
 4457/1F2A : 8D 20 6A                   	JP	SVSTAD		; Save address and do function
 4458/1F2D :                            ;
 4459/1F2D :                            DOFN:
 4460/1F2D : D6 20 07                   	CALL	CHEKFN		; Make sure FN follows
 4461/1F30 : 70 E7                      	PUSH	R7
 4462/1F32 : 70 E6                      	PUSH	R6		; Save function pointer address
 4463/1F34 : D6 17 EE                   	CALL	EVLPAR		; Evaluate expression in "()"
 4464/1F37 : D6 16 80                   	CALL	TSTNUM		; Make sure numeric result
 4465/1F3A : 50 E8                      	POP	R8
 4466/1F3C : 50 E9                      	POP	R9
 4467/1F3E : 70 E3                      	PUSH	R3
 4468/1F40 : 70 E2                      	PUSH	R2
 4469/1F42 : 28 E8                      	LD	R2,R8
 4470/1F44 : 38 E9                      	LD	R3,R9		; Save code str , Get FN ptr
 4471/1F46 : C2 72                      	LDC	R7,@RR2		; Get LSB of FN code string
 4472/1F48 : A0 E2                      	INCW	RR2
 4473/1F4A : C2 62                      	LDC	R6,@RR2		; Get MSB of FN code string
 4474/1F4C : A0 E2                      	INCW	RR2
 4475/1F4E : 08 E6                      	LD	R0,R6		; And function DEFined?
 4476/1F50 : 42 07                      	OR	R0,R7
 4477/1F52 : CF                         	RCF
 4478/1F53 : 6D 05 0F                   	JP	Z,UFERR		; No - ?UF Error
 4479/1F56 : C2 02                      	LDC	R0,@RR2		; Get LSB of argument address
 4480/1F58 : A0 E2                      	INCW	RR2
 4481/1F5A : C2 22                      	LDC	R2,@RR2		; Get MSB of argument address
 4482/1F5C : 38 E0                      	LD	R3,R0		; HL = Arg variable address
 4483/1F5E : 70 E3                      	PUSH	R3
 4484/1F60 : 70 E2                      	PUSH	R2		; Save it
 4485/1F62 : 8C 81                      	LD	R8,#hi(FNRGNM)
 4486/1F64 : 9C 2B                      	LD	R9,#lo(FNRGNM)
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 76 - 2023/10/26 22時18分50秒


 4487/1F66 : C2 28                      	LDC	R2,@RR8
 4488/1F68 : A0 E8                      	INCW	RR8
 4489/1F6A : C2 38                      	LDC	R3,@RR8		; Get old argument name
 4490/1F6C : 50 E8                      	POP	R8
 4491/1F6E : 50 E9                      	POP	R9
 4492/1F70 : 70 E3                      	PUSH	R3
 4493/1F72 : 70 E2                      	PUSH	R2
 4494/1F74 : 28 E8                      	LD	R2,R8
 4495/1F76 : 38 E9                      	LD	R3,R9		; Save old , Get new
 4496/1F78 : 8C 81                      	LD	R8,#hi(FNRGNM)
 4497/1F7A : 9C 2B                      	LD	R9,#lo(FNRGNM)
 4498/1F7C : D2 28                      	LDC	@RR8,R2
 4499/1F7E : A0 E8                      	INCW	RR8
 4500/1F80 : D2 38                      	LDC	@RR8,R3		; Set new argument name
 4501/1F82 : 8C 81                      	LD	R8,#hi(FNARG+2)
 4502/1F84 : 9C 2F                      	LD	R9,#lo(FNARG+2)
 4503/1F86 : C2 28                      	LDC	R2,@RR8
 4504/1F88 : A0 E8                      	INCW	RR8
 4505/1F8A : C2 38                      	LDC	R3,@RR8		; Get LSB,NLSB of old arg value
 4506/1F8C : 70 E3                      	PUSH	R3
 4507/1F8E : 70 E2                      	PUSH	R2		; Save it
 4508/1F90 : 8C 81                      	LD	R8,#hi(FNARG)
 4509/1F92 : 9C 2D                      	LD	R9,#lo(FNARG)
 4510/1F94 : C2 28                      	LDC	R2,@RR8
 4511/1F96 : A0 E8                      	INCW	RR8
 4512/1F98 : C2 38                      	LDC	R3,@RR8		; Get MSB,EXP of old arg value
 4513/1F9A : 70 E3                      	PUSH	R3
 4514/1F9C : 70 E2                      	PUSH	R2		; Save it
 4515/1F9E : 2C 81                      	LD	R2,#hi(FNARG)
 4516/1FA0 : 3C 2D                      	LD	R3,#lo(FNARG)	; HL = Value of argument
 4517/1FA2 : 70 E7                      	PUSH	R7
 4518/1FA4 : 70 E6                      	PUSH	R6		; Save FN code string address
 4519/1FA6 : D6 2C 20                   	CALL	FPTHL		; Move FPREG to argument
 4520/1FA9 : 50 E2                      	POP	R2
 4521/1FAB : 50 E3                      	POP	R3		; Get FN code string address
 4522/1FAD : D6 16 7D                   	CALL	GETNUM		; Get value from function
 4523/1FB0 : 80 E2                      	DECW	RR2		; DEC 'cos GETCHR INCs
 4524/1FB2 : D6 0D AD                   	CALL	GETCHR		; Get next character
 4525/1FB5 : ED 04 FF                   	JP	NZ,SNERR	; Bad character in FN - Error
 4526/1FB8 : 50 E2                      	POP	R2
 4527/1FBA : 50 E3                      	POP	R3		; Get MSB,EXP of old arg
 4528/1FBC : 8C 81                      	LD	R8,#hi(FNARG)
 4529/1FBE : 9C 2D                      	LD	R9,#lo(FNARG)
 4530/1FC0 : D2 28                      	LDC	@RR8,R2
 4531/1FC2 :                            ;	LD	R1,FLAGS
 4532/1FC2 : A0 E8                      	INCW	RR8
 4533/1FC4 :                            ;	LD	FLAGS,R1
 4534/1FC4 : D2 38                      	LDC	@RR8,R3		; Restore it
 4535/1FC6 : 50 E2                      	POP	R2
 4536/1FC8 : 50 E3                      	POP	R3		; Get LSB,NLSB of old arg
 4537/1FCA : 8C 81                      	LD	R8,#hi(FNARG+2)
 4538/1FCC : 9C 2F                      	LD	R9,#lo(FNARG+2)
 4539/1FCE : D2 28                      	LDC	@RR8,R2
 4540/1FD0 :                            ;	LD	R1,FLAGS
 4541/1FD0 : A0 E8                      	INCW	RR8
 4542/1FD2 :                            ;	LD	FLAGS,R1
 4543/1FD2 : D2 38                      	LDC	@RR8,R3		; Restore it
 4544/1FD4 : 50 E2                      	POP	R2
 4545/1FD6 : 50 E3                      	POP	R3		; Get name of old arg
 4546/1FD8 : 8C 81                      	LD	R8,#hi(FNRGNM)
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 77 - 2023/10/26 22時18分50秒


 4547/1FDA : 9C 2B                      	LD	R9,#lo(FNRGNM)
 4548/1FDC : D2 28                      	LDC	@RR8,R2
 4549/1FDE :                            ;	LD	R1,FLAGS
 4550/1FDE : A0 E8                      	INCW	RR8
 4551/1FE0 :                            ;	LD	FLAGS,R1
 4552/1FE0 : D2 38                      	LDC	@RR8,R3		; Restore it
 4553/1FE2 : 50 E2                      	POP	R2
 4554/1FE4 : 50 E3                      	POP	R3		; Restore code string address
 4555/1FE6 : AF                         	RET
 4556/1FE7 :                            ;
 4557/1FE7 :                            IDTEST:
 4558/1FE7 : 70 E3                      	PUSH	R3
 4559/1FE9 : 70 E2                      	PUSH	R2		; Save code string address
 4560/1FEB : 8C 80                      	LD	R8,#hi(LINEAT)
 4561/1FED : 9C A9                      	LD	R9,#lo(LINEAT)
 4562/1FEF : C2 28                      	LDC	R2,@RR8
 4563/1FF1 : A0 E8                      	INCW	RR8
 4564/1FF3 : C2 38                      	LDC	R3,@RR8		; Get current line number
 4565/1FF5 : A0 E2                      	INCW	RR2		; -1 means direct statement
 4566/1FF7 : 08 E2                      	LD	R0,R2
 4567/1FF9 : 42 03                      	OR	R0,R3
 4568/1FFB : 50 E2                      	POP	R2
 4569/1FFD : 50 E3                      	POP	R3		; Restore code string address
 4570/1FFF : 6B 01                      	JR	Z,$+3
 4571/2001 : AF                         	RET			; Return if in program
 4572/2002 : 7C 16                      	LD	R7,#ID		; ?ID Error
 4573/2004 : 8D 05 19                   	JP	ERROR
 4574/2007 :                            ;
 4575/2007 :                            CHEKFN:
 4576/2007 : D6 0A 49                   	CALL	CHKSYN		; Make sure FN follows
 4577/200A : A7                         	DB	ZFN		; "FN" token
 4578/200B : 0C 80                      	LD	R0,#80H
 4579/200D : 8C 81                      	LD	R8,#hi(FORFLG)
 4580/200F : 9C 18                      	LD	R9,#lo(FORFLG)
 4581/2011 : D2 08                      	LDC	@RR8,R0		; Flag FN name to find
 4582/2013 : C2 12                      	LDC	R1,@RR2
 4583/2015 : 42 01                      	OR	R0,R1		; FN name has bit 7 set
 4584/2017 : 48 E0                      	LD	R4,R0		; in first byte of name
 4585/2019 : D6 1A 6B                   	CALL	GTFNAM		; Get FN name
 4586/201C : 8D 16 80                   	JP	TSTNUM		; Make sure numeric function
 4587/201F :                            ;
 4588/201F :                            STR:
 4589/201F : D6 16 80                   	CALL	TSTNUM		; Make sure it's a number
 4590/2022 : D6 2E A8                   	CALL	NUMASC		; Turn number into text
 4591/2025 :                            STR1:
 4592/2025 : D6 20 77                   	CALL	CRTST		; Create string entry for it
 4593/2028 : D6 24 68                   	CALL	GSTRCU		; Current string to pool
 4594/202B : 4C 25                      	LD	R4,#hi(TOPOOL)
 4595/202D : 5C 43                      	LD	R5,#lo(TOPOOL)	; Save in string pool
 4596/202F : 70 E5                      	PUSH	R5
 4597/2031 : 70 E4                      	PUSH	R4		; Save address on stack
 4598/2033 :                            ;
 4599/2033 :                            SAVSTR:
 4600/2033 : C2 02                      	LDC	R0,@RR2		; Get string length
 4601/2035 : A0 E2                      	INCW	RR2
 4602/2037 : A0 E2                      	INCW	RR2
 4603/2039 : 70 E3                      	PUSH	R3
 4604/203B : 70 E2                      	PUSH	R2		; Save pointer to string
 4605/203D : D6 21 23                   	CALL	TESTR		; See if enough string space
 4606/2040 : 50 E2                      	POP	R2
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 78 - 2023/10/26 22時18分50秒


 4607/2042 : 50 E3                      	POP	R3		; Restore pointer to string
 4608/2044 : C2 52                      	LDC	R5,@RR2		; Get LSB of address
 4609/2046 : A0 E2                      	INCW	RR2
 4610/2048 : C2 42                      	LDC	R4,@RR2		; Get MSB of address
 4611/204A : D6 20 5E                   	CALL	CRTMST		; Create string entry
 4612/204D : 70 E3                      	PUSH	R3
 4613/204F : 70 E2                      	PUSH	R2		; Save pointer to MSB of addr
 4614/2051 : 38 E0                      	LD	R3,R0		; Length of string
 4615/2053 : D6 24 54                   	CALL	TOSTRA		; Move to string area
 4616/2056 : 50 E6                      	POP	R6
 4617/2058 : 50 E7                      	POP	R7		; Restore pointer to MSB
 4618/205A : AF                         	RET
 4619/205B :                            ;
 4620/205B :                            MKTMST:
 4621/205B : D6 21 23                   	CALL	TESTR		; See if enough string space
 4622/205E :                            CRTMST:
 4623/205E : 2C 81                      	LD	R2,#hi(TMPSTR)
 4624/2060 : 3C 0C                      	LD	R3,#lo(TMPSTR)	; Temporary string
 4625/2062 : 70 E3                      	PUSH	R3
 4626/2064 : 70 E2                      	PUSH	R2		; Save it
 4627/2066 : D2 02                      	LDC	@RR2,R0		; Save length of string
 4628/2068 : A0 E2                      	INCW	RR2
 4629/206A :                            SVSTAD:
 4630/206A : A0 E2                      	INCW	RR2
 4631/206C : D2 72                      	LDC	@RR2,R7		; Save LSB of address
 4632/206E : A0 E2                      	INCW	RR2
 4633/2070 : D2 62                      	LDC	@RR2,R6		; Save MSB of address
 4634/2072 : 50 E2                      	POP	R2
 4635/2074 : 50 E3                      	POP	R3		; Restore pointer
 4636/2076 : AF                         	RET
 4637/2077 :                            ;
 4638/2077 :                            CRTST:
 4639/2077 : 80 E2                      	DECW	RR2		; DEC - INCed after
 4640/2079 :                            QTSTR:
 4641/2079 : 4C 22                      	LD	R4,#'"'		; Terminating quote
 4642/207B : 68 E4                      	LD	R6,R4		; Quote to D
 4643/207D :                            DTSTR:
 4644/207D : 70 E3                      	PUSH	R3
 4645/207F : 70 E2                      	PUSH	R2		; Save start
 4646/2081 : 5C FF                      	LD	R5,#-1		; Set counter to -1
 4647/2083 :                            QTSTLP:
 4648/2083 : A0 E2                      	INCW	RR2		; Move on
 4649/2085 : C2 02                      	LDC	R0,@RR2		; Get byte
 4650/2087 : 5E                         	INC	R5		; Count bytes
 4651/2088 : 42 00                      	OR	R0,R0		; End of line?
 4652/208A : 6D 20 97                   	JP	Z,CRTSTE	; Yes - Create string entry
 4653/208D : A2 06                      	CP	R0,R6		; Terminator D found?
 4654/208F : 6D 20 97                   	JP	Z,CRTSTE	; Yes - Create string entry
 4655/2092 : A2 04                      	CP	R0,R4		; Terminator B found?
 4656/2094 : ED 20 83                   	JP	NZ,QTSTLP	; No - Keep looking
 4657/2097 :                            CRTSTE:
 4658/2097 : A6 E0 22                   	CP	R0,#'"'		; End with '"'?
 4659/209A : EB 03                      	JR	NZ,$+5
 4660/209C : D6 0D AD                   	CALL	GETCHR		; Yes - Get next character
 4661/209F : 50 E8                      	POP	R8
 4662/20A1 : 50 E9                      	POP	R9
 4663/20A3 : 70 E3                      	PUSH	R3
 4664/20A5 : 70 E2                      	PUSH	R2
 4665/20A7 : 28 E8                      	LD	R2,R8
 4666/20A9 : 38 E9                      	LD	R3,R9		; Starting quote
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 79 - 2023/10/26 22時18分50秒


 4667/20AB : A0 E2                      	INCW	RR2		; First byte of string
 4668/20AD : 88 E6                      	LD	R8,R6
 4669/20AF : 98 E7                      	LD	R9,R7
 4670/20B1 : 68 E2                      	LD	R6,R2
 4671/20B3 : 78 E3                      	LD	R7,R3
 4672/20B5 : 28 E8                      	LD	R2,R8
 4673/20B7 : 38 E9                      	LD	R3,R9		; To DE
 4674/20B9 : 08 E5                      	LD	R0,R5		; Get length
 4675/20BB : D6 20 5E                   	CALL	CRTMST		; Create string entry
 4676/20BE :                            TSTOPL:
 4677/20BE : 6C 81                      	LD	R6,#hi(TMPSTR)
 4678/20C0 : 7C 0C                      	LD	R7,#lo(TMPSTR)	; Temporary string
 4679/20C2 : 8C 80                      	LD	R8,#hi(TMSTPT)
 4680/20C4 : 9C FE                      	LD	R9,#lo(TMSTPT)
 4681/20C6 : C2 28                      	LDC	R2,@RR8
 4682/20C8 : A0 E8                      	INCW	RR8
 4683/20CA : C2 38                      	LDC	R3,@RR8		; Temporary string pool pointer
 4684/20CC : 8C 81                      	LD	R8,#hi(FPREG)
 4685/20CE : 9C 31                      	LD	R9,#lo(FPREG)
 4686/20D0 :                            
 4687/20D0 :                            ;	LDC	@RR8,R2
 4688/20D0 :                            ;	LD	R1,FLAGS
 4689/20D0 :                            ;	INCW	RR8
 4690/20D0 :                            ;	LD	FLAGS,R1
 4691/20D0 :                            ;	LDC	@RR8,R3		; Save address of string ptr
 4692/20D0 : D2 38                      	LDC	@RR8,R3		; @@@ SWAP HL
 4693/20D2 : A0 E8                      	INCW	RR8
 4694/20D4 : D2 28                      	LDC	@RR8,R2		; Save address of string ptr
 4695/20D6 :                            
 4696/20D6 : 0C 01                      	LD	R0,#1
 4697/20D8 : 8C 80                      	LD	R8,#hi(TYPE)
 4698/20DA : 9C FA                      	LD	R9,#lo(TYPE)
 4699/20DC : D2 08                      	LDC	@RR8,R0		; Set type to string
 4700/20DE : D6 2C 24                   	CALL	DETHL4		; Move string to pool
 4701/20E1 : D6 0A 3D                   	CALL	CPDEHL		; Out of string pool?
 4702/20E4 : 8C 80                      	LD	R8,#hi(TMSTPT)
 4703/20E6 : 9C FE                      	LD	R9,#lo(TMSTPT)
 4704/20E8 : D2 28                      	LDC	@RR8,R2
 4705/20EA : 18 FC                      	LD	R1,FLAGS
 4706/20EC : A0 E8                      	INCW	RR8
 4707/20EE : 19 FC                      	LD	FLAGS,R1
 4708/20F0 : D2 38                      	LDC	@RR8,R3		; Save new pointer
 4709/20F2 : 50 E2                      	POP	R2
 4710/20F4 : 50 E3                      	POP	R3		; Restore code string address
 4711/20F6 : C2 02                      	LDC	R0,@RR2		; Get next code byte
 4712/20F8 : 6B 01                      	JR	Z,$+3
 4713/20FA : AF                         	RET			; Return if pool OK
 4714/20FB : 7C 1E                      	LD	R7,#ST		; ?ST Error
 4715/20FD : 8D 05 19                   	JP	ERROR		; String pool overflow
 4716/2100 :                            ;
 4717/2100 :                            PRNUMS:
 4718/2100 : A0 E2                      	INCW	RR2		; Skip leading space
 4719/2102 :                            PRS:
 4720/2102 : D6 20 77                   	CALL	CRTST		; Create string entry for it
 4721/2105 :                            PRS1:
 4722/2105 : D6 24 68                   	CALL	GSTRCU		; Current string to pool
 4723/2108 : D6 2C 07                   	CALL	LOADFP		; Move string block to BCDE
 4724/210B : 7E                         	INC	R7		; Length + 1
 4725/210C :                            PRSLP:
 4726/210C : 00 E7                      	DEC	R7		; Count characters
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 80 - 2023/10/26 22時18分50秒


 4727/210E : EB 01                      	JR	NZ,$+3
 4728/2110 : AF                         	RET			; End of string
 4729/2111 : C2 04                      	LDC	R0,@RR4		; Get byte to output
 4730/2113 : D6 0A 6F                   	CALL	OUTC		; Output character in A
 4731/2116 : A6 E0 0D                   	CP	R0,#CR		; Return?
 4732/2119 : EB 03                      	JR	NZ,$+5
 4733/211B : D6 13 25                   	CALL	DONULL		; Yes - Do nulls
 4734/211E : A0 E4                      	INCW	RR4		; Next byte in string
 4735/2120 : 8D 21 0C                   	JP	PRSLP		; More characters to output
 4736/2123 :                            ;
 4737/2123 :                            TESTR:
 4738/2123 : 42 00                      	OR	R0,R0; Test if enough room
 4739/2125 : 8B 06                      	JR	GRBDON1		; No garbage collection done
 4740/2127 :                            GRBDON:
 4741/2127 : 50 E0                      	POP	R0
 4742/2129 : 50 E1                      	POP	R1
 4743/212B : 19 FC                      	LD	FLAGS,R1	; Garbage collection done
 4744/212D :                            GRBDON1:
 4745/212D : 18 FC                      	LD	R1,FLAGS
 4746/212F : 70 E1                      	PUSH	R1
 4747/2131 : 70 E0                      	PUSH	R0		; Save status
 4748/2133 : 8C 80                      	LD	R8,#hi(STRSPC)
 4749/2135 : 9C A7                      	LD	R9,#lo(STRSPC)
 4750/2137 : C2 28                      	LDC	R2,@RR8
 4751/2139 : A0 E8                      	INCW	RR8
 4752/213B : C2 38                      	LDC	R3,@RR8		; Bottom of string space in use
 4753/213D : 88 E6                      	LD	R8,R6
 4754/213F : 98 E7                      	LD	R9,R7
 4755/2141 : 68 E2                      	LD	R6,R2
 4756/2143 : 78 E3                      	LD	R7,R3
 4757/2145 : 28 E8                      	LD	R2,R8
 4758/2147 : 38 E9                      	LD	R3,R9		; To DE
 4759/2149 : 8C 81                      	LD	R8,#hi(STRBOT)
 4760/214B : 9C 10                      	LD	R9,#lo(STRBOT)
 4761/214D : C2 28                      	LDC	R2,@RR8
 4762/214F : A0 E8                      	INCW	RR8
 4763/2151 : C2 38                      	LDC	R3,@RR8		; Bottom of string area
 4764/2153 : 60 E0                      	COM	R0		; Negate length (Top down)
 4765/2155 : 58 E0                      	LD	R5,R0		; -Length to BC
 4766/2157 : 4C FF                      	LD	R4,#-1		; BC = -ve length of string
 4767/2159 : 02 35                      	ADD	R3,R5
 4768/215B : 12 24                      	ADC	R2,R4		; Add to bottom of space in use
 4769/215D : A0 E2                      	INCW	RR2		; Plus one for 2's complement
 4770/215F : D6 0A 3D                   	CALL	CPDEHL		; Below string RAM area?
 4771/2162 : 7D 21 84                   	JP	C,TESTOS	; Tidy up if not done else err
 4772/2165 : 8C 81                      	LD	R8,#hi(STRBOT)
 4773/2167 : 9C 10                      	LD	R9,#lo(STRBOT)
 4774/2169 : D2 28                      	LDC	@RR8,R2
 4775/216B :                            ;	LD	R1,FLAGS
 4776/216B : A0 E8                      	INCW	RR8
 4777/216D :                            ;	LD	FLAGS,R1
 4778/216D : D2 38                      	LDC	@RR8,R3		; Save new bottom of area
 4779/216F :                            ;	LD	R1,FLAGS
 4780/216F : A0 E2                      	INCW	RR2		; Point to first byte of string
 4781/2171 :                            ;	LD	FLAGS,R1
 4782/2171 : 88 E6                      	LD	R8,R6
 4783/2173 : 98 E7                      	LD	R9,R7
 4784/2175 : 68 E2                      	LD	R6,R2
 4785/2177 : 78 E3                      	LD	R7,R3
 4786/2179 : 28 E8                      	LD	R2,R8
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 81 - 2023/10/26 22時18分50秒


 4787/217B : 38 E9                      	LD	R3,R9		; Address to DE
 4788/217D :                            POPAF:
 4789/217D : 50 E0                      	POP	R0		; Throw away status push
 4790/217F : 50 E1                      	POP	R1
 4791/2181 : 19 FC                      	LD	FLAGS,R1
 4792/2183 : AF                         	RET
 4793/2184 :                            ;
 4794/2184 :                            TESTOS:
 4795/2184 : 50 E0                      	POP	R0
 4796/2186 : 50 E1                      	POP	R1		; Garbage collect been done?
 4797/2188 : 19 FC                      	LD	FLAGS,R1
 4798/218A : 7C 1A                      	LD	R7,#OS		; ?OS Error
 4799/218C : 6D 05 19                   	JP	Z,ERROR		; Yes - Not enough string apace
 4800/218F : A2 00                      	CP	R0,R0		; Flag garbage collect done
 4801/2191 : 18 FC                      	LD	R1,FLAGS
 4802/2193 : 70 E1                      	PUSH	R1
 4803/2195 : 70 E0                      	PUSH	R0		; Save status
 4804/2197 : 4C 21                      	LD	R4,#hi(GRBDON)
 4805/2199 : 5C 27                      	LD	R5,#lo(GRBDON)	; Garbage collection done
 4806/219B : 70 E5                      	PUSH	R5
 4807/219D : 70 E4                      	PUSH	R4		; Save for RETurn
 4808/219F :                            GARBGE:
 4809/219F : 8C 80                      	LD	R8,#hi(LSTRAM)
 4810/21A1 : 9C FC                      	LD	R9,#lo(LSTRAM)
 4811/21A3 : C2 28                      	LDC	R2,@RR8
 4812/21A5 : A0 E8                      	INCW	RR8
 4813/21A7 : C2 38                      	LDC	R3,@RR8		; Get end of RAM pointer
 4814/21A9 :                            GARBLP:
 4815/21A9 : 8C 81                      	LD	R8,#hi(STRBOT)
 4816/21AB : 9C 10                      	LD	R9,#lo(STRBOT)
 4817/21AD : D2 28                      	LDC	@RR8,R2
 4818/21AF : A0 E8                      	INCW	RR8
 4819/21B1 : D2 38                      	LDC	@RR8,R3		; Reset string pointer
 4820/21B3 : 2C 00                      	LD	R2,#hi(0)
 4821/21B5 : 3C 00                      	LD	R3,#lo(0)
 4822/21B7 : 70 E3                      	PUSH	R3
 4823/21B9 : 70 E2                      	PUSH	R2		; Flag no string found
 4824/21BB : 8C 80                      	LD	R8,#hi(STRSPC)
 4825/21BD : 9C A7                      	LD	R9,#lo(STRSPC)
 4826/21BF : C2 28                      	LDC	R2,@RR8
 4827/21C1 : A0 E8                      	INCW	RR8
 4828/21C3 : C2 38                      	LDC	R3,@RR8		; Get bottom of string space
 4829/21C5 : 70 E3                      	PUSH	R3
 4830/21C7 : 70 E2                      	PUSH	R2		; Save bottom of string space
 4831/21C9 : 8C 81                      	LD	R8,#hi(TMSTPL)
 4832/21CB : 9C 00                      	LD	R9,#lo(TMSTPL)
 4833/21CD : C2 28                      	LDC	R2,@RR8
 4834/21CF : A0 E8                      	INCW	RR8
 4835/21D1 : C2 38                      	LDC	R3,@RR8		; Temporary string pool
 4836/21D3 :                            GRBLP:
 4837/21D3 : 88 E6                      	LD	R8,R6
 4838/21D5 : 98 E7                      	LD	R9,R7
 4839/21D7 : 68 E2                      	LD	R6,R2
 4840/21D9 : 78 E3                      	LD	R7,R3
 4841/21DB : 28 E8                      	LD	R2,R8
 4842/21DD : 38 E9                      	LD	R3,R9
 4843/21DF : 8C 80                      	LD	R8,#hi(TMSTPT)
 4844/21E1 : 9C FE                      	LD	R9,#lo(TMSTPT)
 4845/21E3 : C2 28                      	LDC	R2,@RR8
 4846/21E5 : A0 E8                      	INCW	RR8
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 82 - 2023/10/26 22時18分50秒


 4847/21E7 : C2 38                      	LDC	R3,@RR8		; Temporary string pool pointer
 4848/21E9 : 88 E6                      	LD	R8,R6
 4849/21EB : 98 E7                      	LD	R9,R7
 4850/21ED : 68 E2                      	LD	R6,R2
 4851/21EF : 78 E3                      	LD	R7,R3
 4852/21F1 : 28 E8                      	LD	R2,R8
 4853/21F3 : 38 E9                      	LD	R3,R9
 4854/21F5 : D6 0A 3D                   	CALL	CPDEHL		; Temporary string pool done?
 4855/21F8 : 4C 21                      	LD	R4,#hi(GRBLP)
 4856/21FA : 5C D3                      	LD	R5,#lo(GRBLP)	; Loop until string pool done
 4857/21FC : ED 22 C7                   	JP	NZ,STPOOL	; No - See if in string area
 4858/21FF : 8C 81                      	LD	R8,#hi(PROGND)
 4859/2201 : 9C 23                      	LD	R9,#lo(PROGND)
 4860/2203 : C2 28                      	LDC	R2,@RR8
 4861/2205 : A0 E8                      	INCW	RR8
 4862/2207 : C2 38                      	LDC	R3,@RR8		; Start of simple variables
 4863/2209 :                            SMPVAR:
 4864/2209 : 88 E6                      	LD	R8,R6
 4865/220B : 98 E7                      	LD	R9,R7
 4866/220D : 68 E2                      	LD	R6,R2
 4867/220F : 78 E3                      	LD	R7,R3
 4868/2211 : 28 E8                      	LD	R2,R8
 4869/2213 : 38 E9                      	LD	R3,R9
 4870/2215 : 8C 81                      	LD	R8,#hi(VAREND)
 4871/2217 : 9C 25                      	LD	R9,#lo(VAREND)
 4872/2219 : C2 28                      	LDC	R2,@RR8
 4873/221B : A0 E8                      	INCW	RR8
 4874/221D : C2 38                      	LDC	R3,@RR8		; End of simple variables
 4875/221F : 88 E6                      	LD	R8,R6
 4876/2221 : 98 E7                      	LD	R9,R7
 4877/2223 : 68 E2                      	LD	R6,R2
 4878/2225 : 78 E3                      	LD	R7,R3
 4879/2227 : 28 E8                      	LD	R2,R8
 4880/2229 : 38 E9                      	LD	R3,R9
 4881/222B : D6 0A 3D                   	CALL	CPDEHL		; All simple strings done?
 4882/222E : 6D 22 44                   	JP	Z,ARRLP		; Yes - Do string arrays
 4883/2231 : C2 02                      	LDC	R0,@RR2		; Get type of variable
 4884/2233 : A0 E2                      	INCW	RR2
 4885/2235 : A0 E2                      	INCW	RR2
 4886/2237 : 42 00                      	OR	R0,R0		; "S" flag set if string
 4887/2239 : CF                         	RCF
 4888/223A : D6 22 CE                   	CALL	STRADD		; See if string in string area
 4889/223D : 8D 22 09                   	JP	SMPVAR		; Loop until simple ones done
 4890/2240 :                            ;
 4891/2240 :                            GNXARY:
 4892/2240 : 50 E4                      	POP	R4
 4893/2242 : 50 E5                      	POP	R5		; Scrap address of this array
 4894/2244 :                            ARRLP:
 4895/2244 : 88 E6                      	LD	R8,R6
 4896/2246 : 98 E7                      	LD	R9,R7
 4897/2248 : 68 E2                      	LD	R6,R2
 4898/224A : 78 E3                      	LD	R7,R3
 4899/224C : 28 E8                      	LD	R2,R8
 4900/224E : 38 E9                      	LD	R3,R9
 4901/2250 : 8C 81                      	LD	R8,#hi(ARREND)
 4902/2252 : 9C 27                      	LD	R9,#lo(ARREND)
 4903/2254 : C2 28                      	LDC	R2,@RR8
 4904/2256 : A0 E8                      	INCW	RR8
 4905/2258 : C2 38                      	LDC	R3,@RR8		; End of string arrays
 4906/225A : 88 E6                      	LD	R8,R6
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 83 - 2023/10/26 22時18分50秒


 4907/225C : 98 E7                      	LD	R9,R7
 4908/225E : 68 E2                      	LD	R6,R2
 4909/2260 : 78 E3                      	LD	R7,R3
 4910/2262 : 28 E8                      	LD	R2,R8
 4911/2264 : 38 E9                      	LD	R3,R9
 4912/2266 : D6 0A 3D                   	CALL	CPDEHL		; All string arrays done?
 4913/2269 : 6D 23 47                   	JP	Z,SCNEND	; Yes - Move string if found
 4914/226C : D6 2C 07                   	CALL	LOADFP		; Get array name to BCDE
 4915/226F : 08 E7                      	LD	R0,R7		; Get type of array
 4916/2271 : 70 E3                      	PUSH	R3
 4917/2273 : 70 E2                      	PUSH	R2		; Save address of num of dim'ns
 4918/2275 : 02 35                      	ADD	R3,R5
 4919/2277 : 12 24                      	ADC	R2,R4		; Start of next array
 4920/2279 : 42 00                      	OR	R0,R0
 4921/227B : CF                         	RCF			; Test type of array
 4922/227C : DD 22 40                   	JP	PL,GNXARY	; Numeric array - Ignore it
 4923/227F : 8C 81                      	LD	R8,#hi(CUROPR)
 4924/2281 : 9C 12                      	LD	R9,#lo(CUROPR)
 4925/2283 : D2 28                      	LDC	@RR8,R2
 4926/2285 : A0 E8                      	INCW	RR8
 4927/2287 : D2 38                      	LDC	@RR8,R3		; Save address of next array
 4928/2289 : 50 E2                      	POP	R2
 4929/228B : 50 E3                      	POP	R3		; Get address of num of dim'ns
 4930/228D : C2 52                      	LDC	R5,@RR2		; BC = Number of dimensions
 4931/228F : 4C 00                      	LD	R4,#0
 4932/2291 : 02 35                      	ADD	R3,R5
 4933/2293 : 12 24                      	ADC	R2,R4		; Two bytes per dimension size
 4934/2295 : 02 35                      	ADD	R3,R5
 4935/2297 : 12 24                      	ADC	R2,R4
 4936/2299 : A0 E2                      	INCW	RR2		; Plus one for number of dim'ns
 4937/229B :                            GRBARY:
 4938/229B : 88 E6                      	LD	R8,R6
 4939/229D : 98 E7                      	LD	R9,R7
 4940/229F : 68 E2                      	LD	R6,R2
 4941/22A1 : 78 E3                      	LD	R7,R3
 4942/22A3 : 28 E8                      	LD	R2,R8
 4943/22A5 : 38 E9                      	LD	R3,R9
 4944/22A7 : 8C 81                      	LD	R8,#hi(CUROPR)
 4945/22A9 : 9C 12                      	LD	R9,#lo(CUROPR)
 4946/22AB : C2 28                      	LDC	R2,@RR8
 4947/22AD : A0 E8                      	INCW	RR8
 4948/22AF : C2 38                      	LDC	R3,@RR8		; Get address of next array
 4949/22B1 : 88 E6                      	LD	R8,R6
 4950/22B3 : 98 E7                      	LD	R9,R7
 4951/22B5 : 68 E2                      	LD	R6,R2
 4952/22B7 : 78 E3                      	LD	R7,R3
 4953/22B9 : 28 E8                      	LD	R2,R8
 4954/22BB : 38 E9                      	LD	R3,R9
 4955/22BD : D6 0A 3D                   	CALL	CPDEHL		; Is this array finished?
 4956/22C0 : 6D 22 44                   	JP	Z,ARRLP		; Yes - Get next one
 4957/22C3 : 4C 22                      	LD	R4,#hi(GRBARY)
 4958/22C5 : 5C 9B                      	LD	R5,#lo(GRBARY)	; Loop until array all done
 4959/22C7 :                            STPOOL:
 4960/22C7 : 70 E5                      	PUSH	R5
 4961/22C9 : 70 E4                      	PUSH	R4		; Save return address
 4962/22CB : 46 E0 80                   	OR	R0,#80H
 4963/22CE :                            STRADD:
 4964/22CE : C2 02                      	LDC	R0,@RR2		; Get string length
 4965/22D0 : 18 FC                      	LD	R1,FLAGS
 4966/22D2 : A0 E2                      	INCW	RR2
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 84 - 2023/10/26 22時18分50秒


 4967/22D4 : A0 E2                      	INCW	RR2
 4968/22D6 : C2 72                      	LDC	R7,@RR2		; Get LSB of string address
 4969/22D8 : A0 E2                      	INCW	RR2
 4970/22DA : C2 62                      	LDC	R6,@RR2		; Get MSB of string address
 4971/22DC : A0 E2                      	INCW	RR2
 4972/22DE : 19 FC                      	LD	FLAGS,R1
 4973/22E0 : 5B 01                      	JR	MI,$+3
 4974/22E2 : AF                         	RET			; Not a string - Return
 4975/22E3 : 42 00                      	OR	R0,R0		; Set flags on string length
 4976/22E5 : EB 01                      	JR	NZ,$+3
 4977/22E7 : AF                         	RET			; Null string - Return
 4978/22E8 : 48 E2                      	LD	R4,R2		; Save variable pointer
 4979/22EA : 58 E3                      	LD	R5,R3
 4980/22EC : 8C 81                      	LD	R8,#hi(STRBOT)
 4981/22EE : 9C 10                      	LD	R9,#lo(STRBOT)
 4982/22F0 : C2 28                      	LDC	R2,@RR8
 4983/22F2 : A0 E8                      	INCW	RR8
 4984/22F4 : C2 38                      	LDC	R3,@RR8		; Bottom of new area
 4985/22F6 : D6 0A 3D                   	CALL	CPDEHL		; String been done?
 4986/22F9 : 28 E4                      	LD	R2,R4		; Restore variable pointer
 4987/22FB : 38 E5                      	LD	R3,R5
 4988/22FD : FB 01                      	JR	NC,$+3
 4989/22FF : AF                         	RET			; String done - Ignore
 4990/2300 : 50 E2                      	POP	R2
 4991/2302 : 50 E3                      	POP	R3		; Return address
 4992/2304 : 50 E8                      	POP	R8
 4993/2306 : 50 E9                      	POP	R9
 4994/2308 : 70 E3                      	PUSH	R3
 4995/230A : 70 E2                      	PUSH	R2
 4996/230C : 28 E8                      	LD	R2,R8
 4997/230E : 38 E9                      	LD	R3,R9		; Lowest available string area
 4998/2310 : D6 0A 3D                   	CALL	CPDEHL		; String within string area?
 4999/2313 : 50 E8                      	POP	R8
 5000/2315 : 50 E9                      	POP	R9
 5001/2317 : 70 E3                      	PUSH	R3
 5002/2319 : 70 E2                      	PUSH	R2
 5003/231B : 28 E8                      	LD	R2,R8
 5004/231D : 38 E9                      	LD	R3,R9		; Lowest available string area
 5005/231F : 70 E3                      	PUSH	R3
 5006/2321 : 70 E2                      	PUSH	R2		; Re-save return address
 5007/2323 : 28 E4                      	LD	R2,R4		; Restore variable pointer
 5008/2325 : 38 E5                      	LD	R3,R5
 5009/2327 : 7B 01                      	JR	C,$+3
 5010/2329 : AF                         	RET			; Outside string area - Ignore
 5011/232A : 50 E4                      	POP	R4
 5012/232C : 50 E5                      	POP	R5		; Get return , Throw 2 away
 5013/232E : 50 E0                      	POP	R0
 5014/2330 : 50 E1                      	POP	R1
 5015/2332 : 19 FC                      	LD	FLAGS,R1
 5016/2334 : 50 E0                      	POP	R0
 5017/2336 : 50 E1                      	POP	R1
 5018/2338 : 19 FC                      	LD	FLAGS,R1
 5019/233A : 70 E3                      	PUSH	R3
 5020/233C : 70 E2                      	PUSH	R2		; Save variable pointer
 5021/233E : 70 E7                      	PUSH	R7
 5022/2340 : 70 E6                      	PUSH	R6		; Save address of current
 5023/2342 : 70 E5                      	PUSH	R5
 5024/2344 : 70 E4                      	PUSH	R4		; Put back return address
 5025/2346 : AF                         	RET			; Go to it
 5026/2347 :                            ;
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 85 - 2023/10/26 22時18分50秒


 5027/2347 :                            SCNEND:
 5028/2347 : 50 E6                      	POP	R6
 5029/2349 : 50 E7                      	POP	R7		; Addresses of strings
 5030/234B : 50 E2                      	POP	R2
 5031/234D : 50 E3                      	POP	R3		;
 5032/234F : 08 E3                      	LD	R0,R3		; HL = 0 if no more to do
 5033/2351 : 42 02                      	OR	R0,R2
 5034/2353 : CF                         	RCF
 5035/2354 : EB 01                      	JR	NZ,$+3
 5036/2356 : AF                         	RET			; No more to do - Return
 5037/2357 : 80 E2                      	DECW	RR2
 5038/2359 : C2 42                      	LDC	R4,@RR2		; MSB of address of string
 5039/235B : 80 E2                      	DECW	RR2
 5040/235D : C2 52                      	LDC	R5,@RR2		; LSB of address of string
 5041/235F : 70 E3                      	PUSH	R3
 5042/2361 : 70 E2                      	PUSH	R2		; Save variable address
 5043/2363 : 80 E2                      	DECW	RR2
 5044/2365 : 80 E2                      	DECW	RR2
 5045/2367 : C2 32                      	LDC	R3,@RR2		; HL = Length of string
 5046/2369 : 2C 00                      	LD	R2,#0
 5047/236B : 02 35                      	ADD	R3,R5
 5048/236D : 12 24                      	ADC	R2,R4		; Address of end of string+1
 5049/236F : 68 E4                      	LD	R6,R4		; String address to DE
 5050/2371 : 78 E5                      	LD	R7,R5
 5051/2373 : 80 E2                      	DECW	RR2		; Last byte in string
 5052/2375 : 48 E2                      	LD	R4,R2		; Address to BC
 5053/2377 : 58 E3                      	LD	R5,R3
 5054/2379 : 8C 81                      	LD	R8,#hi(STRBOT)
 5055/237B : 9C 10                      	LD	R9,#lo(STRBOT)
 5056/237D : C2 28                      	LDC	R2,@RR8
 5057/237F : A0 E8                      	INCW	RR8
 5058/2381 : C2 38                      	LDC	R3,@RR8		; Current bottom of string area
 5059/2383 : D6 04 87                   	CALL	MOVSTR		; Move string to new address
 5060/2386 : 50 E2                      	POP	R2
 5061/2388 : 50 E3                      	POP	R3		; Restore variable address
 5062/238A : D2 52                      	LDC	@RR2,R5		; Save new LSB of address
 5063/238C :                            ;	LD	R1,FLAGS
 5064/238C : A0 E2                      	INCW	RR2
 5065/238E :                            ;	LD	FLAGS,R1
 5066/238E : D2 42                      	LDC	@RR2,R4		; Save new MSB of address
 5067/2390 : 38 E5                      	LD	R3,R5		; Next string area+1 to HL
 5068/2392 : 28 E4                      	LD	R2,R4
 5069/2394 :                            ;	LD	R1,FLAGS
 5070/2394 : 80 E2                      	DECW	RR2		; Next string area address
 5071/2396 :                            ;	LD	FLAGS,R1
 5072/2396 : 8D 21 A9                   	JP	GARBLP		; Look for more strings
 5073/2399 :                            ;
 5074/2399 :                            CONCAT:
 5075/2399 : 70 E5                      	PUSH	R5
 5076/239B : 70 E4                      	PUSH	R4		; Save prec' opr & code string
 5077/239D : 70 E3                      	PUSH	R3
 5078/239F : 70 E2                      	PUSH	R2		;
 5079/23A1 : 8C 81                      	LD	R8,#hi(FPREG)
 5080/23A3 : 9C 31                      	LD	R9,#lo(FPREG)
 5081/23A5 :                            
 5082/23A5 :                            ;	LDC	R2,@RR8
 5083/23A5 :                            ;	LD	R1,FLAGS
 5084/23A5 :                            ;	INCW	RR8
 5085/23A5 :                            ;	LD	FLAGS,R1
 5086/23A5 :                            ;	LDC	R3,@RR8		; Get first string
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 86 - 2023/10/26 22時18分50秒


 5087/23A5 : C2 38                      	LDC	R3,@RR8		; @@@ SWAP HL
 5088/23A7 : A0 E8                      	INCW	RR8
 5089/23A9 : C2 28                      	LDC	R2,@RR8		; Get first string
 5090/23AB :                            
 5091/23AB : 50 E8                      	POP	R8
 5092/23AD : 50 E9                      	POP	R9
 5093/23AF : 70 E3                      	PUSH	R3
 5094/23B1 : 70 E2                      	PUSH	R2
 5095/23B3 : 28 E8                      	LD	R2,R8
 5096/23B5 : 38 E9                      	LD	R3,R9		; Save first string
 5097/23B7 : D6 17 95                   	CALL	OPRND		; Get second string
 5098/23BA : 50 E8                      	POP	R8
 5099/23BC : 50 E9                      	POP	R9
 5100/23BE : 70 E3                      	PUSH	R3
 5101/23C0 : 70 E2                      	PUSH	R2
 5102/23C2 : 28 E8                      	LD	R2,R8
 5103/23C4 : 38 E9                      	LD	R3,R9		; Restore first string
 5104/23C6 : D6 16 85                   	CALL	TSTSTR		; Make sure it's a string
 5105/23C9 : C2 02                      	LDC	R0,@RR2		; Get length of second string
 5106/23CB : 70 E3                      	PUSH	R3
 5107/23CD : 70 E2                      	PUSH	R2		; Save first string
 5108/23CF : 8C 81                      	LD	R8,#hi(FPREG)
 5109/23D1 : 9C 31                      	LD	R9,#lo(FPREG)
 5110/23D3 :                            
 5111/23D3 :                            ;	LDC	R2,@RR8
 5112/23D3 :                            ;	LD	R1,FLAGS
 5113/23D3 :                            ;	INCW	RR8
 5114/23D3 :                            ;	LD	FLAGS,R1
 5115/23D3 :                            ;	LDC	R3,@RR8		; Get second string
 5116/23D3 : C2 38                      	LDC	R3,@RR8		; @@@ SWAP HL
 5117/23D5 : A0 E8                      	INCW	RR8
 5118/23D7 : C2 28                      	LDC	R2,@RR8		; Get second string
 5119/23D9 :                            
 5120/23D9 : 70 E3                      	PUSH	R3
 5121/23DB : 70 E2                      	PUSH	R2		; Save second string
 5122/23DD : C2 82                      	LDC	R8,@RR2
 5123/23DF : 02 08                      	ADD	R0,R8		; Add length of second string
 5124/23E1 : 7C 1C                      	LD	R7,#LS		; ?LS Error
 5125/23E3 : 7D 05 19                   	JP	C,ERROR		; String too long - Error
 5126/23E6 : D6 20 5B                   	CALL	MKTMST		; Make temporary string
 5127/23E9 : 50 E6                      	POP	R6
 5128/23EB : 50 E7                      	POP	R7		; Get second string to DE
 5129/23ED : D6 24 7E                   	CALL	GSTRDE		; Move to string pool if needed
 5130/23F0 : 50 E8                      	POP	R8
 5131/23F2 : 50 E9                      	POP	R9
 5132/23F4 : 70 E3                      	PUSH	R3
 5133/23F6 : 70 E2                      	PUSH	R2
 5134/23F8 : 28 E8                      	LD	R2,R8
 5135/23FA : 38 E9                      	LD	R3,R9		; Get first string
 5136/23FC : D6 24 72                   	CALL	GSTRHL		; Move to string pool if needed
 5137/23FF : 70 E3                      	PUSH	R3
 5138/2401 : 70 E2                      	PUSH	R2		; Save first string
 5139/2403 : 8C 81                      	LD	R8,#hi(TMPSTR+2)
 5140/2405 : 9C 0E                      	LD	R9,#lo(TMPSTR+2)
 5141/2407 : C2 28                      	LDC	R2,@RR8
 5142/2409 : A0 E8                      	INCW	RR8
 5143/240B : C2 38                      	LDC	R3,@RR8		; Temporary string address
 5144/240D : 88 E6                      	LD	R8,R6
 5145/240F : 98 E7                      	LD	R9,R7
 5146/2411 : 68 E2                      	LD	R6,R2
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 87 - 2023/10/26 22時18分50秒


 5147/2413 : 78 E3                      	LD	R7,R3
 5148/2415 : 28 E8                      	LD	R2,R8
 5149/2417 : 38 E9                      	LD	R3,R9		; To DE
 5150/2419 : D6 24 36                   	CALL	SSTSA		; First string to string area
 5151/241C : D6 24 36                   	CALL	SSTSA		; Second string to string area
 5152/241F : 2C 16                      	LD	R2,#hi(EVAL2)
 5153/2421 : 3C C8                      	LD	R3,#lo(EVAL2)	; Return to evaluation loop
 5154/2423 : 50 E8                      	POP	R8
 5155/2425 : 50 E9                      	POP	R9
 5156/2427 : 70 E3                      	PUSH	R3
 5157/2429 : 70 E2                      	PUSH	R2
 5158/242B : 28 E8                      	LD	R2,R8
 5159/242D : 38 E9                      	LD	R3,R9		; Save return,get code string
 5160/242F : 70 E3                      	PUSH	R3
 5161/2431 : 70 E2                      	PUSH	R2		; Save code string address
 5162/2433 : 8D 20 BE                   	JP	TSTOPL		; To temporary string to pool
 5163/2436 :                            ;
 5164/2436 :                            SSTSA:
 5165/2436 : 50 E2                      	POP	R2
 5166/2438 : 50 E3                      	POP	R3		; Return address
 5167/243A : 50 E8                      	POP	R8
 5168/243C : 50 E9                      	POP	R9
 5169/243E : 70 E3                      	PUSH	R3
 5170/2440 : 70 E2                      	PUSH	R2
 5171/2442 : 28 E8                      	LD	R2,R8
 5172/2444 : 38 E9                      	LD	R3,R9		; Get string block,save return
 5173/2446 : C2 02                      	LDC	R0,@RR2		; Get length of string
 5174/2448 : A0 E2                      	INCW	RR2
 5175/244A : A0 E2                      	INCW	RR2
 5176/244C : C2 52                      	LDC	R5,@RR2		; Get LSB of string address
 5177/244E : A0 E2                      	INCW	RR2
 5178/2450 : C2 42                      	LDC	R4,@RR2		; Get MSB of string address
 5179/2452 : 38 E0                      	LD	R3,R0		; Length to L
 5180/2454 :                            TOSTRA:
 5181/2454 : 3E                         	INC	R3		; INC - DECed after
 5182/2455 :                            TSALP:
 5183/2455 : 00 E3                      	DEC	R3		; Count bytes moved
 5184/2457 : EB 01                      	JR	NZ,$+3
 5185/2459 : AF                         	RET			; End of string - Return
 5186/245A : C2 04                      	LDC	R0,@RR4		; Get source
 5187/245C : D2 06                      	LDC	@RR6,R0		; Save destination
 5188/245E : A0 E4                      	INCW	RR4		; Next source
 5189/2460 : A0 E6                      	INCW	RR6		; Next destination
 5190/2462 : 8D 24 55                   	JP	TSALP		; Loop until string moved
 5191/2465 :                            ;
 5192/2465 :                            GETSTR:
 5193/2465 : D6 16 85                   	CALL	TSTSTR		; Make sure it's a string
 5194/2468 :                            GSTRCU:
 5195/2468 : 8C 81                      	LD	R8,#hi(FPREG)
 5196/246A : 9C 31                      	LD	R9,#lo(FPREG)
 5197/246C :                            
 5198/246C :                            ;	LDC	R2,@RR8
 5199/246C :                            ;	LD	R1,FLAGS
 5200/246C :                            ;	INCW	RR8
 5201/246C :                            ;	LD	FLAGS,R1
 5202/246C :                            ;	LDC	R3,@RR8		; Get current string
 5203/246C : C2 38                      	LDC	R3,@RR8		; @@@ SWAP HL
 5204/246E : A0 E8                      	INCW	RR8
 5205/2470 : C2 28                      	LDC	R2,@RR8		; Get current string
 5206/2472 :                            GSTRHL:
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 88 - 2023/10/26 22時18分50秒


 5207/2472 : 88 E6                      	LD	R8,R6
 5208/2474 : 98 E7                      	LD	R9,R7
 5209/2476 : 68 E2                      	LD	R6,R2
 5210/2478 : 78 E3                      	LD	R7,R3
 5211/247A : 28 E8                      	LD	R2,R8
 5212/247C : 38 E9                      	LD	R3,R9		; Save DE
 5213/247E :                            GSTRDE:
 5214/247E : D6 24 C5                   	CALL	BAKTMP		; Was it last tmp-str?
 5215/2481 : 88 E6                      	LD	R8,R6
 5216/2483 : 98 E7                      	LD	R9,R7
 5217/2485 : 68 E2                      	LD	R6,R2
 5218/2487 : 78 E3                      	LD	R7,R3
 5219/2489 : 28 E8                      	LD	R2,R8
 5220/248B : 38 E9                      	LD	R3,R9		; Restore DE
 5221/248D : 6B 01                      	JR	Z,$+3
 5222/248F : AF                         	RET			; No - Return
 5223/2490 : 70 E7                      	PUSH	R7
 5224/2492 : 70 E6                      	PUSH	R6		; Save string
 5225/2494 : 68 E4                      	LD	R6,R4		; String block address to DE
 5226/2496 : 78 E5                      	LD	R7,R5
 5227/2498 : 80 E6                      	DECW	RR6		; Point to length
 5228/249A : C2 52                      	LDC	R5,@RR2		; Get string length
 5229/249C : 8C 81                      	LD	R8,#hi(STRBOT)
 5230/249E : 9C 10                      	LD	R9,#lo(STRBOT)
 5231/24A0 : C2 28                      	LDC	R2,@RR8
 5232/24A2 : A0 E8                      	INCW	RR8
 5233/24A4 : C2 38                      	LDC	R3,@RR8		; Current bottom of string area
 5234/24A6 : D6 0A 3D                   	CALL	CPDEHL		; Last one in string area?
 5235/24A9 : ED 24 C0                   	JP	NZ,POPHL	; No - Return
 5236/24AC : 48 E0                      	LD	R4,R0		; Clear B (A=0)
 5237/24AE : 02 35                      	ADD	R3,R5
 5238/24B0 : 12 24                      	ADC	R2,R4		; Remove string from str' area
 5239/24B2 : 8C 81                      	LD	R8,#hi(STRBOT)
 5240/24B4 : 9C 10                      	LD	R9,#lo(STRBOT)
 5241/24B6 : D2 28                      	LDC	@RR8,R2
 5242/24B8 : 18 FC                      	LD	R1,FLAGS
 5243/24BA : A0 E8                      	INCW	RR8
 5244/24BC : 19 FC                      	LD	FLAGS,R1
 5245/24BE : D2 38                      	LDC	@RR8,R3		; Save new bottom of str' area
 5246/24C0 :                            POPHL:
 5247/24C0 : 50 E2                      	POP	R2
 5248/24C2 : 50 E3                      	POP	R3		; Restore string
 5249/24C4 : AF                         	RET
 5250/24C5 :                            ;
 5251/24C5 :                            BAKTMP:
 5252/24C5 : 8C 80                      	LD	R8,#hi(TMSTPT)
 5253/24C7 : 9C FE                      	LD	R9,#lo(TMSTPT)
 5254/24C9 : C2 28                      	LDC	R2,@RR8
 5255/24CB : A0 E8                      	INCW	RR8
 5256/24CD : C2 38                      	LDC	R3,@RR8		; Get temporary string pool top
 5257/24CF : 80 E2                      	DECW	RR2		; Back
 5258/24D1 : C2 42                      	LDC	R4,@RR2		; Get MSB of address
 5259/24D3 : 80 E2                      	DECW	RR2		; Back
 5260/24D5 : C2 52                      	LDC	R5,@RR2		; Get LSB of address
 5261/24D7 : 80 E2                      	DECW	RR2		; Back
 5262/24D9 : 80 E2                      	DECW	RR2		; Back
 5263/24DB : D6 0A 3D                   	CALL	CPDEHL		; String last in string pool?
 5264/24DE : 6B 01                      	JR	Z,$+3
 5265/24E0 : AF                         	RET			; Yes - Leave it
 5266/24E1 : 8C 80                      	LD	R8,#hi(TMSTPT)
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 89 - 2023/10/26 22時18分50秒


 5267/24E3 : 9C FE                      	LD	R9,#lo(TMSTPT)
 5268/24E5 : D2 28                      	LDC	@RR8,R2
 5269/24E7 : 18 FC                      	LD	R1,FLAGS
 5270/24E9 : A0 E8                      	INCW	RR8
 5271/24EB : 19 FC                      	LD	FLAGS,R1
 5272/24ED : D2 38                      	LDC	@RR8,R3		; Save new string pool top
 5273/24EF : AF                         	RET
 5274/24F0 :                            ;
 5275/24F0 :                            LEN:
 5276/24F0 : 4C 1E                      	LD	R4,#hi(PASSA)
 5277/24F2 : 5C C8                      	LD	R5,#lo(PASSA)	; To return integer A
 5278/24F4 : 70 E5                      	PUSH	R5
 5279/24F6 : 70 E4                      	PUSH	R4		; Save address
 5280/24F8 :                            GETLEN:
 5281/24F8 : D6 24 65                   	CALL	GETSTR		; Get string and its length
 5282/24FB : B2 00                      	XOR	R0,R0
 5283/24FD : CF                         	RCF
 5284/24FE : 68 E0                      	LD	R6,R0		; Clear D
 5285/2500 : 8C 80                      	LD	R8,#hi(TYPE)
 5286/2502 : 9C FA                      	LD	R9,#lo(TYPE)
 5287/2504 : D2 08                      	LDC	@RR8,R0		; Set type to numeric
 5288/2506 : C2 02                      	LDC	R0,@RR2		; Get length of string
 5289/2508 : 42 00                      	OR	R0,R0
 5290/250A : CF                         	RCF			; Set status flags
 5291/250B : AF                         	RET
 5292/250C :                            ;
 5293/250C :                            ASC:
 5294/250C : 4C 1E                      	LD	R4,#hi(PASSA)
 5295/250E : 5C C8                      	LD	R5,#lo(PASSA)	; To return integer A
 5296/2510 : 70 E5                      	PUSH	R5
 5297/2512 : 70 E4                      	PUSH	R4		; Save address
 5298/2514 :                            GTFLNM:
 5299/2514 : D6 24 F8                   	CALL	GETLEN		; Get length of string
 5300/2517 : 6D 0F 7B                   	JP	Z,FCERR		; Null string - Error
 5301/251A : 18 FC                      	LD	R1,FLAGS
 5302/251C : A0 E2                      	INCW	RR2
 5303/251E : A0 E2                      	INCW	RR2
 5304/2520 : C2 72                      	LDC	R7,@RR2		; Get LSB of address
 5305/2522 : A0 E2                      	INCW	RR2
 5306/2524 : 19 FC                      	LD	FLAGS,R1
 5307/2526 : C2 62                      	LDC	R6,@RR2		; Get MSB of address
 5308/2528 : C2 06                      	LDC	R0,@RR6		; Get first byte of string
 5309/252A : AF                         	RET
 5310/252B :                            ;
 5311/252B :                            CHR:
 5312/252B : 0C 01                      	LD	R0,#1		; One character string
 5313/252D : D6 20 5B                   	CALL	MKTMST		; Make a temporary string
 5314/2530 : D6 26 EE                   	CALL	MAKINT		; Make it integer A
 5315/2533 : 8C 81                      	LD	R8,#hi(TMPSTR+2)
 5316/2535 : 9C 0E                      	LD	R9,#lo(TMPSTR+2)
 5317/2537 :                            
 5318/2537 :                            ;	LDC	R2,@RR8
 5319/2537 :                            ;	LD	R1,FLAGS
 5320/2537 :                            ;	INCW	RR8
 5321/2537 :                            ;	LD	FLAGS,R1
 5322/2537 :                            ;	LDC	R3,@RR8		; Get address of string
 5323/2537 : C2 38                      	LDC	R3,@RR8		; @@@ SWAP HL
 5324/2539 : 18 FC                      	LD	R1,FLAGS
 5325/253B : A0 E8                      	INCW	RR8
 5326/253D :                            
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 90 - 2023/10/26 22時18分50秒


 5327/253D : 19 FC                      	LD	FLAGS,R1
 5328/253F : C2 28                      	LDC	R2,@RR8		; Get address of string
 5329/2541 :                            
 5330/2541 : D2 72                      	LDC	@RR2,R7		; Save character
 5331/2543 :                            TOPOOL:
 5332/2543 : 50 E4                      	POP	R4
 5333/2545 : 50 E5                      	POP	R5		; Clean up stack
 5334/2547 : 8D 20 BE                   	JP	TSTOPL		; Temporary string to pool
 5335/254A :                            ;
 5336/254A :                            LEFT:
 5337/254A : D6 26 75                   	CALL	LFRGNM		; Get number and ending ")"
 5338/254D : B2 00                      	XOR	R0,R0
 5339/254F : CF                         	RCF			; Start at first byte in string
 5340/2550 :                            RIGHT1:
 5341/2550 : 50 E8                      	POP	R8
 5342/2552 : 50 E9                      	POP	R9
 5343/2554 : 70 E3                      	PUSH	R3
 5344/2556 : 70 E2                      	PUSH	R2
 5345/2558 : 28 E8                      	LD	R2,R8
 5346/255A : 38 E9                      	LD	R3,R9		; Save code string,Get string
 5347/255C : 58 E0                      	LD	R5,R0		; Starting position in string
 5348/255E :                            MID1:
 5349/255E : 70 E3                      	PUSH	R3
 5350/2560 : 70 E2                      	PUSH	R2		; Save string block address
 5351/2562 : C2 02                      	LDC	R0,@RR2		; Get length of string
 5352/2564 : A2 04                      	CP	R0,R4		; Compare with number given
 5353/2566 : 7D 25 6D                   	JP	C,ALLFOL	; All following bytes required
 5354/2569 : 08 E4                      	LD	R0,R4		; Get new length
 5355/256B : 8B 02                      	JR	ALLFOL1		; Skip "LD C,0"
 5356/256D :                            ALLFOL:
 5357/256D : 5C 00                      	LD	R5,#0		; First byte of string
 5358/256F :                            ALLFOL1:
 5359/256F : 70 E5                      	PUSH	R5
 5360/2571 : 70 E4                      	PUSH	R4		; Save position in string
 5361/2573 : D6 21 23                   	CALL	TESTR		; See if enough string space
 5362/2576 : 50 E4                      	POP	R4
 5363/2578 : 50 E5                      	POP	R5		; Get position in string
 5364/257A : 50 E2                      	POP	R2
 5365/257C : 50 E3                      	POP	R3		; Restore string block address
 5366/257E : 70 E3                      	PUSH	R3
 5367/2580 : 70 E2                      	PUSH	R2		; And re-save it
 5368/2582 : A0 E2                      	INCW	RR2
 5369/2584 : A0 E2                      	INCW	RR2
 5370/2586 : C2 42                      	LDC	R4,@RR2		; Get LSB of address
 5371/2588 : A0 E2                      	INCW	RR2
 5372/258A : C2 22                      	LDC	R2,@RR2		; Get MSB of address
 5373/258C : 38 E4                      	LD	R3,R4		; HL = address of string
 5374/258E : 4C 00                      	LD	R4,#0		; BC = starting address
 5375/2590 : 02 35                      	ADD	R3,R5
 5376/2592 : 12 24                      	ADC	R2,R4		; Point to that byte
 5377/2594 : 48 E2                      	LD	R4,R2		; BC = source string
 5378/2596 : 58 E3                      	LD	R5,R3
 5379/2598 : D6 20 5E                   	CALL	CRTMST		; Create a string entry
 5380/259B : 38 E0                      	LD	R3,R0		; Length of new string
 5381/259D : D6 24 54                   	CALL	TOSTRA		; Move string to string area
 5382/25A0 : 50 E6                      	POP	R6
 5383/25A2 : 50 E7                      	POP	R7		; Clear stack
 5384/25A4 : D6 24 7E                   	CALL	GSTRDE		; Move to string pool if needed
 5385/25A7 : 8D 20 BE                   	JP	TSTOPL		; Temporary string to pool
 5386/25AA :                            ;
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 91 - 2023/10/26 22時18分50秒


 5387/25AA :                            RIGHT:
 5388/25AA : D6 26 75                   	CALL	LFRGNM		; Get number and ending ")"
 5389/25AD : 50 E6                      	POP	R6
 5390/25AF : 50 E7                      	POP	R7		; Get string length
 5391/25B1 : 70 E7                      	PUSH	R7
 5392/25B3 : 70 E6                      	PUSH	R6		; And re-save
 5393/25B5 : C2 06                      	LDC	R0,@RR6		; Get length
 5394/25B7 : 22 04                      	SUB	R0,R4		; Move back N bytes
 5395/25B9 : 8D 25 50                   	JP	RIGHT1		; Go and get sub-string
 5396/25BC :                            ;
 5397/25BC :                            MID:
 5398/25BC : 88 E6                      	LD	R8,R6
 5399/25BE : 98 E7                      	LD	R9,R7
 5400/25C0 : 68 E2                      	LD	R6,R2
 5401/25C2 : 78 E3                      	LD	R7,R3
 5402/25C4 : 28 E8                      	LD	R2,R8
 5403/25C6 : 38 E9                      	LD	R3,R9		; Get code string address
 5404/25C8 : C2 02                      	LDC	R0,@RR2		; Get next byte ',' or ")"
 5405/25CA : D6 26 85                   	CALL	MIDNUM		; Get number supplied
 5406/25CD : 4E                         	INC	R4		; Is it character zero?
 5407/25CE : 00 E4                      	DEC	R4
 5408/25D0 : 6D 0F 7B                   	JP	Z,FCERR		; Yes - Error
 5409/25D3 : 70 E5                      	PUSH	R5
 5410/25D5 : 70 E4                      	PUSH	R4		; Save starting position
 5411/25D7 : 7C FF                      	LD	R7,#255		; All of string
 5412/25D9 : A6 E0 29                   	CP	R0,#')'		; Any length given?
 5413/25DC : 6D 25 E6                   	JP	Z,RSTSTR	; No - Rest of string
 5414/25DF : D6 0A 49                   	CALL	CHKSYN		; Make sure ',' follows
 5415/25E2 : 2C                         	DB	','
 5416/25E3 : D6 26 EB                   	CALL	GETINT		; Get integer 0-255
 5417/25E6 :                            RSTSTR:
 5418/25E6 : D6 0A 49                   	CALL	CHKSYN		; Make sure ")" follows
 5419/25E9 : 29                         	DB	")"
 5420/25EA : 50 E0                      	POP	R0		; Restore starting position
 5421/25EC : 50 E1                      	POP	R1
 5422/25EE : 19 FC                      	LD	FLAGS,R1
 5423/25F0 : 50 E8                      	POP	R8
 5424/25F2 : 50 E9                      	POP	R9
 5425/25F4 : 70 E3                      	PUSH	R3
 5426/25F6 : 70 E2                      	PUSH	R2
 5427/25F8 : 28 E8                      	LD	R2,R8
 5428/25FA : 38 E9                      	LD	R3,R9		; Get string,8ave code string
 5429/25FC : 4C 25                      	LD	R4,#hi(MID1)
 5430/25FE : 5C 5E                      	LD	R5,#lo(MID1)	; Continuation of MID$ routine
 5431/2600 : 70 E5                      	PUSH	R5
 5432/2602 : 70 E4                      	PUSH	R4		; Save for return
 5433/2604 : 00 E0                      	DEC	R0		; Starting position-1
 5434/2606 : C2 82                      	LDC	R8,@RR2
 5435/2608 : A2 08                      	CP	R0,R8		; Compare with length
 5436/260A : 4C 00                      	LD	R4,#0		; Zero bytes length
 5437/260C : 7B 01                      	JR	C,$+3
 5438/260E : AF                         	RET			; Null string if start past end
 5439/260F : 58 E0                      	LD	R5,R0		; Save starting position-1
 5440/2611 : C2 02                      	LDC	R0,@RR2		; Get length of string
 5441/2613 : 22 05                      	SUB	R0,R5		; Subtract start
 5442/2615 : A2 07                      	CP	R0,R7		; Enough string for it?
 5443/2617 : 48 E0                      	LD	R4,R0		; Save maximum length available
 5444/2619 : FB 01                      	JR	NC,$+3
 5445/261B : AF                         	RET			; Truncate string if needed
 5446/261C : 48 E7                      	LD	R4,R7		; Set specified length
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 92 - 2023/10/26 22時18分50秒


 5447/261E : AF                         	RET			; Go and create string
 5448/261F :                            ;
 5449/261F :                            VAL:
 5450/261F : D6 24 F8                   	CALL	GETLEN		; Get length of string
 5451/2622 : 6D 28 05                   	JP	Z,RESZER	; Result zero
 5452/2625 : 78 E0                      	LD	R7,R0		; Save length
 5453/2627 : A0 E2                      	INCW	RR2
 5454/2629 : A0 E2                      	INCW	RR2
 5455/262B : C2 02                      	LDC	R0,@RR2		; Get LSB of address
 5456/262D : A0 E2                      	INCW	RR2
 5457/262F : C2 22                      	LDC	R2,@RR2		; Get MSB of address
 5458/2631 : 38 E0                      	LD	R3,R0		; HL = String address
 5459/2633 : 70 E3                      	PUSH	R3
 5460/2635 : 70 E2                      	PUSH	R2		; Save string address
 5461/2637 : 02 37                      	ADD	R3,R7
 5462/2639 : 12 26                      	ADC	R2,R6
 5463/263B : C2 42                      	LDC	R4,@RR2		; Get end of string+1 byte
 5464/263D : D2 62                      	LDC	@RR2,R6		; Zero it to terminate
 5465/263F : 50 E8                      	POP	R8
 5466/2641 : 50 E9                      	POP	R9
 5467/2643 : 70 E3                      	PUSH	R3
 5468/2645 : 70 E2                      	PUSH	R2
 5469/2647 : 28 E8                      	LD	R2,R8
 5470/2649 : 38 E9                      	LD	R3,R9		; Save string end,get start
 5471/264B : 70 E5                      	PUSH	R5
 5472/264D : 70 E4                      	PUSH	R4		; Save end+1 byte
 5473/264F : C2 02                      	LDC	R0,@RR2		; Get starting byte
 5474/2651 : A6 E0 24                   	CP	R0,#'$'		; Hex number indicated? [function added]
 5475/2654 : ED 26 5C                   	JP	NZ,VAL1
 5476/2657 : D6 34 FB                   	CALL	HEXTFP		; Convert Hex to FPREG
 5477/265A : 8B 0E                      	JR	VAL3
 5478/265C :                            VAL1:
 5479/265C : A6 E0 25                   	CP	R0,#'%'		; Binary number indicated? [function added]
 5480/265F : ED 26 67                   	JP	NZ,VAL2
 5481/2662 : D6 35 B9                   	CALL	BINTFP		; Convert Bin to FPREG
 5482/2665 : 8B 03                      	JR	VAL3
 5483/2667 :                            VAL2:
 5484/2667 : D6 2D 7E                   	CALL	ASCTFP		; Convert ASCII string to FP
 5485/266A :                            VAL3:
 5486/266A : 50 E4                      	POP	R4
 5487/266C : 50 E5                      	POP	R5		; Restore end+1 byte
 5488/266E : 50 E2                      	POP	R2
 5489/2670 : 50 E3                      	POP	R3		; Restore end+1 address
 5490/2672 : D2 42                      	LDC	@RR2,R4		; Put back original byte
 5491/2674 : AF                         	RET
 5492/2675 :                            ;
 5493/2675 :                            LFRGNM:
 5494/2675 : 88 E6                      	LD	R8,R6
 5495/2677 : 98 E7                      	LD	R9,R7
 5496/2679 : 68 E2                      	LD	R6,R2
 5497/267B : 78 E3                      	LD	R7,R3
 5498/267D : 28 E8                      	LD	R2,R8
 5499/267F : 38 E9                      	LD	R3,R9		; Code string address to HL
 5500/2681 : D6 0A 49                   	CALL	CHKSYN		; Make sure ")" follows
 5501/2684 : 29                         	DB	")"
 5502/2685 :                            MIDNUM:
 5503/2685 : 50 E4                      	POP	R4
 5504/2687 : 50 E5                      	POP	R5		; Get return address
 5505/2689 : 50 E6                      	POP	R6
 5506/268B : 50 E7                      	POP	R7		; Get number supplied
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 93 - 2023/10/26 22時18分50秒


 5507/268D : 70 E5                      	PUSH	R5
 5508/268F : 70 E4                      	PUSH	R4		; Re-save return address
 5509/2691 : 48 E7                      	LD	R4,R7		; Number to B
 5510/2693 : AF                         	RET
 5511/2694 :                            ;
 5512/2694 :                            INP:
 5513/2694 : D6 26 EE                   	CALL	MAKINT		; Make it integer A
 5514/2697 : 8C 80                      	LD	R8,#hi(INPORT)
 5515/2699 : 9C 8C                      	LD	R9,#lo(INPORT)
 5516/269B : D2 08                      	LDC	@RR8,R0		; Set input port
 5517/269D : D6 80 8B                   	CALL	INPSUB		; Get input from port
 5518/26A0 : 8D 1E C8                   	JP	PASSA		; Return integer A
 5519/26A3 :                            ;
 5520/26A3 :                            POUT:
 5521/26A3 : D6 26 D2                   	CALL	SETIO		; Set up port number
 5522/26A6 : 8D 80 4B                   	JP	OUTSUB		; Output data and return
 5523/26A9 :                            ;
 5524/26A9 :                            WAIT:
 5525/26A9 : D6 26 D2                   	CALL	SETIO		; Set up port number
 5526/26AC : 18 FC                      	LD	R1,FLAGS
 5527/26AE : 70 E1                      	PUSH	R1
 5528/26B0 : 70 E0                      	PUSH	R0		; Save AND mask
 5529/26B2 : 7C 00                      	LD	R7,#0		; Assume zero if none given
 5530/26B4 : 80 E2                      	DECW	RR2		; DEC 'cos GETCHR INCs
 5531/26B6 : D6 0D AD                   	CALL	GETCHR		; Get next character
 5532/26B9 : 6D 26 C3                   	JP	Z,NOXOR		; No XOR byte given
 5533/26BC : D6 0A 49                   	CALL	CHKSYN		; Make sure ',' follows
 5534/26BF : 2C                         	DB	','
 5535/26C0 : D6 26 EB                   	CALL	GETINT		; Get integer 0-255 to XOR with
 5536/26C3 :                            NOXOR:
 5537/26C3 : 50 E4                      	POP	R4
 5538/26C5 : 50 E5                      	POP	R5		; Restore AND mask
 5539/26C7 :                            WAITLP:
 5540/26C7 : D6 80 8B                   	CALL	INPSUB		; Get input
 5541/26CA : B2 07                      	XOR	R0,R7		; Flip selected bits
 5542/26CC : 52 04                      	AND	R0,R4		; Result non-zero?
 5543/26CE : 6D 26 C7                   	JP	Z,WAITLP	; No = keep waiting
 5544/26D1 : AF                         	RET
 5545/26D2 :                            ;
 5546/26D2 :                            SETIO:
 5547/26D2 : D6 26 EB                   	CALL	GETINT		; Get integer 0-255
 5548/26D5 : 8C 80                      	LD	R8,#hi(INPORT)
 5549/26D7 : 9C 8C                      	LD	R9,#lo(INPORT)
 5550/26D9 : D2 08                      	LDC	@RR8,R0		; Set input port
 5551/26DB : 8C 80                      	LD	R8,#hi(OTPORT)
 5552/26DD : 9C 4C                      	LD	R9,#lo(OTPORT)
 5553/26DF : D2 08                      	LDC	@RR8,R0		; Set output port
 5554/26E1 : D6 0A 49                   	CALL	CHKSYN		; Make sure ',' follows
 5555/26E4 : 2C                         	DB	','
 5556/26E5 : 8D 26 EB                   	JP	GETINT		; Get integer 0-255 and return
 5557/26E8 :                            ;
 5558/26E8 :                            FNDNUM:
 5559/26E8 : D6 0D AD                   	CALL	GETCHR		; Get next character
 5560/26EB :                            GETINT:
 5561/26EB : D6 16 7D                   	CALL	GETNUM		; Get a number from 0 to 255
 5562/26EE :                            MAKINT:
 5563/26EE : D6 0F 51                   	CALL	DEPINT		; Make sure value 0 - 255
 5564/26F1 : 08 E6                      	LD	R0,R6		; Get MSB of number
 5565/26F3 : 42 00                      	OR	R0,R0
 5566/26F5 : CF                         	RCF			; Zero?
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 94 - 2023/10/26 22時18分50秒


 5567/26F6 : ED 0F 7B                   	JP	NZ,FCERR	; No - Error
 5568/26F9 : 80 E2                      	DECW	RR2		; DEC 'cos GETCHR INCs
 5569/26FB : D6 0D AD                   	CALL	GETCHR		; Get next character
 5570/26FE : 08 E7                      	LD	R0,R7		; Get number to A
 5571/2700 : AF                         	RET
 5572/2701 :                            ;
 5573/2701 :                            PEEK:
 5574/2701 : D6 0F 57                   	CALL	DEINT		; Get memory address
 5575/2704 : C2 06                      	LDC	R0,@RR6		; Get byte in memory
 5576/2706 : 8D 1E C8                   	JP	PASSA		; Return integer A
 5577/2709 :                            ;
 5578/2709 :                            POKE:
 5579/2709 : D6 16 7D                   	CALL	GETNUM		; Get memory address
 5580/270C : D6 0F 57                   	CALL	DEINT		; Get integer -32768 to 3276
 5581/270F : 70 E7                      	PUSH	R7
 5582/2711 : 70 E6                      	PUSH	R6		; Save memory address
 5583/2713 : D6 0A 49                   	CALL	CHKSYN		; Make sure ',' follows
 5584/2716 : 2C                         	DB	','
 5585/2717 : D6 26 EB                   	CALL	GETINT		; Get integer 0-255
 5586/271A : 50 E6                      	POP	R6
 5587/271C : 50 E7                      	POP	R7		; Restore memory address
 5588/271E : D2 06                      	LDC	@RR6,R0		; Load it into memory
 5589/2720 : AF                         	RET
 5590/2721 :                            ;
 5591/2721 :                            ROUND:
 5592/2721 : 2C 30                      	LD	R2,#hi(HALF)
 5593/2723 : 3C 7E                      	LD	R3,#lo(HALF)	; Add 0.5 to FPREG
 5594/2725 :                            ADDPHL:
 5595/2725 : D6 2C 07                   	CALL	LOADFP		; Load FP at (HL) to BCDE
 5596/2728 : 8D 27 3B                   	JP	FPADD		; Add BCDE to FPREG
 5597/272B :                            ;
 5598/272B :                            SUBPHL:
 5599/272B : D6 2C 07                   	CALL	LOADFP		; FPREG = -FPREG + number at HL
 5600/272E : 8B 08                      	JR	SUBCDE		; Skip "POP BC" and "POP DE"
 5601/2730 :                            PSUB:
 5602/2730 : 50 E4                      	POP	R4
 5603/2732 : 50 E5                      	POP	R5		; Get FP number from stack
 5604/2734 : 50 E6                      	POP	R6
 5605/2736 : 50 E7                      	POP	R7
 5606/2738 :                            SUBCDE:
 5607/2738 : D6 2B BC                   	CALL	INVSGN		; Negate FPREG
 5608/273B :                            FPADD:
 5609/273B : 08 E4                      	LD	R0,R4		; Get FP exponent
 5610/273D : 42 00                      	OR	R0,R0
 5611/273F : CF                         	RCF			; Is number zero?
 5612/2740 : EB 01                      	JR	NZ,$+3
 5613/2742 : AF                         	RET			; Yes - Nothing to add
 5614/2743 : 8C 81                      	LD	R8,#hi(FPEXP)
 5615/2745 : 9C 34                      	LD	R9,#lo(FPEXP)
 5616/2747 : C2 08                      	LDC	R0,@RR8		; Get FPREG exponent
 5617/2749 : 42 00                      	OR	R0,R0
 5618/274B : CF                         	RCF			; Is this number zero?
 5619/274C : 6D 2B EE                   	JP	Z,FPBCDE	; Yes - Move BCDE to FPREG
 5620/274F : 22 04                      	SUB	R0,R4		; BCDE number larger?
 5621/2751 : FD 27 7D                   	JP	NC,NOSWAP	; No - Don't swap them
 5622/2754 : 60 E0                      	COM	R0		; Two's complement
 5623/2756 : 0E                         	INC	R0		;	FP exponent
 5624/2757 : 88 E6                      	LD	R8,R6
 5625/2759 : 98 E7                      	LD	R9,R7
 5626/275B : 68 E2                      	LD	R6,R2
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 95 - 2023/10/26 22時18分50秒


 5627/275D : 78 E3                      	LD	R7,R3
 5628/275F : 28 E8                      	LD	R2,R8
 5629/2761 : 38 E9                      	LD	R3,R9
 5630/2763 : D6 2B C8                   	CALL	STAKFP		; Put FPREG on stack
 5631/2766 : 88 E6                      	LD	R8,R6
 5632/2768 : 98 E7                      	LD	R9,R7
 5633/276A : 68 E2                      	LD	R6,R2
 5634/276C : 78 E3                      	LD	R7,R3
 5635/276E : 28 E8                      	LD	R2,R8
 5636/2770 : 38 E9                      	LD	R3,R9
 5637/2772 : D6 2B EE                   	CALL	FPBCDE		; Move BCDE to FPREG
 5638/2775 : 50 E4                      	POP	R4
 5639/2777 : 50 E5                      	POP	R5		; Restore number from stack
 5640/2779 : 50 E6                      	POP	R6
 5641/277B : 50 E7                      	POP	R7
 5642/277D :                            NOSWAP:
 5643/277D : A6 E0 19                   	CP	R0,#24+1	; Second number insignificant?
 5644/2780 : 7B 01                      	JR	C,$+3
 5645/2782 : AF                         	RET			; Yes - First number is result
 5646/2783 : 18 FC                      	LD	R1,FLAGS
 5647/2785 : 70 E1                      	PUSH	R1
 5648/2787 : 70 E0                      	PUSH	R0		; Save number of bits to scale
 5649/2789 : D6 2C 34                   	CALL	SIGNS		; Set MSBs & sign of result
 5650/278C : 28 E0                      	LD	R2,R0		; Save sign of result
 5651/278E : 50 E0                      	POP	R0		; Restore scaling factor
 5652/2790 : 50 E1                      	POP	R1
 5653/2792 : 19 FC                      	LD	FLAGS,R1
 5654/2794 : D6 28 BA                   	CALL	SCALE		; Scale BCDE to same exponent
 5655/2797 : 42 02                      	OR	R0,R2
 5656/2799 : CF                         	RCF			; Result to be positive?
 5657/279A : 2C 81                      	LD	R2,#hi(FPREG)
 5658/279C : 3C 31                      	LD	R3,#lo(FPREG)	; Point to FPREG
 5659/279E : DD 27 B9                   	JP	PL,MINCDE	; No - Subtract FPREG from CDE
 5660/27A1 : D6 28 75                   	CALL	PLUCDE		; Add FPREG to CDE
 5661/27A4 : FD 28 3F                   	JP	NC,RONDUP	; No overflow - Round it up
 5662/27A7 : A0 E2                      	INCW	RR2		; Point to exponent
 5663/27A9 : C2 82                      	LDC	R8,@RR2
 5664/27AB : 8E                         	INC	R8
 5665/27AC : D2 82                      	LDC	@RR2,R8		; Increment it
 5666/27AE : 6D 05 13                   	JP	Z,OVERR		; Number overflowed - Error
 5667/27B1 : 3C 01                      	LD	R3,#1		; 1 bit to shift right
 5668/27B3 : D6 28 DC                   	CALL	SHRT1		; Shift result right
 5669/27B6 : 8D 28 3F                   	JP	RONDUP		; Round it up
 5670/27B9 :                            ;
 5671/27B9 :                            MINCDE:
 5672/27B9 : B2 00                      	XOR	R0,R0
 5673/27BB : CF                         	RCF			; Clear A and carry
 5674/27BC : 22 04                      	SUB	R0,R4		; Negate exponent
 5675/27BE : 48 E0                      	LD	R4,R0		; Re-save exponent
 5676/27C0 : C2 02                      	LDC	R0,@RR2		; Get LSB of FPREG
 5677/27C2 : 32 07                      	SBC	R0,R7		; Subtract LSB of BCDE
 5678/27C4 : 78 E0                      	LD	R7,R0		; Save LSB of BCDE
 5679/27C6 : 18 FC                      	LD	R1,FLAGS
 5680/27C8 : A0 E2                      	INCW	RR2
 5681/27CA : 19 FC                      	LD	FLAGS,R1
 5682/27CC : C2 02                      	LDC	R0,@RR2		; Get NMSB of FPREG
 5683/27CE : 32 06                      	SBC	R0,R6		; Subtract NMSB of BCDE
 5684/27D0 : 68 E0                      	LD	R6,R0		; Save NMSB of BCDE
 5685/27D2 : 18 FC                      	LD	R1,FLAGS
 5686/27D4 : A0 E2                      	INCW	RR2
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 96 - 2023/10/26 22時18分50秒


 5687/27D6 : 19 FC                      	LD	FLAGS,R1
 5688/27D8 : C2 02                      	LDC	R0,@RR2		; Get MSB of FPREG
 5689/27DA : 32 05                      	SBC	R0,R5		; Subtract MSB of BCDE
 5690/27DC : 58 E0                      	LD	R5,R0		; Save MSB of BCDE
 5691/27DE :                            CONPOS:
 5692/27DE : FB 03                      	JR	NC,$+5
 5693/27E0 : D6 28 94                   	CALL	COMPL		; Overflow - Make it positive
 5694/27E3 :                            ;
 5695/27E3 :                            BNORM:
 5696/27E3 : 38 E4                      	LD	R3,R4		; L = Exponent
 5697/27E5 : 28 E7                      	LD	R2,R7		; H = LSB
 5698/27E7 : B2 00                      	XOR	R0,R0
 5699/27E9 :                            ;	RCF
 5700/27E9 :                            BNRMLP:
 5701/27E9 : 48 E0                      	LD	R4,R0		; Save bit count
 5702/27EB : 08 E5                      	LD	R0,R5		; Get MSB
 5703/27ED : 42 00                      	OR	R0,R0		; Is it zero?
 5704/27EF : ED 28 21                   	JP	NZ,PNORM	; No - Do it bit at a time
 5705/27F2 : 58 E6                      	LD	R5,R6		; MSB = NMSB
 5706/27F4 : 68 E2                      	LD	R6,R2		; NMSB= LSB
 5707/27F6 : 28 E3                      	LD	R2,R3		; LSB = VLSB
 5708/27F8 : 38 E0                      	LD	R3,R0		; VLSB= 0
 5709/27FA : 08 E4                      	LD	R0,R4		; Get exponent
 5710/27FC : 26 E0 08                   	SUB	R0,#8		; Count 8 bits
 5711/27FF : A6 E0 E0                   	CP	R0,#0E0H	; -24-8 Was number zero?
 5712/2802 : ED 27 E9                   	JP	NZ,BNRMLP	; No - Keep normalising
 5713/2805 :                            RESZER:
 5714/2805 : B2 00                      	XOR	R0,R0		; Result is zero
 5715/2807 : CF                         	RCF
 5716/2808 :                            SAVEXP:
 5717/2808 : 8C 81                      	LD	R8,#hi(FPEXP)
 5718/280A : 9C 34                      	LD	R9,#lo(FPEXP)
 5719/280C : D2 08                      	LDC	@RR8,R0		; Save result as zero
 5720/280E : AF                         	RET
 5721/280F :                            ;
 5722/280F :                            NORMAL:
 5723/280F : 00 E4                      	DEC	R4		; Count bits
 5724/2811 : 02 33                      	ADD	R3,R3
 5725/2813 : 12 22                      	ADC	R2,R2		; Shift HL left
 5726/2815 : 08 E6                      	LD	R0,R6		; Get NMSB
 5727/2817 : 10 E0                      	RLC	R0		; Shift left with last bit
 5728/2819 : 68 E0                      	LD	R6,R0		; Save NMSB
 5729/281B : 08 E5                      	LD	R0,R5		; Get MSB
 5730/281D : 12 00                      	ADC	R0,R0		; Shift left with last bit
 5731/281F : 58 E0                      	LD	R5,R0		; Save MSB
 5732/2821 :                            PNORM:
 5733/2821 : DD 28 0F                   	JP	PL,NORMAL	; Not done - Keep going
 5734/2824 : 08 E4                      	LD	R0,R4		; Number of bits shifted
 5735/2826 : 78 E2                      	LD	R7,R2		; Save HL in EB
 5736/2828 : 48 E3                      	LD	R4,R3
 5737/282A : 42 00                      	OR	R0,R0		; Any shifting done?
 5738/282C : 6D 28 3F                   	JP	Z,RONDUP	; No - Round it up
 5739/282F : 2C 81                      	LD	R2,#hi(FPEXP)
 5740/2831 : 3C 34                      	LD	R3,#lo(FPEXP)	; Point to exponent
 5741/2833 : C2 82                      	LDC	R8,@RR2
 5742/2835 : 02 08                      	ADD	R0,R8		; Add shifted bits
 5743/2837 : D2 02                      	LDC	@RR2,R0		; Re-save exponent
 5744/2839 : FD 28 05                   	JP	NC,RESZER	; Underflow - Result is zero
 5745/283C : EB 01                      	JR	NZ,$+3
 5746/283E : AF                         	RET			; Result is zero
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 97 - 2023/10/26 22時18分50秒


 5747/283F :                            RONDUP:
 5748/283F : 08 E4                      	LD	R0,R4		; Get VLSB of number
 5749/2841 :                            RONDB:
 5750/2841 : 2C 81                      	LD	R2,#hi(FPEXP)
 5751/2843 : 3C 34                      	LD	R3,#lo(FPEXP)	; Point to exponent
 5752/2845 : 42 00                      	OR	R0,R0		; Any rounding?
 5753/2847 : DB 03                      	JR	PL,$+5
 5754/2849 : D6 28 5C                   	CALL	FPROND		; Yes - Round number up
 5755/284C : C2 42                      	LDC	R4,@RR2		; B = Exponent
 5756/284E : A0 E2                      	INCW	RR2
 5757/2850 : C2 02                      	LDC	R0,@RR2		; Get sign of result
 5758/2852 : 56 E0 80                   	AND	R0,#10000000B	; Only bit 7 needed
 5759/2855 : B2 05                      	XOR	R0,R5		; Set correct sign
 5760/2857 : 58 E0                      	LD	R5,R0		; Save correct sign in number
 5761/2859 : 8D 2B EE                   	JP	FPBCDE		; Move BCDE to FPREG
 5762/285C :                            ;
 5763/285C :                            FPROND:
 5764/285C : 7E                         	INC	R7		; Round LSB
 5765/285D : 6B 01                      	JR	Z,$+3
 5766/285F : AF                         	RET			; Return if ok
 5767/2860 : 6E                         	INC	R6		; Round NMSB
 5768/2861 : 6B 01                      	JR	Z,$+3
 5769/2863 : AF                         	RET			; Return if ok
 5770/2864 : 5E                         	INC	R5		; Round MSB
 5771/2865 : 6B 01                      	JR	Z,$+3
 5772/2867 : AF                         	RET			; Return if ok
 5773/2868 : 5C 80                      	LD	R5,#80H		; Set normal value
 5774/286A : C2 82                      	LDC	R8,@RR2
 5775/286C : 8E                         	INC	R8
 5776/286D : D2 82                      	LDC	@RR2,R8		; Increment exponent
 5777/286F : 6B 01                      	JR	Z,$+3
 5778/2871 : AF                         	RET			; Return if ok
 5779/2872 : 8D 05 13                   	JP	OVERR		; Overflow error
 5780/2875 :                            ;
 5781/2875 :                            PLUCDE:
 5782/2875 : C2 02                      	LDC	R0,@RR2		; Get LSB of FPREG
 5783/2877 : 02 07                      	ADD	R0,R7		; Add LSB of BCDE
 5784/2879 : 78 E0                      	LD	R7,R0		; Save LSB of BCDE
 5785/287B : 18 FC                      	LD	R1,FLAGS
 5786/287D : A0 E2                      	INCW	RR2
 5787/287F : 19 FC                      	LD	FLAGS,R1
 5788/2881 : C2 02                      	LDC	R0,@RR2		; Get NMSB of FPREG
 5789/2883 : 12 06                      	ADC	R0,R6		; Add NMSB of BCDE
 5790/2885 : 68 E0                      	LD	R6,R0		; Save NMSB of BCDE
 5791/2887 : 18 FC                      	LD	R1,FLAGS
 5792/2889 : A0 E2                      	INCW	RR2
 5793/288B : 19 FC                      	LD	FLAGS,R1
 5794/288D : C2 02                      	LDC	R0,@RR2		; Get MSB of FPREG
 5795/288F : 12 05                      	ADC	R0,R5		; Add MSB of BCDE
 5796/2891 : 58 E0                      	LD	R5,R0		; Save MSB of BCDE
 5797/2893 : AF                         	RET
 5798/2894 :                            ;
 5799/2894 :                            COMPL:
 5800/2894 : 2C 81                      	LD	R2,#hi(SGNRES)
 5801/2896 : 3C 35                      	LD	R3,#lo(SGNRES)	; Sign of result
 5802/2898 : C2 02                      	LDC	R0,@RR2		; Get sign of result
 5803/289A : 60 E0                      	COM	R0		; Negate it
 5804/289C : D2 02                      	LDC	@RR2,R0		; Put it back
 5805/289E : B2 00                      	XOR	R0,R0
 5806/28A0 : CF                         	RCF
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 98 - 2023/10/26 22時18分50秒


 5807/28A1 : 38 E0                      	LD	R3,R0		; Set L to zero
 5808/28A3 : 22 04                      	SUB	R0,R4		; Negate exponent,set carry
 5809/28A5 : 48 E0                      	LD	R4,R0		; Re-save exponent
 5810/28A7 : 08 E3                      	LD	R0,R3		; Load zero
 5811/28A9 : 32 07                      	SBC	R0,R7		; Negate LSB
 5812/28AB : 78 E0                      	LD	R7,R0		; Re-save LSB
 5813/28AD : 08 E3                      	LD	R0,R3		; Load zero
 5814/28AF : 32 06                      	SBC	R0,R6		; Negate NMSB
 5815/28B1 : 68 E0                      	LD	R6,R0		; Re-save NMSB
 5816/28B3 : 08 E3                      	LD	R0,R3		; Load zero
 5817/28B5 : 32 05                      	SBC	R0,R5		; Negate MSB
 5818/28B7 : 58 E0                      	LD	R5,R0		; Re-save MSB
 5819/28B9 : AF                         	RET
 5820/28BA :                            ;
 5821/28BA :                            SCALE:
 5822/28BA : 4C 00                      	LD	R4,#0		; Clear underflow
 5823/28BC :                            SCALLP:
 5824/28BC : 26 E0 08                   	SUB	R0,#8		; 8 bits (a whole byte)?
 5825/28BF : 7D 28 CD                   	JP	C,SHRITE	; No - Shift right A bits
 5826/28C2 : 48 E7                      	LD	R4,R7		; <- Shift
 5827/28C4 : 78 E6                      	LD	R7,R6		; <- right
 5828/28C6 : 68 E5                      	LD	R6,R5		; <- eight
 5829/28C8 : 5C 00                      	LD	R5,#0		; <- bits
 5830/28CA : 8D 28 BC                   	JP	SCALLP		; More bits to shift
 5831/28CD :                            ;
 5832/28CD :                            SHRITE:
 5833/28CD : 06 E0 09                   	ADD	R0,#8+1		; Adjust count
 5834/28D0 : 38 E0                      	LD	R3,R0		; Save bits to shift
 5835/28D2 :                            SHRLP:
 5836/28D2 : B2 00                      	XOR	R0,R0
 5837/28D4 : CF                         	RCF			; Flag for all done
 5838/28D5 : 00 E3                      	DEC	R3		; All shifting done?
 5839/28D7 : EB 01                      	JR	NZ,$+3
 5840/28D9 : AF                         	RET			; Yes - Return
 5841/28DA : 08 E5                      	LD	R0,R5		; Get MSB
 5842/28DC :                            SHRT1:
 5843/28DC :                            ;	RRC	R0		; Shift it right
 5844/28DC :                            ;	LD	R5,R0		; Re-save
 5845/28DC :                            ;	LD	R0,R6		; Get NMSB
 5846/28DC :                            ;	RRC	R0		; Shift right with last bit
 5847/28DC :                            ;	LD	R6,R0		; Re-save it
 5848/28DC :                            ;	LD	R0,R7		; Get LSB
 5849/28DC :                            ;	RRC	R0		; Shift right with last bit
 5850/28DC :                            ;	LD	R7,R0		; Re-save it
 5851/28DC :                            ;	LD	R0,R4		; Get underflow
 5852/28DC :                            ;	RRC	R0		; Shift right with last bit
 5853/28DC :                            ;	LD	R4,R0		; Re-save underflow
 5854/28DC :                            ;	JP	SHRLP		; More bits to do
 5855/28DC :                            
 5856/28DC : C0 E0                      	RRC	R0		; Shift it right
 5857/28DE : 58 E0                      	LD	R5,R0		; Re-save
 5858/28E0 : C0 E6                      	RRC	R6		; Shift NMSB right with last bit
 5859/28E2 : C0 E7                      	RRC	R7		; Shift LSB right with last bit
 5860/28E4 : C0 E4                      	RRC	R4		; Shift underflow right with last bit
 5861/28E6 : 8D 28 D2                   	JP	SHRLP		; More bits to do
 5862/28E9 :                            
 5863/28E9 :                            ;
 5864/28E9 :                            UNITY:
 5865/28E9 : 00 00 00 81                	DB	 000H,000H,000H,081H	; 1.00000
 5866/28ED :                            ;
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 99 - 2023/10/26 22時18分50秒


 5867/28ED :                            LOGTAB:
 5868/28ED : 03                         	DB	3			; Table used by LOG
 5869/28EE : AA 56 19 80                	DB	0AAH,056H,019H,080H	; 0.59898
 5870/28F2 : F1 22 76 80                	DB	0F1H,022H,076H,080H	; 0.96147
 5871/28F6 : 45 AA 38 82                	DB	045H,0AAH,038H,082H	; 2.88539
 5872/28FA :                            ;
 5873/28FA :                            LOG:
 5874/28FA : D6 2B 76                   	CALL	TSTSGN		; Test sign of value
 5875/28FD :                            ; OR	A
 5876/28FD :                            ; JP	PE,FCERR		; ?FC Error if <= zero
 5877/28FD :                            
 5878/28FD : 18 E0                      	LD	R1,R0
 5879/28FF : C0 E1                      	RRC	R1
 5880/2901 : C0 E1                      	RRC	R1
 5881/2903 : C0 E1                      	RRC	R1
 5882/2905 : C0 E1                      	RRC	R1
 5883/2907 : B2 10                      	XOR	R1,R0
 5884/2909 : 88 E1                      	LD	R8,R1
 5885/290B : C0 E1                      	RRC	R1
 5886/290D : C0 E1                      	RRC	R1
 5887/290F : B2 18                      	XOR	R1,R8
 5888/2911 : 88 E1                      	LD	R8,R1
 5889/2913 : C0 E1                      	RRC	R1
 5890/2915 : B2 18                      	XOR	R1,R8
 5891/2917 : 56 E1 01                   	AND	R1,#01H
 5892/291A : 6D 0F 7B                   	JP	Z,FCERR
 5893/291D :                            
 5894/291D : 2C 81                      	LD	R2,#hi(FPEXP)
 5895/291F : 3C 34                      	LD	R3,#lo(FPEXP)	; Point to exponent
 5896/2921 : C2 02                      	LDC	R0,@RR2		; Get exponent
 5897/2923 : 4C 80                      	LD	R4,#hi(8035H)
 5898/2925 : 5C 35                      	LD	R5,#lo(8035H)	; BCDE = SQR(1/2)
 5899/2927 : 6C 04                      	LD	R6,#hi(04F3H)
 5900/2929 : 7C F3                      	LD	R7,#lo(04F3H)
 5901/292B : 22 04                      	SUB	R0,R4		; Scale value to be < 1
 5902/292D : 18 FC                      	LD	R1,FLAGS
 5903/292F : 70 E1                      	PUSH	R1
 5904/2931 : 70 E0                      	PUSH	R0		; Save scale factor
 5905/2933 : D2 42                      	LDC	@RR2,R4		; Save new exponent
 5906/2935 : 70 E7                      	PUSH	R7
 5907/2937 : 70 E6                      	PUSH	R6		; Save SQR(1/2)
 5908/2939 : 70 E5                      	PUSH	R5
 5909/293B : 70 E4                      	PUSH	R4
 5910/293D : D6 27 3B                   	CALL	FPADD		; Add SQR(1/2) to value
 5911/2940 : 50 E4                      	POP	R4
 5912/2942 : 50 E5                      	POP	R5		; Restore SQR(1/2)
 5913/2944 : 50 E6                      	POP	R6
 5914/2946 : 50 E7                      	POP	R7
 5915/2948 : 4E                         	INC	R4		; Make it SQR(2)
 5916/2949 : D6 2A 40                   	CALL	DVBCDE		; Divide by SQR(2)
 5917/294C : 2C 28                      	LD	R2,#hi(UNITY)
 5918/294E : 3C E9                      	LD	R3,#lo(UNITY)	; Point to 1.
 5919/2950 : D6 27 2B                   	CALL	SUBPHL		; Subtract FPREG from 1
 5920/2953 : 2C 28                      	LD	R2,#hi(LOGTAB)
 5921/2955 : 3C ED                      	LD	R3,#lo(LOGTAB)	; Coefficient table
 5922/2957 : D6 31 D0                   	CALL	SUMSER		; Evaluate sum of series
 5923/295A : 4C 80                      	LD	R4,#hi(8080H)
 5924/295C : 5C 80                      	LD	R5,#lo(8080H)	; BCDE = -0.5
 5925/295E : 6C 00                      	LD	R6,#hi(0000H)
 5926/2960 : 7C 00                      	LD	R7,#lo(0000H)
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 100 - 2023/10/26 22時18分50秒


 5927/2962 : D6 27 3B                   	CALL	FPADD		; Subtract 0.5 from FPREG
 5928/2965 : 50 E0                      	POP	R0		; Restore scale factor
 5929/2967 : 50 E1                      	POP	R1
 5930/2969 : 19 FC                      	LD	FLAGS,R1
 5931/296B : D6 2E 57                   	CALL	RSCALE		; Re-scale number
 5932/296E :                            MULLN2:
 5933/296E : 4C 80                      	LD	R4,#hi(8031H)
 5934/2970 : 5C 31                      	LD	R5,#lo(8031H)	; BCDE = Ln(2)
 5935/2972 : 6C 72                      	LD	R6,#hi(7218H)
 5936/2974 : 7C 18                      	LD	R7,#lo(7218H)
 5937/2976 : 8B 08                      	JR	FPMULT		; Skip "POP BC" and "POP DE"
 5938/2978 :                            ;
 5939/2978 :                            MULT:
 5940/2978 : 50 E4                      	POP	R4
 5941/297A : 50 E5                      	POP	R5		; Get number from stack
 5942/297C : 50 E6                      	POP	R6
 5943/297E : 50 E7                      	POP	R7
 5944/2980 :                            FPMULT:
 5945/2980 : D6 2B 76                   	CALL	TSTSGN		; Test sign of FPREG
 5946/2983 : EB 01                      	JR	NZ,$+3
 5947/2985 : AF                         	RET			; Return zero if zero
 5948/2986 : 3C 00                      	LD	R3,#0		; Flag add exponents
 5949/2988 : D6 2B 08                   	CALL	ADDEXP		; Add exponents
 5950/298B : 08 E5                      	LD	R0,R5		; Get MSB of multiplier
 5951/298D : 8C 81                      	LD	R8,#hi(MULVAL)
 5952/298F : 9C 43                      	LD	R9,#lo(MULVAL)
 5953/2991 : D2 08                      	LDC	@RR8,R0		; Save MSB of multiplier
 5954/2993 : 88 E6                      	LD	R8,R6
 5955/2995 : 98 E7                      	LD	R9,R7
 5956/2997 : 68 E2                      	LD	R6,R2
 5957/2999 : 78 E3                      	LD	R7,R3
 5958/299B : 28 E8                      	LD	R2,R8
 5959/299D : 38 E9                      	LD	R3,R9
 5960/299F : 8C 81                      	LD	R8,#hi(MULVAL+1); @@
 5961/29A1 : 9C 44                      	LD	R9,#lo(MULVAL+1)
 5962/29A3 : D2 28                      	LDC	@RR8,R2
 5963/29A5 : A0 E8                      	INCW	RR8
 5964/29A7 : D2 38                      	LDC	@RR8,R3		; Save rest of multiplier
 5965/29A9 : 4C 00                      	LD	R4,#hi(0)
 5966/29AB : 5C 00                      	LD	R5,#lo(0)	; Partial product (BCDE) = zero
 5967/29AD : 68 E4                      	LD	R6,R4
 5968/29AF : 78 E4                      	LD	R7,R4
 5969/29B1 : 2C 27                      	LD	R2,#hi(BNORM)
 5970/29B3 : 3C E3                      	LD	R3,#lo(BNORM)	; Address of normalise
 5971/29B5 : 70 E3                      	PUSH	R3
 5972/29B7 : 70 E2                      	PUSH	R2		; Save for return
 5973/29B9 : 2C 29                      	LD	R2,#hi(MULT8)
 5974/29BB : 3C C9                      	LD	R3,#lo(MULT8)	; Address of 8 bit multiply
 5975/29BD : 70 E3                      	PUSH	R3
 5976/29BF : 70 E2                      	PUSH	R2		; Save for NMSB,MSB
 5977/29C1 : 70 E3                      	PUSH	R3
 5978/29C3 : 70 E2                      	PUSH	R2		;
 5979/29C5 : 2C 81                      	LD	R2,#hi(FPREG)
 5980/29C7 : 3C 31                      	LD	R3,#lo(FPREG)	; Point to number
 5981/29C9 :                            MULT8:
 5982/29C9 : C2 02                      	LDC	R0,@RR2		; Get LSB of number
 5983/29CB : A0 E2                      	INCW	RR2		; Point to NMSB
 5984/29CD : 42 00                      	OR	R0,R0		; Test LSB
 5985/29CF : 6D 2A 21                   	JP	Z,BYTSFT	; Zero - shift to next byte
 5986/29D2 : 70 E3                      	PUSH	R3
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 101 - 2023/10/26 22時18分50秒


 5987/29D4 : 70 E2                      	PUSH	R2		; Save address of number
 5988/29D6 : 3C 08                      	LD	R3,#8		; 8 bits to multiply by
 5989/29D8 :                            MUL8LP:
 5990/29D8 : C0 E0                      	RRC	R0		; Shift LSB right
 5991/29DA : 28 E0                      	LD	R2,R0		; Save LSB
 5992/29DC : 08 E5                      	LD	R0,R5		; Get MSB
 5993/29DE : FD 2A 0B                   	JP	NC,NOMADD	; Bit was zero - Don't add
 5994/29E1 : 70 E3                      	PUSH	R3
 5995/29E3 : 70 E2                      	PUSH	R2		; Save LSB and count
 5996/29E5 : 8C 81                      	LD	R8,#hi(MULVAL+1)
 5997/29E7 : 9C 44                      	LD	R9,#lo(MULVAL+1)
 5998/29E9 : C2 28                      	LDC	R2,@RR8
 5999/29EB : A0 E8                      	INCW	RR8
 6000/29ED : C2 38                      	LDC	R3,@RR8		; Get LSB and NMSB
 6001/29EF : 02 37                      	ADD	R3,R7
 6002/29F1 : 12 26                      	ADC	R2,R6		; Add NMSB and LSB
 6003/29F3 : 88 E6                      	LD	R8,R6
 6004/29F5 : 98 E7                      	LD	R9,R7
 6005/29F7 : 68 E2                      	LD	R6,R2
 6006/29F9 : 78 E3                      	LD	R7,R3
 6007/29FB : 28 E8                      	LD	R2,R8
 6008/29FD : 38 E9                      	LD	R3,R9		; Leave sum in DE
 6009/29FF : 50 E2                      	POP	R2
 6010/2A01 : 50 E3                      	POP	R3		; Restore MSB and count
 6011/2A03 : 8C 81                      	LD	R8,#hi(MULVAL)
 6012/2A05 : 9C 43                      	LD	R9,#lo(MULVAL)
 6013/2A07 : C2 08                      	LDC	R0,@RR8		; Get MSB of multiplier
 6014/2A09 : 12 05                      	ADC	R0,R5		; Add MSB
 6015/2A0B :                            NOMADD:
 6016/2A0B :                            ;	RRC	R0		; Shift MSB right
 6017/2A0B :                            ;	LD	R5,R0		; Re-save MSB
 6018/2A0B :                            ;	LD	R0,R6		; Get NMSB
 6019/2A0B :                            ;	RRC	R0		; Shift NMSB right
 6020/2A0B :                            ;	LD	R6,R0		; Re-save NMSB
 6021/2A0B :                            ;	LD	R0,R7		; Get LSB
 6022/2A0B :                            ;	RRC	R0		; Shift LSB right
 6023/2A0B :                            ;	LD	R7,R0		; Re-save LSB
 6024/2A0B :                            ;	LD	R0,R4		; Get VLSB
 6025/2A0B :                            ;	RRC	R0		; Shift VLSB right
 6026/2A0B :                            ;	LD	R4,R0		; Re-save VLSB
 6027/2A0B :                            ;	DEC	R3		; Count bits multiplied
 6028/2A0B :                            ;	LD	R0,R2		; Get LSB of multiplier
 6029/2A0B :                            ;	JP	NZ,MUL8LP	; More - Do it
 6030/2A0B :                            
 6031/2A0B : C0 E0                      	RRC	R0		; Shift MSB right
 6032/2A0D : 58 E0                      	LD	R5,R0		; Re-save MSB
 6033/2A0F : C0 E6                      	RRC	R6		; Shift NMSB right
 6034/2A11 : C0 E7                      	RRC	R7		; Shift LSB right
 6035/2A13 : C0 E4                      	RRC	R4		; Shift VLSB right
 6036/2A15 : 00 E3                      	DEC	R3		; Count bits multiplied
 6037/2A17 : 08 E2                      	LD	R0,R2		; Get LSB of multiplier
 6038/2A19 : ED 29 D8                   	JP	NZ,MUL8LP	; More - Do it
 6039/2A1C :                            
 6040/2A1C :                            POPHRT:
 6041/2A1C : 50 E2                      	POP	R2
 6042/2A1E : 50 E3                      	POP	R3		; Restore address of number
 6043/2A20 : AF                         	RET
 6044/2A21 :                            ;
 6045/2A21 :                            BYTSFT:
 6046/2A21 : 48 E7                      	LD	R4,R7		; Shift partial product left
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 102 - 2023/10/26 22時18分50秒


 6047/2A23 : 78 E6                      	LD	R7,R6
 6048/2A25 : 68 E5                      	LD	R6,R5
 6049/2A27 : 58 E0                      	LD	R5,R0
 6050/2A29 : AF                         	RET
 6051/2A2A :                            ;
 6052/2A2A :                            DIV10:
 6053/2A2A : D6 2B C8                   	CALL	STAKFP		; Save FPREG on stack
 6054/2A2D : 4C 84                      	LD	R4,#hi(8420H)
 6055/2A2F : 5C 20                      	LD	R5,#lo(8420H)	; BCDE = 10.
 6056/2A31 : 6C 00                      	LD	R6,#hi(0000H)
 6057/2A33 : 7C 00                      	LD	R7,#lo(0000H)
 6058/2A35 : D6 2B EE                   	CALL	FPBCDE		; Move 10 to FPREG
 6059/2A38 :                            ;
 6060/2A38 :                            DIV:
 6061/2A38 : 50 E4                      	POP	R4
 6062/2A3A : 50 E5                      	POP	R5		; Get number from stack
 6063/2A3C : 50 E6                      	POP	R6
 6064/2A3E : 50 E7                      	POP	R7
 6065/2A40 :                            DVBCDE:
 6066/2A40 : D6 2B 76                   	CALL	TSTSGN		; Test sign of FPREG
 6067/2A43 : 6D 05 03                   	JP	Z,DZERR		; Error if division by zero
 6068/2A46 : 3C FF                      	LD	R3,#-1		; Flag subtract exponents
 6069/2A48 : D6 2B 08                   	CALL	ADDEXP		; Subtract exponents
 6070/2A4B : C2 82                      	LDC	R8,@RR2
 6071/2A4D : 8E                         	INC	R8
 6072/2A4E : D2 82                      	LDC	@RR2,R8		; Add 2 to exponent to adjust
 6073/2A50 : C2 82                      	LDC	R8,@RR2
 6074/2A52 : 8E                         	INC	R8
 6075/2A53 : D2 82                      	LDC	@RR2,R8
 6076/2A55 : 80 E2                      	DECW	RR2		; Point to MSB
 6077/2A57 : C2 02                      	LDC	R0,@RR2		; Get MSB of dividend
 6078/2A59 : 8C 80                      	LD	R8,#hi(DIV3)
 6079/2A5B : 9C 5E                      	LD	R9,#lo(DIV3)
 6080/2A5D : D2 08                      	LDC	@RR8,R0		; Save for subtraction
 6081/2A5F : 80 E2                      	DECW	RR2
 6082/2A61 : C2 02                      	LDC	R0,@RR2		; Get NMSB of dividend
 6083/2A63 : 8C 80                      	LD	R8,#hi(DIV2)
 6084/2A65 : 9C 57                      	LD	R9,#lo(DIV2)
 6085/2A67 : D2 08                      	LDC	@RR8,R0		; Save for subtraction
 6086/2A69 : 80 E2                      	DECW	RR2
 6087/2A6B : C2 02                      	LDC	R0,@RR2		; Get MSB of dividend
 6088/2A6D : 8C 80                      	LD	R8,#hi(DIV1)
 6089/2A6F : 9C 50                      	LD	R9,#lo(DIV1)
 6090/2A71 : D2 08                      	LDC	@RR8,R0		; Save for subtraction
 6091/2A73 : 48 E5                      	LD	R4,R5		; Get MSB
 6092/2A75 : 88 E6                      	LD	R8,R6
 6093/2A77 : 98 E7                      	LD	R9,R7
 6094/2A79 : 68 E2                      	LD	R6,R2
 6095/2A7B : 78 E3                      	LD	R7,R3
 6096/2A7D : 28 E8                      	LD	R2,R8
 6097/2A7F : 38 E9                      	LD	R3,R9		; NMSB,LSB to HL
 6098/2A81 : B2 00                      	XOR	R0,R0
 6099/2A83 : 58 E0                      	LD	R5,R0		; Clear MSB of quotient
 6100/2A85 : 68 E0                      	LD	R6,R0		; Clear NMSB of quotient
 6101/2A87 : 78 E0                      	LD	R7,R0		; Clear LSB of quotient
 6102/2A89 : 8C 80                      	LD	R8,#hi(DIV4)
 6103/2A8B : 9C 62                      	LD	R9,#lo(DIV4)
 6104/2A8D : D2 08                      	LDC	@RR8,R0		; Clear overflow count
 6105/2A8F :                            DIVLP:
 6106/2A8F : 70 E3                      	PUSH	R3
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 103 - 2023/10/26 22時18分50秒


 6107/2A91 : 70 E2                      	PUSH	R2		; Save divisor
 6108/2A93 : 70 E5                      	PUSH	R5
 6109/2A95 : 70 E4                      	PUSH	R4
 6110/2A97 : 08 E3                      	LD	R0,R3		; Get LSB of number
 6111/2A99 : D6 80 4E                   	CALL	DIVSUP		; Subt' divisor from dividend
 6112/2A9C : 36 E0 00                   	SBC	R0,#0		; Count for overflows
 6113/2A9F : EF                         	CCF
 6114/2AA0 : FD 2A B6                   	JP	NC,RESDIV	; Restore divisor if borrow
 6115/2AA3 : 8C 80                      	LD	R8,#hi(DIV4)
 6116/2AA5 : 9C 62                      	LD	R9,#lo(DIV4)
 6117/2AA7 : D2 08                      	LDC	@RR8,R0		; Re-save overflow count
 6118/2AA9 : 50 E0                      	POP	R0		; Scrap divisor
 6119/2AAB : 50 E1                      	POP	R1
 6120/2AAD : 50 E0                      	POP	R0
 6121/2AAF : 50 E1                      	POP	R1
 6122/2AB1 : 19 FC                      	LD	FLAGS,R1
 6123/2AB3 : DF                         	SCF			; Set carry to
 6124/2AB4 : 8B 08                      	JR	RESDIV1		; Skip "POP BC" and "POP HL"
 6125/2AB6 :                            ;
 6126/2AB6 :                            RESDIV:
 6127/2AB6 : 50 E4                      	POP	R4
 6128/2AB8 : 50 E5                      	POP	R5		; Restore divisor
 6129/2ABA : 50 E2                      	POP	R2
 6130/2ABC : 50 E3                      	POP	R3
 6131/2ABE :                            RESDIV1:
 6132/2ABE : 08 E5                      	LD	R0,R5		; Get MSB of quotient
 6133/2AC0 : 0E                         	INC	R0
 6134/2AC1 : 00 E0                      	DEC	R0
 6135/2AC3 :                            ;	RRC	R0		; Bit 0 to bit 7
 6136/2AC3 :                            ;	JP	MI,RONDB	; Done - Normalise result
 6137/2AC3 :                            ;	RLC	R0		; Restore carry
 6138/2AC3 : DB 05                      	JR	PL,RESDIV2
 6139/2AC5 : C0 E0                      	RRC	R0		; Bit 0 to bit 7
 6140/2AC7 : 8D 28 41                   	JP	RONDB		; Done - Normalise result
 6141/2ACA :                            RESDIV2:
 6142/2ACA : C0 E0                      	RRC	R0		; Bit 0 to bit 7
 6143/2ACC : 10 E0                      	RLC	R0		; Restore carry
 6144/2ACE :                            
 6145/2ACE :                            ;	LD	R0,R7		; Get LSB of quotient
 6146/2ACE :                            ;	RLC	R0		; Double it
 6147/2ACE :                            ;	LD	R7,R0		; Put it back
 6148/2ACE :                            ;	LD	R0,R6		; Get NMSB of quotient
 6149/2ACE :                            ;	RLC	R0		; Double it
 6150/2ACE :                            ;	LD	R6,R0		; Put it back
 6151/2ACE :                            ;	LD	R0,R5		; Get MSB of quotient
 6152/2ACE :                            ;	RLC	R0		; Double it
 6153/2ACE :                            ;	LD	R5,R0		; Put it back
 6154/2ACE : 10 E7                      	RLC	R7		; Double LSB of quotient
 6155/2AD0 : 10 E6                      	RLC	R6		; Double NMSB of quotient
 6156/2AD2 : 10 E5                      	RLC	R5		; Double MSB of quotient
 6157/2AD4 : 02 33                      	ADD	R3,R3
 6158/2AD6 : 12 22                      	ADC	R2,R2		; Double NMSB,LSB of divisor
 6159/2AD8 : 08 E4                      	LD	R0,R4		; Get MSB of divisor
 6160/2ADA : 10 E4                      	RLC	R4		; Double MSB of divisor
 6161/2ADC :                            
 6162/2ADC : 8C 80                      	LD	R8,#hi(DIV4)
 6163/2ADE : 9C 62                      	LD	R9,#lo(DIV4)
 6164/2AE0 : C2 08                      	LDC	R0,@RR8		; Get VLSB of quotient
 6165/2AE2 : 10 E0                      	RLC	R0		; Double it
 6166/2AE4 : D2 08                      	LDC	@RR8,R0		; Put it back
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 104 - 2023/10/26 22時18分50秒


 6167/2AE6 : 08 E5                      	LD	R0,R5		; Get MSB of quotient
 6168/2AE8 : 42 06                      	OR	R0,R6		; Merge NMSB
 6169/2AEA : 42 07                      	OR	R0,R7		; Merge LSB
 6170/2AEC : CF                         	RCF
 6171/2AED : ED 2A 8F                   	JP	NZ,DIVLP	; Not done - Keep dividing
 6172/2AF0 : 70 E3                      	PUSH	R3
 6173/2AF2 : 70 E2                      	PUSH	R2		; Save divisor
 6174/2AF4 : 2C 81                      	LD	R2,#hi(FPEXP)
 6175/2AF6 : 3C 34                      	LD	R3,#lo(FPEXP)	; Point to exponent
 6176/2AF8 : C2 82                      	LDC	R8,@RR2
 6177/2AFA : 00 E8                      	DEC	R8
 6178/2AFC : D2 82                      	LDC	@RR2,R8		; Divide by 2
 6179/2AFE : 50 E2                      	POP	R2
 6180/2B00 : 50 E3                      	POP	R3		; Restore divisor
 6181/2B02 : ED 2A 8F                   	JP	NZ,DIVLP	; Ok - Keep going
 6182/2B05 : 8D 05 13                   	JP	OVERR		; Overflow error
 6183/2B08 :                            
 6184/2B08 :                            ;
 6185/2B08 :                            ADDEXP:
 6186/2B08 : 08 E4                      	LD	R0,R4		; Get exponent of dividend
 6187/2B0A : 42 00                      	OR	R0,R0
 6188/2B0C : CF                         	RCF			; Test it
 6189/2B0D : 6D 2B 47                   	JP	Z,OVTST3	; Zero - Result zero
 6190/2B10 : 08 E3                      	LD	R0,R3		; Get add/subtract flag
 6191/2B12 : 2C 81                      	LD	R2,#hi(FPEXP)
 6192/2B14 : 3C 34                      	LD	R3,#lo(FPEXP)	; Point to exponent
 6193/2B16 : C2 82                      	LDC	R8,@RR2
 6194/2B18 : B2 08                      	XOR	R0,R8		; Add or subtract it
 6195/2B1A : 02 04                      	ADD	R0,R4		; Add the other exponent
 6196/2B1C : 48 E0                      	LD	R4,R0		; Save new exponent
 6197/2B1E : C0 E0                      	RRC	R0			; Test exponent for overflow
 6198/2B20 : B2 04                      	XOR	R0,R4
 6199/2B22 : 08 E4                      	LD	R0,R4		; Get exponent
 6200/2B24 : DD 2B 44                   	JP	PL,OVTST2	; Positive - Test for overflow
 6201/2B27 : 06 E0 80                   	ADD	R0,#80H		; Add excess 128
 6202/2B2A : D2 02                      	LDC	@RR2,R0		; Save new exponent
 6203/2B2C : 6D 2A 1C                   	JP	Z,POPHRT	; Zero - Result zero
 6204/2B2F : D6 2C 34                   	CALL	SIGNS		; Set MSBs and sign of result
 6205/2B32 : D2 02                      	LDC	@RR2,R0		; Save new exponent
 6206/2B34 : 18 FC                      	LD	R1,FLAGS
 6207/2B36 : 80 E2                      	DECW	RR2		; Point to MSB
 6208/2B38 : 19 FC                      	LD	FLAGS,R1
 6209/2B3A : AF                         	RET
 6210/2B3B :                            ;
 6211/2B3B :                            OVTST1:
 6212/2B3B : D6 2B 76                   	CALL	TSTSGN		; Test sign of FPREG
 6213/2B3E : 60 E0                      	COM	R0		; Invert sign
 6214/2B40 : 50 E2                      	POP	R2
 6215/2B42 : 50 E3                      	POP	R3		; Clean up stack
 6216/2B44 :                            OVTST2:
 6217/2B44 : 42 00                      	OR	R0,R0
 6218/2B46 : CF                         	RCF			; Test if new exponent zero
 6219/2B47 :                            OVTST3:
 6220/2B47 : 50 E2                      	POP	R2
 6221/2B49 : 50 E3                      	POP	R3		; Clear off return address
 6222/2B4B : DD 28 05                   	JP	PL,RESZER	; Result zero
 6223/2B4E : 8D 05 13                   	JP	OVERR		; Overflow error
 6224/2B51 :                            ;
 6225/2B51 :                            MLSP10:
 6226/2B51 : D6 2C 03                   	CALL	BCDEFP		; Move FPREG to BCDE
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 105 - 2023/10/26 22時18分50秒


 6227/2B54 : 08 E4                      	LD	R0,R4		; Get exponent
 6228/2B56 : 42 00                      	OR	R0,R0
 6229/2B58 : CF                         	RCF			; Is it zero?
 6230/2B59 : EB 01                      	JR	NZ,$+3
 6231/2B5B : AF                         	RET			; Yes - Result is zero
 6232/2B5C : 06 E0 02                   	ADD	R0,#2		; Multiply by 4
 6233/2B5F : 7D 05 13                   	JP	C,OVERR		; Overflow - ?OV Error
 6234/2B62 : 48 E0                      	LD	R4,R0		; Re-save exponent
 6235/2B64 : D6 27 3B                   	CALL	FPADD		; Add BCDE to FPREG (Times 5)
 6236/2B67 : 2C 81                      	LD	R2,#hi(FPEXP)
 6237/2B69 : 3C 34                      	LD	R3,#lo(FPEXP)	; Point to exponent
 6238/2B6B : C2 82                      	LDC	R8,@RR2
 6239/2B6D : 8E                         	INC	R8
 6240/2B6E : D2 82                      	LDC	@RR2,R8		; Double number (Times 10)
 6241/2B70 : 6B 01                      	JR	Z,$+3
 6242/2B72 : AF                         	RET			; Ok - Return
 6243/2B73 : 8D 05 13                   	JP	OVERR		; Overflow error
 6244/2B76 :                            ;
 6245/2B76 :                            TSTSGN:
 6246/2B76 : 8C 81                      	LD	R8,#hi(FPEXP)
 6247/2B78 : 9C 34                      	LD	R9,#lo(FPEXP)
 6248/2B7A : C2 08                      	LDC	R0,@RR8		; Get sign of FPREG
 6249/2B7C : 42 00                      	OR	R0,R0
 6250/2B7E : CF                         	RCF
 6251/2B7F : EB 01                      	JR	NZ,$+3
 6252/2B81 : AF                         	RET			; RETurn if number is zero
 6253/2B82 : 8C 81                      	LD	R8,#hi(FPREG+2)
 6254/2B84 : 9C 33                      	LD	R9,#lo(FPREG+2)
 6255/2B86 : C2 08                      	LDC	R0,@RR8		; Get MSB of FPREG
 6256/2B88 : A6 E0 2F                   	CP	R0,#'/'		; Test sign
 6257/2B8B : 8B 02                      	JR	RETREL1
 6258/2B8D :                            RETREL:
 6259/2B8D : 60 E0                      	COM	R0		; Invert sign
 6260/2B8F :                            RETREL1:
 6261/2B8F : 10 E0                      	RLC	R0		; Sign bit to carry
 6262/2B91 :                            FLGDIF:
 6263/2B91 : 32 00                      	SBC	R0,R0		; Carry to all bits of A
 6264/2B93 : 6B 01                      	JR	Z,$+3
 6265/2B95 : AF                         	RET			; Return -1 if negative
 6266/2B96 : 0E                         	INC	R0		; Bump to +1
 6267/2B97 : AF                         	RET			; Positive - Return +1
 6268/2B98 :                            ;
 6269/2B98 :                            SGN:
 6270/2B98 : D6 2B 76                   	CALL	TSTSGN		; Test sign of FPREG
 6271/2B9B :                            FLGREL:
 6272/2B9B : 4C 88                      	LD	R4,#80H+8	; 8 bit integer in exponent
 6273/2B9D : 6C 00                      	LD	R6,#hi(0)
 6274/2B9F : 7C 00                      	LD	R7,#lo(0)	; Zero NMSB and LSB
 6275/2BA1 :                            RETINT:
 6276/2BA1 : 2C 81                      	LD	R2,#hi(FPEXP)
 6277/2BA3 : 3C 34                      	LD	R3,#lo(FPEXP)	; Point to exponent
 6278/2BA5 : 58 E0                      	LD	R5,R0		; CDE = MSB,NMSB and LSB
 6279/2BA7 : D2 42                      	LDC	@RR2,R4		; Save exponent
 6280/2BA9 : 4C 00                      	LD	R4,#0		; CDE = integer to normalise
 6281/2BAB : A0 E2                      	INCW	RR2		; Point to sign of result
 6282/2BAD : 1C 80                      	LD	R1,#80H
 6283/2BAF : D2 12                      	LDC	@RR2,R1		; Set sign of result
 6284/2BB1 : 10 E0                      	RLC	R0		; Carry = sign of integer
 6285/2BB3 : 8D 27 DE                   	JP	CONPOS		; Set sign of result
 6286/2BB6 :                            ;
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 106 - 2023/10/26 22時18分50秒


 6287/2BB6 :                            ABS:
 6288/2BB6 : D6 2B 76                   	CALL	TSTSGN		; Test sign of FPREG
 6289/2BB9 : 5B 01                      	JR	MI,$+3
 6290/2BBB : AF                         	RET			; Return if positive
 6291/2BBC :                            INVSGN:
 6292/2BBC : 2C 81                      	LD	R2,#hi(FPREG+2)
 6293/2BBE : 3C 33                      	LD	R3,#lo(FPREG+2)	; Point to MSB
 6294/2BC0 : C2 02                      	LDC	R0,@RR2		; Get sign of mantissa
 6295/2BC2 : B6 E0 80                   	XOR	R0,#80H		; Invert sign of mantissa
 6296/2BC5 : D2 02                      	LDC	@RR2,R0		; Re-save sign of mantissa
 6297/2BC7 : AF                         	RET
 6298/2BC8 :                            ;
 6299/2BC8 :                            STAKFP:
 6300/2BC8 :                            ;	LD	R8,R6
 6301/2BC8 :                            ;	LD	R9,R7
 6302/2BC8 :                            ;	LD	R6,R2
 6303/2BC8 :                            ;	LD	R7,R3
 6304/2BC8 :                            ;	LD	R2,R8
 6305/2BC8 :                            ;	LD	R3,R9		; Save code string address
 6306/2BC8 :                            ;	LD	R8,#hi(FPREG)
 6307/2BC8 :                            ;	LD	R9,#lo(FPREG)
 6308/2BC8 :                            ;	LDC	R3,@RR8		; @@@ SWAP HL
 6309/2BC8 :                            ;	INCW	RR8
 6310/2BC8 :                            ;	LDC	R2,@RR8		; LSB,NLSB of FPREG
 6311/2BC8 :                            ;
 6312/2BC8 :                            ;	POP	R8
 6313/2BC8 :                            ;	POP	R9
 6314/2BC8 :                            ;	PUSH	R3
 6315/2BC8 :                            ;	PUSH	R2
 6316/2BC8 :                            ;	LD	R2,R8
 6317/2BC8 :                            ;	LD	R3,R9		; Stack them,get return
 6318/2BC8 :                            ;	PUSH	R3
 6319/2BC8 :                            ;	PUSH	R2		; Re-save return
 6320/2BC8 :                            ;	LD	R8,#hi(FPREG+2)
 6321/2BC8 :                            ;	LD	R9,#lo(FPREG+2)
 6322/2BC8 :                            ;	LDC	R3,@RR8		; @@@ SWAP HL
 6323/2BC8 :                            ;	INCW	RR8
 6324/2BC8 :                            ;	LDC	R2,@RR8		; MSB and exponent of FPREG
 6325/2BC8 :                            ;
 6326/2BC8 :                            ;	POP	R8
 6327/2BC8 :                            ;	POP	R9
 6328/2BC8 :                            ;	PUSH	R3
 6329/2BC8 :                            ;	PUSH	R2
 6330/2BC8 :                            ;	LD	R2,R8
 6331/2BC8 :                            ;	LD	R3,R9		; Stack them,get return
 6332/2BC8 :                            ;	PUSH	R3
 6333/2BC8 :                            ;	PUSH	R2		; Re-save return
 6334/2BC8 :                            ;	LD	R8,R6
 6335/2BC8 :                            ;	LD	R9,R7
 6336/2BC8 :                            ;	LD	R6,R2
 6337/2BC8 :                            ;	LD	R7,R3
 6338/2BC8 :                            ;	LD	R2,R8
 6339/2BC8 :                            ;	LD	R3,R9		; Restore code string address
 6340/2BC8 :                            ;	RET
 6341/2BC8 :                            
 6342/2BC8 : 50 EA                      	POP	R10
 6343/2BCA : 50 EB                      	POP	R11
 6344/2BCC : 8C 81                      	LD	R8,#hi(FPREG)
 6345/2BCE : 9C 31                      	LD	R9,#lo(FPREG)
 6346/2BD0 : C2 18                      	LDC	R1,@RR8		; LSB of FPREG
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 107 - 2023/10/26 22時18分50秒


 6347/2BD2 : A0 E8                      	INCW	RR8
 6348/2BD4 : 70 E1                      	PUSH	R1
 6349/2BD6 : C2 18                      	LDC	R1,@RR8		; NLSB of FPREG
 6350/2BD8 : A0 E8                      	INCW	RR8
 6351/2BDA : 70 E1                      	PUSH	R1
 6352/2BDC : C2 18                      	LDC	R1,@RR8		; MSB of FPREG
 6353/2BDE : A0 E8                      	INCW	RR8
 6354/2BE0 : 70 E1                      	PUSH	R1
 6355/2BE2 : C2 18                      	LDC	R1,@RR8		; exponent of FPREG
 6356/2BE4 : 70 E1                      	PUSH	R1
 6357/2BE6 : 70 EB                      	PUSH	R11
 6358/2BE8 : 70 EA                      	PUSH	R10
 6359/2BEA : AF                         	RET
 6360/2BEB :                            
 6361/2BEB :                            ;
 6362/2BEB :                            PHLTFP:
 6363/2BEB : D6 2C 07                   	CALL	LOADFP		; Number at HL to BCDE
 6364/2BEE :                            FPBCDE:
 6365/2BEE :                            ;	LD	R8,R6
 6366/2BEE :                            ;	LD	R9,R7
 6367/2BEE :                            ;	LD	R6,R2
 6368/2BEE :                            ;	LD	R7,R3
 6369/2BEE :                            ;	LD	R2,R8
 6370/2BEE :                            ;	LD	R3,R9		; Save code string address
 6371/2BEE :                            ;	LD	R8,#hi(FPREG)
 6372/2BEE :                            ;	LD	R9,#lo(FPREG)
 6373/2BEE :                            ;	LDC	@RR8,R3		; @@@ SWAP HL
 6374/2BEE :                            ;	INCW	RR8
 6375/2BEE :                            ;	LDC	@RR8,R2		; Save LSB,NLSB of number
 6376/2BEE :                            ;
 6377/2BEE :                            ;	LD	R2,R4		; Exponent of number
 6378/2BEE :                            ;	LD	R3,R5		; MSB of number
 6379/2BEE :                            ;	LD	R8,#hi(FPREG+2)
 6380/2BEE :                            ;	LD	R9,#lo(FPREG+2)
 6381/2BEE :                            ;	LDC	@RR8,R3		; @@@ SWAP HL
 6382/2BEE :                            ;	INCW	RR8
 6383/2BEE :                            ;	LDC	@RR8,R2		; Save MSB and exponent
 6384/2BEE :                            ;
 6385/2BEE :                            ;	LD	R8,R6
 6386/2BEE :                            ;	LD	R9,R7
 6387/2BEE :                            ;	LD	R6,R2
 6388/2BEE :                            ;	LD	R7,R3
 6389/2BEE :                            ;	LD	R2,R8
 6390/2BEE :                            ;	LD	R3,R9		; Restore code string address
 6391/2BEE :                            ;	RET
 6392/2BEE :                            
 6393/2BEE : 8C 81                      	LD	R8,#hi(FPREG)
 6394/2BF0 : 9C 31                      	LD	R9,#lo(FPREG)
 6395/2BF2 : D2 78                      	LDC	@RR8,R7		; Save LSB of number
 6396/2BF4 : A0 E8                      	INCW	RR8
 6397/2BF6 : D2 68                      	LDC	@RR8,R6		; Save NLSB of number
 6398/2BF8 : A0 E8                      	INCW	RR8
 6399/2BFA : D2 58                      	LDC	@RR8,R5		; Save MSB exponent of number
 6400/2BFC : A0 E8                      	INCW	RR8
 6401/2BFE : D2 48                      	LDC	@RR8,R4		; Save exponent of number
 6402/2C00 : A0 E8                      	INCW	RR8
 6403/2C02 : AF                         	RET
 6404/2C03 :                            
 6405/2C03 :                            BCDEFP:
 6406/2C03 : 2C 81                      	LD	R2,#hi(FPREG)
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 108 - 2023/10/26 22時18分50秒


 6407/2C05 : 3C 31                      	LD	R3,#lo(FPREG)	; Point to FPREG
 6408/2C07 :                            LOADFP:
 6409/2C07 : C2 72                      	LDC	R7,@RR2		; Get LSB of number
 6410/2C09 : 18 FC                      	LD	R1,FLAGS
 6411/2C0B : A0 E2                      	INCW	RR2
 6412/2C0D : C2 62                      	LDC	R6,@RR2		; Get NMSB of number
 6413/2C0F : A0 E2                      	INCW	RR2
 6414/2C11 : C2 52                      	LDC	R5,@RR2		; Get MSB of number
 6415/2C13 : A0 E2                      	INCW	RR2
 6416/2C15 : 19 FC                      	LD	FLAGS,R1
 6417/2C17 : C2 42                      	LDC	R4,@RR2		; Get exponent of number
 6418/2C19 :                            INCHL:
 6419/2C19 : 18 FC                      	LD	R1,FLAGS
 6420/2C1B : A0 E2                      	INCW	RR2		; Used for conditional "INC HL"
 6421/2C1D : 19 FC                      	LD	FLAGS,R1
 6422/2C1F : AF                         	RET
 6423/2C20 :                            ;
 6424/2C20 :                            FPTHL:
 6425/2C20 : 6C 81                      	LD	R6,#hi(FPREG)
 6426/2C22 : 7C 31                      	LD	R7,#lo(FPREG)	; Point to FPREG
 6427/2C24 :                            DETHL4:
 6428/2C24 : 4C 04                      	LD	R4,#4		; 4 bytes to move
 6429/2C26 :                            DETHLB:
 6430/2C26 : C2 06                      	LDC	R0,@RR6		; Get source
 6431/2C28 : D2 02                      	LDC	@RR2,R0		; Save destination
 6432/2C2A : A0 E6                      	INCW	RR6		; Next source
 6433/2C2C : A0 E2                      	INCW	RR2		; Next destination
 6434/2C2E : 00 E4                      	DEC	R4		; Count bytes
 6435/2C30 : ED 2C 26                   	JP	NZ,DETHLB	; Loop if more
 6436/2C33 : AF                         	RET
 6437/2C34 :                            ;
 6438/2C34 :                            SIGNS:
 6439/2C34 : 2C 81                      	LD	R2,#hi(FPREG+2)
 6440/2C36 : 3C 33                      	LD	R3,#lo(FPREG+2)	; Point to MSB of FPREG
 6441/2C38 : C2 02                      	LDC	R0,@RR2		; Get MSB
 6442/2C3A : 90 E0                      	RL	R0		; Old sign to carry
 6443/2C3C : DF                         	SCF			; Set MSBit
 6444/2C3D : C0 E0                      	RRC	R0		; Set MSBit of MSB
 6445/2C3F : D2 02                      	LDC	@RR2,R0		; Save new MSB
 6446/2C41 : EF                         	CCF			; Complement sign
 6447/2C42 : C0 E0                      	RRC	R0		; Old sign to carry
 6448/2C44 : A0 E2                      	INCW	RR2
 6449/2C46 : A0 E2                      	INCW	RR2
 6450/2C48 : D2 02                      	LDC	@RR2,R0		; Set sign of result
 6451/2C4A : 08 E5                      	LD	R0,R5		; Get MSB
 6452/2C4C : 90 E0                      	RL	R0		; Old sign to carry
 6453/2C4E : DF                         	SCF			; Set MSBit
 6454/2C4F : C0 E0                      	RRC	R0		; Set MSBit of MSB
 6455/2C51 : 58 E0                      	LD	R5,R0		; Save MSB
 6456/2C53 : C0 E0                      	RRC	R0
 6457/2C55 : C2 82                      	LDC	R8,@RR2
 6458/2C57 : B2 08                      	XOR	R0,R8		; New sign of result
 6459/2C59 : AF                         	RET
 6460/2C5A :                            ;
 6461/2C5A :                            CMPNUM:
 6462/2C5A : 08 E4                      	LD	R0,R4		; Get exponent of number
 6463/2C5C : 42 00                      	OR	R0,R0
 6464/2C5E : CF                         	RCF
 6465/2C5F : 6D 2B 76                   	JP	Z,TSTSGN	; Zero - Test sign of FPREG
 6466/2C62 : 2C 2B                      	LD	R2,#hi(RETREL)
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 109 - 2023/10/26 22時18分50秒


 6467/2C64 : 3C 8D                      	LD	R3,#lo(RETREL)	; Return relation routine
 6468/2C66 : 70 E3                      	PUSH	R3
 6469/2C68 : 70 E2                      	PUSH	R2		; Save for return
 6470/2C6A : D6 2B 76                   	CALL	TSTSGN		; Test sign of FPREG
 6471/2C6D : 08 E5                      	LD	R0,R5		; Get MSB of number
 6472/2C6F : EB 01                      	JR	NZ,$+3
 6473/2C71 : AF                         	RET			; FPREG zero - Number's MSB
 6474/2C72 : 2C 81                      	LD	R2,#hi(FPREG+2)
 6475/2C74 : 3C 33                      	LD	R3,#lo(FPREG+2)	; MSB of FPREG
 6476/2C76 : C2 82                      	LDC	R8,@RR2
 6477/2C78 : B2 08                      	XOR	R0,R8		; Combine signs
 6478/2C7A : 08 E5                      	LD	R0,R5		; Get MSB of number
 6479/2C7C : DB 01                      	JR	PL,$+3
 6480/2C7E : AF                         	RET			; Exit if signs different
 6481/2C7F : D6 2C 87                   	CALL	CMPFP		; Compare FP numbers
 6482/2C82 : C0 E0                      	RRC	R0		; Get carry to sign
 6483/2C84 : B2 05                      	XOR	R0,R5		; Combine with MSB of number
 6484/2C86 : AF                         	RET
 6485/2C87 :                            ;
 6486/2C87 :                            CMPFP:
 6487/2C87 : A0 E2                      	INCW	RR2		; Point to exponent
 6488/2C89 : 08 E4                      	LD	R0,R4		; Get exponent
 6489/2C8B : C2 82                      	LDC	R8,@RR2
 6490/2C8D : A2 08                      	CP	R0,R8		; Compare exponents
 6491/2C8F : 6B 01                      	JR	Z,$+3
 6492/2C91 : AF                         	RET			; Different
 6493/2C92 : 80 E2                      	DECW	RR2		; Point to MBS
 6494/2C94 : 08 E5                      	LD	R0,R5		; Get MSB
 6495/2C96 : C2 82                      	LDC	R8,@RR2
 6496/2C98 : A2 08                      	CP	R0,R8		; Compare MSBs
 6497/2C9A : 6B 01                      	JR	Z,$+3
 6498/2C9C : AF                         	RET			; Different
 6499/2C9D : 80 E2                      	DECW	RR2		; Point to NMSB
 6500/2C9F : 08 E6                      	LD	R0,R6		; Get NMSB
 6501/2CA1 : C2 82                      	LDC	R8,@RR2
 6502/2CA3 : A2 08                      	CP	R0,R8		; Compare NMSBs
 6503/2CA5 : 6B 01                      	JR	Z,$+3
 6504/2CA7 : AF                         	RET			; Different
 6505/2CA8 : 80 E2                      	DECW	RR2		; Point to LSB
 6506/2CAA : 08 E7                      	LD	R0,R7		; Get LSB
 6507/2CAC : C2 82                      	LDC	R8,@RR2
 6508/2CAE : 22 08                      	SUB	R0,R8		; Compare LSBs
 6509/2CB0 : 6B 01                      	JR	Z,$+3
 6510/2CB2 : AF                         	RET			; Different
 6511/2CB3 : 50 E2                      	POP	R2
 6512/2CB5 : 50 E3                      	POP	R3		; Drop RETurn
 6513/2CB7 : 50 E2                      	POP	R2
 6514/2CB9 : 50 E3                      	POP	R3		; Drop another RETurn
 6515/2CBB : AF                         	RET
 6516/2CBC :                            ;
 6517/2CBC :                            FPINT:
 6518/2CBC : 48 E0                      	LD	R4,R0		; <- Move
 6519/2CBE : 58 E0                      	LD	R5,R0		; <- exponent
 6520/2CC0 : 68 E0                      	LD	R6,R0		; <- to all
 6521/2CC2 : 78 E0                      	LD	R7,R0		; <- bits
 6522/2CC4 : 42 00                      	OR	R0,R0
 6523/2CC6 : CF                         	RCF			; Test exponent
 6524/2CC7 : EB 01                      	JR	NZ,$+3
 6525/2CC9 : AF                         	RET			; Zero - Return zero
 6526/2CCA : 70 E3                      	PUSH	R3
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 110 - 2023/10/26 22時18分50秒


 6527/2CCC : 70 E2                      	PUSH	R2		; Save pointer to number
 6528/2CCE : D6 2C 03                   	CALL	BCDEFP		; Move FPREG to BCDE
 6529/2CD1 : D6 2C 34                   	CALL	SIGNS		; Set MSBs & sign of result
 6530/2CD4 : C2 82                      	LDC	R8,@RR2
 6531/2CD6 : B2 08                      	XOR	R0,R8		; Combine with sign of FPREG
 6532/2CD8 : 28 E0                      	LD	R2,R0		; Save combined signs
 6533/2CDA : DB 03                      	JR	PL,$+5
 6534/2CDC : D6 2C FB                   	CALL	DCBCDE		; Negative - Decrement BCDE
 6535/2CDF : 0C 98                      	LD	R0,#80H+24	; 24 bits
 6536/2CE1 : 22 04                      	SUB	R0,R4		; Bits to shift
 6537/2CE3 : D6 28 BA                   	CALL	SCALE		; Shift BCDE
 6538/2CE6 : 08 E2                      	LD	R0,R2		; Get combined sign
 6539/2CE8 : 10 E0                      	RLC	R0		; Sign to carry
 6540/2CEA : FB 03                      	JR	NC,$+5
 6541/2CEC : D6 28 5C                   	CALL	FPROND		; Negative - Round number up
 6542/2CEF : 4C 00                      	LD	R4,#0		; Zero exponent
 6543/2CF1 : FB 03                      	JR	NC,$+5
 6544/2CF3 : D6 28 94                   	CALL	COMPL		; If negative make positive
 6545/2CF6 : 50 E2                      	POP	R2
 6546/2CF8 : 50 E3                      	POP	R3		; Restore pointer to number
 6547/2CFA : AF                         	RET
 6548/2CFB :                            ;
 6549/2CFB :                            DCBCDE:
 6550/2CFB : 80 E6                      	DECW	RR6		; Decrement BCDE
 6551/2CFD : 08 E6                      	LD	R0,R6		; Test LSBs
 6552/2CFF : 52 07                      	AND	R0,R7
 6553/2D01 : 0E                         	INC	R0
 6554/2D02 : 6B 01                      	JR	Z,$+3
 6555/2D04 : AF                         	RET			; Exit if LSBs not FFFF
 6556/2D05 : 18 FC                      	LD	R1,FLAGS
 6557/2D07 : 80 E4                      	DECW	RR4		; Decrement MSBs
 6558/2D09 : 19 FC                      	LD	FLAGS,R1
 6559/2D0B : AF                         	RET
 6560/2D0C :                            ;
 6561/2D0C :                            INT:
 6562/2D0C : 2C 81                      	LD	R2,#hi(FPEXP)
 6563/2D0E : 3C 34                      	LD	R3,#lo(FPEXP)	; Point to exponent
 6564/2D10 : C2 02                      	LDC	R0,@RR2		; Get exponent
 6565/2D12 : A6 E0 98                   	CP	R0,#80H+24	; Integer accuracy only?
 6566/2D15 : 8C 81                      	LD	R8,#hi(FPREG)
 6567/2D17 : 9C 31                      	LD	R9,#lo(FPREG)
 6568/2D19 : C2 08                      	LDC	R0,@RR8		; Get LSB
 6569/2D1B : 7B 01                      	JR	C,$+3
 6570/2D1D : AF                         	RET			; Yes - Already integer
 6571/2D1E : C2 02                      	LDC	R0,@RR2		; Get exponent
 6572/2D20 : D6 2C BC                   	CALL	FPINT		; F.P to integer
 6573/2D23 : 1C 98                      	LD	R1,#80H+24
 6574/2D25 : D2 12                      	LDC	@RR2,R1		; Save 24 bit integer
 6575/2D27 : 08 E7                      	LD	R0,R7		; Get LSB of number
 6576/2D29 : 18 FC                      	LD	R1,FLAGS
 6577/2D2B : 70 E1                      	PUSH	R1
 6578/2D2D : 70 E0                      	PUSH	R0		; Save LSB
 6579/2D2F : 08 E5                      	LD	R0,R5		; Get MSB of number
 6580/2D31 : 10 E0                      	RLC	R0			; Sign to carry
 6581/2D33 : D6 27 DE                   	CALL	CONPOS		; Set sign of result
 6582/2D36 : 50 E0                      	POP	R0		; Restore LSB of number
 6583/2D38 : 50 E1                      	POP	R1
 6584/2D3A : 19 FC                      	LD	FLAGS,R1
 6585/2D3C : AF                         	RET
 6586/2D3D :                            ;
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 111 - 2023/10/26 22時18分50秒


 6587/2D3D :                            MLDEBC:
 6588/2D3D : 2C 00                      	LD	R2,#hi(0)
 6589/2D3F : 3C 00                      	LD	R3,#lo(0)	; Clear partial product
 6590/2D41 : 08 E4                      	LD	R0,R4		; Test multiplier
 6591/2D43 : 42 05                      	OR	R0,R5
 6592/2D45 : CF                         	RCF
 6593/2D46 : EB 01                      	JR	NZ,$+3
 6594/2D48 : AF                         	RET			; Return zero if zero
 6595/2D49 : 0C 10                      	LD	R0,#16		; 16 bits
 6596/2D4B :                            MLDBLP:
 6597/2D4B : 02 33                      	ADD	R3,R3
 6598/2D4D : 12 22                      	ADC	R2,R2		; Shift P.P left
 6599/2D4F : 7D 1C ED                   	JP	C,BSERR		; ?BS Error if overflow
 6600/2D52 : 88 E6                      	LD	R8,R6
 6601/2D54 : 98 E7                      	LD	R9,R7
 6602/2D56 : 68 E2                      	LD	R6,R2
 6603/2D58 : 78 E3                      	LD	R7,R3
 6604/2D5A : 28 E8                      	LD	R2,R8
 6605/2D5C : 38 E9                      	LD	R3,R9
 6606/2D5E : 02 33                      	ADD	R3,R3
 6607/2D60 : 12 22                      	ADC	R2,R2		; Shift multiplier left
 6608/2D62 : 88 E6                      	LD	R8,R6
 6609/2D64 : 98 E7                      	LD	R9,R7
 6610/2D66 : 68 E2                      	LD	R6,R2
 6611/2D68 : 78 E3                      	LD	R7,R3
 6612/2D6A : 28 E8                      	LD	R2,R8
 6613/2D6C : 38 E9                      	LD	R3,R9
 6614/2D6E : FD 2D 78                   	JP	NC,NOMLAD	; Bit was zero - No add
 6615/2D71 : 02 35                      	ADD	R3,R5
 6616/2D73 : 12 24                      	ADC	R2,R4		; Add multiplicand
 6617/2D75 : 7D 1C ED                   	JP	C,BSERR		; ?BS Error if overflow
 6618/2D78 :                            NOMLAD:
 6619/2D78 : 00 E0                      	DEC	R0		; Count bits
 6620/2D7A : ED 2D 4B                   	JP	NZ,MLDBLP	; More
 6621/2D7D : AF                         	RET
 6622/2D7E :                            ;
 6623/2D7E :                            ASCTFP:
 6624/2D7E : A6 E0 2D                   	CP	R0,#'-'		; Negative?
 6625/2D81 : 18 FC                      	LD	R1,FLAGS
 6626/2D83 : 70 E1                      	PUSH	R1
 6627/2D85 : 70 E0                      	PUSH	R0		; Save it and flags
 6628/2D87 : 6D 2D 92                   	JP	Z,CNVNUM	; Yes - Convert number
 6629/2D8A : A6 E0 2B                   	CP	R0,#'+'		; Positive?
 6630/2D8D : 6D 2D 92                   	JP	Z,CNVNUM	; Yes - Convert number
 6631/2D90 : 80 E2                      	DECW	RR2		; DEC 'cos GETCHR INCs
 6632/2D92 :                            CNVNUM:
 6633/2D92 : D6 28 05                   	CALL	RESZER		; Set result to zero
 6634/2D95 : 48 E0                      	LD	R4,R0		; Digits after point counter
 6635/2D97 : 68 E0                      	LD	R6,R0		; Sign of exponent
 6636/2D99 : 78 E0                      	LD	R7,R0		; Exponent of ten
 6637/2D9B : 60 E0                      	COM	R0
 6638/2D9D : 58 E0                      	LD	R5,R0		; Before or after point flag
 6639/2D9F :                            MANLP:
 6640/2D9F : D6 0D AD                   	CALL	GETCHR		; Get next character
 6641/2DA2 : 7D 2E 21                   	JP	C,ADDIG		; Digit - Add to number
 6642/2DA5 : A6 E0 2E                   	CP	R0,#'.'
 6643/2DA8 : 6D 2D C9                   	JP	Z,DPOINT	; '.' - Flag point
 6644/2DAB : A6 E0 45                   	CP	R0,#'E'
 6645/2DAE : ED 2D CD                   	JP	NZ,CONEXP	; Not 'E' - Scale number
 6646/2DB1 : D6 0D AD                   	CALL	GETCHR		; Get next character
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 112 - 2023/10/26 22時18分50秒


 6647/2DB4 : D6 18 DC                   	CALL	SGNEXP		; Get sign of exponent
 6648/2DB7 :                            EXPLP:
 6649/2DB7 : D6 0D AD                   	CALL	GETCHR		; Get next character
 6650/2DBA : 7D 2E 68                   	JP	C,EDIGIT	; Digit - Add to exponent
 6651/2DBD : 6E                         	INC	R6		; Is sign negative?
 6652/2DBE : ED 2D CD                   	JP	NZ,CONEXP	; No - Scale number
 6653/2DC1 : B2 00                      	XOR	R0,R0
 6654/2DC3 : CF                         	RCF
 6655/2DC4 : 22 07                      	SUB	R0,R7		; Negate exponent
 6656/2DC6 : 78 E0                      	LD	R7,R0		; And re-save it
 6657/2DC8 : 5E                         	INC	R5		; Flag end of number
 6658/2DC9 :                            DPOINT:
 6659/2DC9 : 5E                         	INC	R5		; Flag point passed
 6660/2DCA : 6D 2D 9F                   	JP	Z,MANLP		; Zero - Get another digit
 6661/2DCD :                            CONEXP:
 6662/2DCD : 70 E3                      	PUSH	R3
 6663/2DCF : 70 E2                      	PUSH	R2		; Save code string address
 6664/2DD1 : 08 E7                      	LD	R0,R7		; Get exponent
 6665/2DD3 : 22 04                      	SUB	R0,R4		; Subtract digits after point
 6666/2DD5 :                            SCALMI:
 6667/2DD5 : 5B 03                      	JR	MI,$+5
 6668/2DD7 : D6 2E 0C                   	CALL	SCALPL		; Positive - Multiply number
 6669/2DDA : DD 2D ED                   	JP	PL,ENDCON	; Positive - All done
 6670/2DDD : 18 FC                      	LD	R1,FLAGS
 6671/2DDF : 70 E1                      	PUSH	R1
 6672/2DE1 : 70 E0                      	PUSH	R0		; Save number of times to /10
 6673/2DE3 : D6 2A 2A                   	CALL	DIV10		; Divide by 10
 6674/2DE6 : 50 E0                      	POP	R0		; Restore count
 6675/2DE8 : 50 E1                      	POP	R1
 6676/2DEA : 19 FC                      	LD	FLAGS,R1
 6677/2DEC : 0E                         	INC	R0		; Count divides
 6678/2DED :                            ;
 6679/2DED :                            ENDCON:
 6680/2DED : ED 2D D5                   	JP	NZ,SCALMI	; More to do
 6681/2DF0 : 50 E6                      	POP	R6
 6682/2DF2 : 50 E7                      	POP	R7		; Restore code string address
 6683/2DF4 : 50 E0                      	POP	R0		; Restore sign of number
 6684/2DF6 : 50 E1                      	POP	R1
 6685/2DF8 : 19 FC                      	LD	FLAGS,R1
 6686/2DFA : EB 03                      	JR	NZ,$+5
 6687/2DFC : D6 2B BC                   	CALL	INVSGN		; Negative - Negate number
 6688/2DFF : 88 E6                      	LD	R8,R6
 6689/2E01 : 98 E7                      	LD	R9,R7
 6690/2E03 : 68 E2                      	LD	R6,R2
 6691/2E05 : 78 E3                      	LD	R7,R3
 6692/2E07 : 28 E8                      	LD	R2,R8
 6693/2E09 : 38 E9                      	LD	R3,R9		; Code string address to HL
 6694/2E0B : AF                         	RET
 6695/2E0C :                            ;
 6696/2E0C :                            SCALPL:
 6697/2E0C : EB 01                      	JR	NZ,$+3
 6698/2E0E : AF                         	RET			; Exit if no scaling needed
 6699/2E0F :                            MULTEN:
 6700/2E0F : 18 FC                      	LD	R1,FLAGS
 6701/2E11 : 70 E1                      	PUSH	R1
 6702/2E13 : 70 E0                      	PUSH	R0		; Save count
 6703/2E15 : D6 2B 51                   	CALL	MLSP10		; Multiply number by 10
 6704/2E18 : 50 E0                      	POP	R0		; Restore count
 6705/2E1A : 50 E1                      	POP	R1
 6706/2E1C : 19 FC                      	LD	FLAGS,R1
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 113 - 2023/10/26 22時18分50秒


 6707/2E1E : 00 E0                      	DEC	R0		; Count multiplies
 6708/2E20 : AF                         	RET
 6709/2E21 :                            ;
 6710/2E21 :                            ADDIG:
 6711/2E21 : 70 E7                      	PUSH	R7
 6712/2E23 : 70 E6                      	PUSH	R6		; Save sign of exponent
 6713/2E25 : 68 E0                      	LD	R6,R0		; Save digit
 6714/2E27 : 08 E4                      	LD	R0,R4		; Get digits after point
 6715/2E29 : 12 05                      	ADC	R0,R5		; Add one if after point
 6716/2E2B : 48 E0                      	LD	R4,R0		; Re-save counter
 6717/2E2D : 70 E5                      	PUSH	R5
 6718/2E2F : 70 E4                      	PUSH	R4		; Save point flags
 6719/2E31 : 70 E3                      	PUSH	R3
 6720/2E33 : 70 E2                      	PUSH	R2		; Save code string address
 6721/2E35 : 70 E7                      	PUSH	R7
 6722/2E37 : 70 E6                      	PUSH	R6		; Save digit
 6723/2E39 : D6 2B 51                   	CALL	MLSP10		; Multiply number by 10
 6724/2E3C : 50 E0                      	POP	R0		; Restore digit
 6725/2E3E : 50 E1                      	POP	R1
 6726/2E40 : 19 FC                      	LD	FLAGS,R1
 6727/2E42 : 26 E0 30                   	SUB	R0,#'0'		; Make it absolute
 6728/2E45 : D6 2E 57                   	CALL	RSCALE		; Re-scale number
 6729/2E48 : 50 E2                      	POP	R2
 6730/2E4A : 50 E3                      	POP	R3		; Restore code string address
 6731/2E4C : 50 E4                      	POP	R4
 6732/2E4E : 50 E5                      	POP	R5		; Restore point flags
 6733/2E50 : 50 E6                      	POP	R6
 6734/2E52 : 50 E7                      	POP	R7		; Restore sign of exponent
 6735/2E54 : 8D 2D 9F                   	JP	MANLP		; Get another digit
 6736/2E57 :                            ;
 6737/2E57 :                            RSCALE:
 6738/2E57 : D6 2B C8                   	CALL	STAKFP		; Put number on stack
 6739/2E5A : D6 2B 9B                   	CALL	FLGREL		; Digit to add to FPREG
 6740/2E5D :                            PADD:
 6741/2E5D : 50 E4                      	POP	R4
 6742/2E5F : 50 E5                      	POP	R5		; Restore number
 6743/2E61 : 50 E6                      	POP	R6
 6744/2E63 : 50 E7                      	POP	R7
 6745/2E65 : 8D 27 3B                   	JP	FPADD		; Add BCDE to FPREG and return
 6746/2E68 :                            ;
 6747/2E68 :                            EDIGIT:
 6748/2E68 : 08 E7                      	LD	R0,R7		; Get digit
 6749/2E6A : 90 E0                      	RL	R0		; Times 2
 6750/2E6C : 90 E0                      	RL	R0		; Times 4
 6751/2E6E : 02 07                      	ADD	R0,R7		; Times 5
 6752/2E70 : 90 E0                      	RL	R0		; Times 10
 6753/2E72 : C2 82                      	LDC	R8,@RR2
 6754/2E74 : 02 08                      	ADD	R0,R8		; Add next digit
 6755/2E76 : 26 E0 30                   	SUB	R0,#'0'		; Make it absolute
 6756/2E79 : 78 E0                      	LD	R7,R0		; Save new digit
 6757/2E7B : 8D 2D B7                   	JP	EXPLP		; Look for another digit
 6758/2E7E :                            ;
 6759/2E7E :                            LINEIN:
 6760/2E7E : 70 E3                      	PUSH	R3
 6761/2E80 : 70 E2                      	PUSH	R2		; Save code string address
 6762/2E82 : 2C 04                      	LD	R2,#hi(INMSG)
 6763/2E84 : 3C 17                      	LD	R3,#lo(INMSG)	; Output " in "
 6764/2E86 : D6 21 02                   	CALL	PRS		; Output string at HL
 6765/2E89 : 50 E2                      	POP	R2
 6766/2E8B : 50 E3                      	POP	R3		; Restore code string address
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 114 - 2023/10/26 22時18分50秒


 6767/2E8D :                            PRNTHL:
 6768/2E8D : 88 E6                      	LD	R8,R6
 6769/2E8F : 98 E7                      	LD	R9,R7
 6770/2E91 : 68 E2                      	LD	R6,R2
 6771/2E93 : 78 E3                      	LD	R7,R3
 6772/2E95 : 28 E8                      	LD	R2,R8
 6773/2E97 : 38 E9                      	LD	R3,R9		; Code string address to DE
 6774/2E99 : B2 00                      	XOR	R0,R0
 6775/2E9B : 4C 98                      	LD	R4,#80H+24	; 24 bits
 6776/2E9D : D6 2B A1                   	CALL	RETINT		; Return the integer
 6777/2EA0 : 2C 21                      	LD	R2,#hi(PRNUMS)
 6778/2EA2 : 3C 00                      	LD	R3,#lo(PRNUMS)	; Print number string
 6779/2EA4 : 70 E3                      	PUSH	R3
 6780/2EA6 : 70 E2                      	PUSH	R2		; Save for return
 6781/2EA8 :                            NUMASC:
 6782/2EA8 : 2C 81                      	LD	R2,#hi(PBUFF)
 6783/2EAA : 3C 36                      	LD	R3,#lo(PBUFF)	; Convert number to ASCII
 6784/2EAC : 70 E3                      	PUSH	R3
 6785/2EAE : 70 E2                      	PUSH	R2		; Save for return
 6786/2EB0 : D6 2B 76                   	CALL	TSTSGN		; Test sign of FPREG
 6787/2EB3 : 1C 20                      	LD	R1,#' '
 6788/2EB5 : D2 12                      	LDC	@RR2,R1		; Space at start
 6789/2EB7 : DD 2E BE                   	JP	PL,SPCFST	; Positive - Space to start
 6790/2EBA : 1C 2D                      	LD	R1,#'-'
 6791/2EBC : D2 12                      	LDC	@RR2,R1		; '-' sign at start
 6792/2EBE :                            SPCFST:
 6793/2EBE : 18 FC                      	LD	R1,FLAGS
 6794/2EC0 : A0 E2                      	INCW	RR2		; First byte of number
 6795/2EC2 : 19 FC                      	LD	FLAGS,R1
 6796/2EC4 : 1C 30                      	LD	R1,#'0'
 6797/2EC6 : D2 12                      	LDC	@RR2,R1		; '0' if zero
 6798/2EC8 : 6D 30 3C                   	JP	Z,JSTZER	; Return '0' if zero
 6799/2ECB : 70 E3                      	PUSH	R3
 6800/2ECD : 70 E2                      	PUSH	R2		; Save buffer address
 6801/2ECF : DB 03                      	JR	PL,$+5
 6802/2ED1 : D6 2B BC                   	CALL	INVSGN		; Negate FPREG if negative
 6803/2ED4 : B2 00                      	XOR	R0,R0
 6804/2ED6 : CF                         	RCF			; Zero A
 6805/2ED7 : 18 FC                      	LD	R1,FLAGS
 6806/2ED9 : 70 E1                      	PUSH	R1
 6807/2EDB : 70 E0                      	PUSH	R0		; Save it
 6808/2EDD : D6 30 4D                   	CALL	RNGTST		; Test number is in range
 6809/2EE0 :                            SIXDIG:
 6810/2EE0 : 4C 91                      	LD	R4,#hi(9143H)
 6811/2EE2 : 5C 43                      	LD	R5,#lo(9143H)	; BCDE - 99999.9
 6812/2EE4 : 6C 4F                      	LD	R6,#hi(4FF8H)
 6813/2EE6 : 7C F8                      	LD	R7,#lo(4FF8H)
 6814/2EE8 : D6 2C 5A                   	CALL	CMPNUM		; Compare numbers
 6815/2EEB :                            ; OR	A
 6816/2EEB :                            ; JP	PO,INRNG	; > 99999.9 - Sort it out
 6817/2EEB :                            
 6818/2EEB : 18 E0                      	LD	R1,R0		; @@@
 6819/2EED : C0 E1                      	RRC	R1
 6820/2EEF : C0 E1                      	RRC	R1
 6821/2EF1 : C0 E1                      	RRC	R1
 6822/2EF3 : C0 E1                      	RRC	R1
 6823/2EF5 : B2 10                      	XOR	R1,R0
 6824/2EF7 : 88 E1                      	LD	R8,R1
 6825/2EF9 : C0 E1                      	RRC	R1
 6826/2EFB : C0 E1                      	RRC	R1
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 115 - 2023/10/26 22時18分50秒


 6827/2EFD : B2 18                      	XOR	R1,R8
 6828/2EFF : 88 E1                      	LD	R8,R1
 6829/2F01 : C0 E1                      	RRC	R1
 6830/2F03 : B2 18                      	XOR	R1,R8
 6831/2F05 : 56 E1 01                   	AND	R1,#01H
 6832/2F08 : EB 25                      	JR	NZ,INRNG
 6833/2F0A :                            
 6834/2F0A : 50 E0                      	POP	R0		; Restore count
 6835/2F0C : 50 E1                      	POP	R1
 6836/2F0E : 19 FC                      	LD	FLAGS,R1
 6837/2F10 : D6 2E 0F                   	CALL	MULTEN		; Multiply by ten
 6838/2F13 : 18 FC                      	LD	R1,FLAGS
 6839/2F15 : 70 E1                      	PUSH	R1
 6840/2F17 : 70 E0                      	PUSH	R0		; Re-save count
 6841/2F19 : 8D 2E E0                   	JP	SIXDIG		; Test it again
 6842/2F1C :                            ;
 6843/2F1C :                            GTSIXD:
 6844/2F1C : D6 2A 2A                   	CALL	DIV10		; Divide by 10
 6845/2F1F : 50 E0                      	POP	R0		; Get count
 6846/2F21 : 50 E1                      	POP	R1
 6847/2F23 : 19 FC                      	LD	FLAGS,R1
 6848/2F25 : 0E                         	INC	R0		; Count divides
 6849/2F26 : 18 FC                      	LD	R1,FLAGS
 6850/2F28 : 70 E1                      	PUSH	R1
 6851/2F2A : 70 E0                      	PUSH	R0		; Re-save count
 6852/2F2C : D6 30 4D                   	CALL	RNGTST		; Test number is in range
 6853/2F2F :                            INRNG:
 6854/2F2F : D6 27 21                   	CALL	ROUND		; Add 0.5 to FPREG
 6855/2F32 : 0E                         	INC	R0
 6856/2F33 : D6 2C BC                   	CALL	FPINT		; F.P to integer
 6857/2F36 : D6 2B EE                   	CALL	FPBCDE		; Move BCDE to FPREG
 6858/2F39 : 4C 03                      	LD	R4,#hi(0306H)
 6859/2F3B : 5C 06                      	LD	R5,#lo(0306H)	; 1E+06 to 1E-03 range
 6860/2F3D : 50 E0                      	POP	R0		; Restore count
 6861/2F3F : 50 E1                      	POP	R1
 6862/2F41 : 19 FC                      	LD	FLAGS,R1
 6863/2F43 : 02 05                      	ADD	R0,R5		; 6 digits before point
 6864/2F45 : 0E                         	INC	R0		; Add one
 6865/2F46 : 5D 2F 54                   	JP	MI,MAKNUM	; Do it in 'E' form if < 1E-02
 6866/2F49 : A6 E0 08                   	CP	R0,#6+1+1	; More than 999999 ?
 6867/2F4C : FD 2F 54                   	JP	NC,MAKNUM	; Yes - Do it in 'E' form
 6868/2F4F : 0E                         	INC	R0		; Adjust for exponent
 6869/2F50 : 48 E0                      	LD	R4,R0		; Exponent of number
 6870/2F52 : 0C 02                      	LD	R0,#2		; Make it zero after
 6871/2F54 :                            ;
 6872/2F54 :                            MAKNUM:
 6873/2F54 : 00 E0                      	DEC	R0		; Adjust for digits to do
 6874/2F56 : 00 E0                      	DEC	R0
 6875/2F58 : 50 E2                      	POP	R2
 6876/2F5A : 50 E3                      	POP	R3		; Restore buffer address
 6877/2F5C : 18 FC                      	LD	R1,FLAGS
 6878/2F5E : 70 E1                      	PUSH	R1
 6879/2F60 : 70 E0                      	PUSH	R0		; Save count
 6880/2F62 : 6C 30                      	LD	R6,#hi(POWERS)
 6881/2F64 : 7C 82                      	LD	R7,#lo(POWERS)	; Powers of ten
 6882/2F66 : 00 E4                      	DEC	R4		; Count digits before point
 6883/2F68 : ED 2F 77                   	JP	NZ,DIGTXT	; Not zero - Do number
 6884/2F6B : 1C 2E                      	LD	R1,#'.'
 6885/2F6D : D2 12                      	LDC	@RR2,R1		; Save point
 6886/2F6F : A0 E2                      	INCW	RR2		; Move on
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 116 - 2023/10/26 22時18分50秒


 6887/2F71 : 1C 30                      	LD	R1,#'0'
 6888/2F73 : D2 12                      	LDC	@RR2,R1	; Save zero
 6889/2F75 : A0 E2                      	INCW	RR2		; Move on
 6890/2F77 :                            DIGTXT:
 6891/2F77 : 00 E4                      	DEC	R4		; Count digits before point
 6892/2F79 : 1C 2E                      	LD	R1,#'.'
 6893/2F7B : D2 12                      	LDC	@RR2,R1		; Save point in case
 6894/2F7D : EB 03                      	JR	NZ,$+5
 6895/2F7F : D6 2C 19                   	CALL	INCHL		; Last digit - move on
 6896/2F82 : 70 E5                      	PUSH	R5
 6897/2F84 : 70 E4                      	PUSH	R4		; Save digits before point
 6898/2F86 : 70 E3                      	PUSH	R3
 6899/2F88 : 70 E2                      	PUSH	R2		; Save buffer address
 6900/2F8A : 70 E7                      	PUSH	R7
 6901/2F8C : 70 E6                      	PUSH	R6		; Save powers of ten
 6902/2F8E : D6 2C 03                   	CALL	BCDEFP		; Move FPREG to BCDE
 6903/2F91 : 50 E2                      	POP	R2
 6904/2F93 : 50 E3                      	POP	R3		; Powers of ten table
 6905/2F95 : 4C 2F                      	LD	R4,#'0'-1	; ASCII '0' - 1
 6906/2F97 :                            TRYAGN:
 6907/2F97 : 4E                         	INC	R4		; Count subtractions
 6908/2F98 : 08 E7                      	LD	R0,R7		; Get LSB
 6909/2F9A : C2 82                      	LDC	R8,@RR2
 6910/2F9C : 22 08                      	SUB	R0,R8		; Subtract LSB
 6911/2F9E : 78 E0                      	LD	R7,R0		; Save LSB
 6912/2FA0 : 18 FC                      	LD	R1,FLAGS
 6913/2FA2 : A0 E2                      	INCW	RR2
 6914/2FA4 : 19 FC                      	LD	FLAGS,R1
 6915/2FA6 : 08 E6                      	LD	R0,R6		; Get NMSB
 6916/2FA8 : C2 82                      	LDC	R8,@RR2
 6917/2FAA : 32 08                      	SBC	R0,R8		; Subtract NMSB
 6918/2FAC : 68 E0                      	LD	R6,R0		; Save NMSB
 6919/2FAE : 18 FC                      	LD	R1,FLAGS
 6920/2FB0 : A0 E2                      	INCW	RR2
 6921/2FB2 : 19 FC                      	LD	FLAGS,R1
 6922/2FB4 : 08 E5                      	LD	R0,R5		; Get MSB
 6923/2FB6 : C2 82                      	LDC	R8,@RR2
 6924/2FB8 : 32 08                      	SBC	R0,R8		; Subtract MSB
 6925/2FBA : 58 E0                      	LD	R5,R0		; Save MSB
 6926/2FBC : 18 FC                      	LD	R1,FLAGS
 6927/2FBE : 80 E2                      	DECW	RR2		; Point back to start
 6928/2FC0 : 80 E2                      	DECW	RR2
 6929/2FC2 : 19 FC                      	LD	FLAGS,R1
 6930/2FC4 : FD 2F 97                   	JP	NC,TRYAGN	; No overflow - Try again
 6931/2FC7 : D6 28 75                   	CALL	PLUCDE		; Restore number
 6932/2FCA : 18 FC                      	LD	R1,FLAGS
 6933/2FCC : A0 E2                      	INCW	RR2		; Start of next number
 6934/2FCE : 19 FC                      	LD	FLAGS,R1
 6935/2FD0 : D6 2B EE                   	CALL	FPBCDE		; Move BCDE to FPREG
 6936/2FD3 : 88 E6                      	LD	R8,R6
 6937/2FD5 : 98 E7                      	LD	R9,R7
 6938/2FD7 : 68 E2                      	LD	R6,R2
 6939/2FD9 : 78 E3                      	LD	R7,R3
 6940/2FDB : 28 E8                      	LD	R2,R8
 6941/2FDD : 38 E9                      	LD	R3,R9		; Save point in table
 6942/2FDF : 50 E2                      	POP	R2
 6943/2FE1 : 50 E3                      	POP	R3		; Restore buffer address
 6944/2FE3 : D2 42                      	LDC	@RR2,R4		; Save digit in buffer
 6945/2FE5 : A0 E2                      	INCW	RR2		; And move on
 6946/2FE7 : 50 E4                      	POP	R4
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 117 - 2023/10/26 22時18分50秒


 6947/2FE9 : 50 E5                      	POP	R5		; Restore digit count
 6948/2FEB : 00 E5                      	DEC	R5		; Count digits
 6949/2FED : ED 2F 77                   	JP	NZ,DIGTXT	; More - Do them
 6950/2FF0 : 00 E4                      	DEC	R4		; Any decimal part?
 6951/2FF2 : 6D 30 07                   	JP	Z,DOEBIT	; No - Do 'E' bit
 6952/2FF5 :                            SUPTLZ:
 6953/2FF5 : 80 E2                      	DECW	RR2		; Move back through buffer
 6954/2FF7 : C2 02                      	LDC	R0,@RR2		; Get character
 6955/2FF9 : A6 E0 30                   	CP	R0,#'0'		; '0' character?
 6956/2FFC : 6D 2F F5                   	JP	Z,SUPTLZ	; Yes - Look back for more
 6957/2FFF : A6 E0 2E                   	CP	R0,#'.'		; A decimal point?
 6958/3002 : 6B 03                      	JR	Z,$+5
 6959/3004 : D6 2C 19                   	CALL	INCHL		; Move back over digit
 6960/3007 :                            ;
 6961/3007 :                            DOEBIT:
 6962/3007 : 50 E0                      	POP	R0
 6963/3009 : 50 E1                      	POP	R1		; Get 'E' flag
 6964/300B : 19 FC                      	LD	FLAGS,R1
 6965/300D : 6D 30 46                   	JP	Z,NOENED	; No 'E' needed - End buffer
 6966/3010 : 1C 45                      	LD	R1,#'E'
 6967/3012 : D2 12                      	LDC	@RR2,R1		; Put 'E' in buffer
 6968/3014 : 18 FC                      	LD	R1,FLAGS
 6969/3016 : A0 E2                      	INCW	RR2		; And move on
 6970/3018 : 19 FC                      	LD	FLAGS,R1
 6971/301A : 1C 2B                      	LD	R1,#'+'
 6972/301C : D2 12                      	LDC	@RR2,R1		; Put '+' in buffer
 6973/301E : DD 30 28                   	JP	PL,OUTEXP	; Positive - Output exponent
 6974/3021 : 1C 2D                      	LD	R1,#'-'
 6975/3023 : D2 12                      	LDC	@RR2,R1		; Put '-' in buffer
 6976/3025 : 60 E0                      	COM	R0		; Negate exponent
 6977/3027 : 0E                         	INC	R0
 6978/3028 :                            OUTEXP:
 6979/3028 : 4C 2F                      	LD	R4,#'0'-1	; ASCII '0' - 1
 6980/302A :                            EXPTEN:
 6981/302A : 4E                         	INC	R4		; Count subtractions
 6982/302B : 26 E0 0A                   	SUB	R0,#10		; Tens digit
 6983/302E : FD 30 2A                   	JP	NC,EXPTEN	; More to do
 6984/3031 : 06 E0 3A                   	ADD	R0,#'0'+10	; Restore and make ASCII
 6985/3034 : 18 FC                      	LD	R1,FLAGS
 6986/3036 : A0 E2                      	INCW	RR2		; Move on
 6987/3038 : 19 FC                      	LD	FLAGS,R1
 6988/303A : D2 42                      	LDC	@RR2,R4		; Save MSB of exponent
 6989/303C :                            JSTZER:
 6990/303C : 18 FC                      	LD	R1,FLAGS
 6991/303E : A0 E2                      	INCW	RR2		;
 6992/3040 : D2 02                      	LDC	@RR2,R0		; Save LSB of exponent
 6993/3042 : A0 E2                      	INCW	RR2
 6994/3044 : 19 FC                      	LD	FLAGS,R1
 6995/3046 :                            NOENED:
 6996/3046 : D2 52                      	LDC	@RR2,R5		; Mark end of buffer
 6997/3048 : 50 E2                      	POP	R2
 6998/304A : 50 E3                      	POP	R3		; Restore code string address
 6999/304C : AF                         	RET
 7000/304D :                            ;
 7001/304D :                            RNGTST:
 7002/304D : 4C 94                      	LD	R4,#hi(9474H)
 7003/304F : 5C 74                      	LD	R5,#lo(9474H)	; BCDE = 999999.
 7004/3051 : 6C 23                      	LD	R6,#hi(23F7H)
 7005/3053 : 7C F7                      	LD	R7,#lo(23F7H)
 7006/3055 : D6 2C 5A                   	CALL	CMPNUM		; Compare numbers
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 118 - 2023/10/26 22時18分50秒


 7007/3058 : 50 E2                      	POP	R2
 7008/305A : 50 E3                      	POP	R3		; Return address to HL
 7009/305C :                            ; OR	A
 7010/305C :                            ; JP	PO,GTSIXD		; Too big - Divide by ten
 7011/305C :                            
 7012/305C : 18 E0                      	LD	R1,R0		; @@@
 7013/305E : C0 E1                      	RRC	R1
 7014/3060 : C0 E1                      	RRC	R1
 7015/3062 : C0 E1                      	RRC	R1
 7016/3064 : C0 E1                      	RRC	R1
 7017/3066 : B2 10                      	XOR	R1,R0
 7018/3068 : 88 E1                      	LD	R8,R1
 7019/306A : C0 E1                      	RRC	R1
 7020/306C : C0 E1                      	RRC	R1
 7021/306E : B2 18                      	XOR	R1,R8
 7022/3070 : 88 E1                      	LD	R8,R1
 7023/3072 : C0 E1                      	RRC	R1
 7024/3074 : B2 18                      	XOR	R1,R8
 7025/3076 : 56 E1 01                   	AND	R1,#01H
 7026/3079 : ED 2F 1C                   	JP	NZ,GTSIXD
 7027/307C :                            
 7028/307C : 30 E2                      	JP	@RR2		; Otherwise return to caller
 7029/307E :                            ;
 7030/307E :                            HALF:
 7031/307E : 00 00 00 80                	DB	00H,00H,00H,80H	; 0.5
 7032/3082 :                            ;
 7033/3082 :                            POWERS:
 7034/3082 : A0 86 01                   	DB	0A0H,086H,001H	; 100000
 7035/3085 : 10 27 00                   	DB	010H,027H,000H	; 10000
 7036/3088 : E8 03 00                   	DB	0E8H,003H,000H	; 1000
 7037/308B : 64 00 00                   	DB	064H,000H,000H	; 100
 7038/308E : 0A 00 00                   	DB	00AH,000H,000H	; 10
 7039/3091 : 01 00 00                   	DB	001H,000H,000H	; 1
 7040/3094 :                            ;
 7041/3094 :                            NEGAFT:
 7042/3094 : 2C 2B                      	LD	R2,#hi(INVSGN)
 7043/3096 : 3C BC                      	LD	R3,#lo(INVSGN)	; Negate result
 7044/3098 : 50 E8                      	POP	R8
 7045/309A : 50 E9                      	POP	R9
 7046/309C : 70 E3                      	PUSH	R3
 7047/309E : 70 E2                      	PUSH	R2
 7048/30A0 : 28 E8                      	LD	R2,R8
 7049/30A2 : 38 E9                      	LD	R3,R9		; To be done after caller
 7050/30A4 : 30 E2                      	JP	@RR2		; Return to caller
 7051/30A6 :                            ;
 7052/30A6 :                            SQR:
 7053/30A6 : D6 2B C8                   	CALL	STAKFP		; Put value on stack
 7054/30A9 : 2C 30                      	LD	R2,#hi(HALF)
 7055/30AB : 3C 7E                      	LD	R3,#lo(HALF)	; Set power to 1/2
 7056/30AD : D6 2B EB                   	CALL	PHLTFP		; Move 1/2 to FPREG
 7057/30B0 :                            ;
 7058/30B0 :                            POWER:
 7059/30B0 : 50 E4                      	POP	R4
 7060/30B2 : 50 E5                      	POP	R5		; Get base
 7061/30B4 : 50 E6                      	POP	R6
 7062/30B6 : 50 E7                      	POP	R7
 7063/30B8 : D6 2B 76                   	CALL	TSTSGN		; Test sign of power
 7064/30BB : 08 E4                      	LD	R0,R4		; Get exponent of base
 7065/30BD : 6D 31 4B                   	JP	Z,EXP		; Make result 1 if zero
 7066/30C0 : DD 30 C9                   	JP	PL,POWER1	; Positive base - Ok
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 119 - 2023/10/26 22時18分50秒


 7067/30C3 : 42 00                      	OR	R0,R0
 7068/30C5 : CF                         	RCF			; Zero to negative power?
 7069/30C6 : 6D 05 03                   	JP	Z,DZERR		; Yes - ?/0 Error
 7070/30C9 :                            POWER1:
 7071/30C9 : 42 00                      	OR	R0,R0
 7072/30CB : CF                         	RCF			; Base zero?
 7073/30CC : 6D 28 08                   	JP	Z,SAVEXP	; Yes - Return zero
 7074/30CF : 70 E7                      	PUSH	R7
 7075/30D1 : 70 E6                      	PUSH	R6		; Save base
 7076/30D3 : 70 E5                      	PUSH	R5
 7077/30D5 : 70 E4                      	PUSH	R4
 7078/30D7 : 08 E5                      	LD	R0,R5		; Get MSB of base
 7079/30D9 : 46 E0 7F                   	OR	R0,#01111111B
 7080/30DC : CF                         	RCF			; Get sign status
 7081/30DD : D6 2C 03                   	CALL	BCDEFP		; Move power to BCDE
 7082/30E0 : DD 31 07                   	JP	PL,POWER2	; Positive base - Ok
 7083/30E3 : 70 E7                      	PUSH	R7
 7084/30E5 : 70 E6                      	PUSH	R6		; Save power
 7085/30E7 : 70 E5                      	PUSH	R5
 7086/30E9 : 70 E4                      	PUSH	R4
 7087/30EB : D6 2D 0C                   	CALL	INT		; Get integer of power
 7088/30EE : 50 E4                      	POP	R4
 7089/30F0 : 50 E5                      	POP	R5		; Restore power
 7090/30F2 : 50 E6                      	POP	R6
 7091/30F4 : 50 E7                      	POP	R7
 7092/30F6 : 18 FC                      	LD	R1,FLAGS
 7093/30F8 : 70 E1                      	PUSH	R1
 7094/30FA : 70 E0                      	PUSH	R0		; MSB of base
 7095/30FC : D6 2C 5A                   	CALL	CMPNUM		; Power an integer?
 7096/30FF : 50 E2                      	POP	R2
 7097/3101 : 50 E3                      	POP	R3		; Restore MSB of base
 7098/3103 : 08 E2                      	LD	R0,R2		; but don't affect flags
 7099/3105 : C0 E0                      	RRC	R0		; Exponent odd or even?
 7100/3107 :                            POWER2:
 7101/3107 : 50 E2                      	POP	R2
 7102/3109 : 50 E3                      	POP	R3		; Restore MSB and exponent
 7103/310B : 8C 81                      	LD	R8,#hi(FPREG+2)
 7104/310D : 9C 33                      	LD	R9,#lo(FPREG+2)
 7105/310F :                            
 7106/310F :                            ;	LDC	@RR8,R2
 7107/310F :                            ;	LD	R1,FLAGS
 7108/310F :                            ;	INCW	RR8
 7109/310F :                            ;	LD	FLAGS,R1
 7110/310F :                            ;	LDC	@RR8,R3		; Save base in FPREG
 7111/310F : D2 38                      	LDC	@RR8,R3		; @@@SWAP HL
 7112/3111 : 18 FC                      	LD	R1,FLAGS
 7113/3113 : A0 E8                      	INCW	RR8
 7114/3115 : 19 FC                      	LD	FLAGS,R1
 7115/3117 : D2 28                      	LDC	@RR8,R2		; Save base in FPREG
 7116/3119 :                            
 7117/3119 : 50 E2                      	POP	R2
 7118/311B : 50 E3                      	POP	R3		; LSBs of base
 7119/311D : 8C 81                      	LD	R8,#hi(FPREG)
 7120/311F : 9C 31                      	LD	R9,#lo(FPREG)
 7121/3121 :                            
 7122/3121 :                            ;	LDC	@RR8,R2
 7123/3121 :                            ;	LD	R1,FLAGS
 7124/3121 :                            ;	INCW	RR8
 7125/3121 :                            ;	LD	FLAGS,R1
 7126/3121 :                            ;	LDC	@RR8,R3		; Save in FPREG
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 120 - 2023/10/26 22時18分50秒


 7127/3121 : D2 38                      	LDC	@RR8,R3		; @@@ SWAP HL
 7128/3123 : 18 FC                      	LD	R1,FLAGS
 7129/3125 : A0 E8                      	INCW	RR8
 7130/3127 : 19 FC                      	LD	FLAGS,R1
 7131/3129 : D2 28                      	LDC	@RR8,R2		; Save in FPREG
 7132/312B :                            
 7133/312B : FB 03                      	JR	NC,$+5
 7134/312D : D6 30 94                   	CALL	NEGAFT		; Odd power - Negate result
 7135/3130 : EB 03                      	JR	NZ,$+5
 7136/3132 : D6 2B BC                   	CALL	INVSGN		; Negative base - Negate it
 7137/3135 : 70 E7                      	PUSH	R7
 7138/3137 : 70 E6                      	PUSH	R6		; Save power
 7139/3139 : 70 E5                      	PUSH	R5
 7140/313B : 70 E4                      	PUSH	R4
 7141/313D : D6 28 FA                   	CALL	LOG		; Get LOG of base
 7142/3140 : 50 E4                      	POP	R4
 7143/3142 : 50 E5                      	POP	R5		; Restore power
 7144/3144 : 50 E6                      	POP	R6
 7145/3146 : 50 E7                      	POP	R7
 7146/3148 : D6 29 80                   	CALL	FPMULT		; Multiply LOG by power
 7147/314B :                            ;
 7148/314B :                            EXP:
 7149/314B : D6 2B C8                   	CALL	STAKFP		; Put value on stack
 7150/314E : 4C 81                      	LD	R4,#hi(08138H)
 7151/3150 : 5C 38                      	LD	R5,#lo(08138H)	; BCDE = 1/Ln(2)
 7152/3152 : 6C AA                      	LD	R6,#hi(0AA3BH)
 7153/3154 : 7C 3B                      	LD	R7,#lo(0AA3BH)
 7154/3156 : D6 29 80                   	CALL	FPMULT		; Multiply value by 1/LN(2)
 7155/3159 : 8C 81                      	LD	R8,#hi(FPEXP)
 7156/315B : 9C 34                      	LD	R9,#lo(FPEXP)
 7157/315D : C2 08                      	LDC	R0,@RR8		; Get exponent
 7158/315F : A6 E0 88                   	CP	R0,#80H+8		; Is it in range?
 7159/3162 : FD 2B 3B                   	JP	NC,OVTST1	; No - Test for overflow
 7160/3165 : D6 2D 0C                   	CALL	INT		; Get INT of FPREG
 7161/3168 : 06 E0 80                   	ADD	R0,#80H		; For excess 128
 7162/316B : 06 E0 02                   	ADD	R0,#2		; Exponent > 126?
 7163/316E : 7D 2B 3B                   	JP	C,OVTST1	; Yes - Test for overflow
 7164/3171 : 18 FC                      	LD	R1,FLAGS
 7165/3173 : 70 E1                      	PUSH	R1
 7166/3175 : 70 E0                      	PUSH	R0		; Save scaling factor
 7167/3177 : 2C 28                      	LD	R2,#hi(UNITY)
 7168/3179 : 3C E9                      	LD	R3,#lo(UNITY)	; Point to 1.
 7169/317B : D6 27 25                   	CALL	ADDPHL		; Add 1 to FPREG
 7170/317E : D6 29 6E                   	CALL	MULLN2		; Multiply by LN(2)
 7171/3181 : 50 E0                      	POP	R0		; Restore scaling factor
 7172/3183 : 50 E1                      	POP	R1
 7173/3185 : 19 FC                      	LD	FLAGS,R1
 7174/3187 : 50 E4                      	POP	R4
 7175/3189 : 50 E5                      	POP	R5		; Restore exponent
 7176/318B : 50 E6                      	POP	R6
 7177/318D : 50 E7                      	POP	R7
 7178/318F : 18 FC                      	LD	R1,FLAGS
 7179/3191 : 70 E1                      	PUSH	R1
 7180/3193 : 70 E0                      	PUSH	R0		; Save scaling factor
 7181/3195 : D6 27 38                   	CALL	SUBCDE		; Subtract exponent from FPREG
 7182/3198 : D6 2B BC                   	CALL	INVSGN		; Negate result
 7183/319B : 2C 31                      	LD	R2,#hi(EXPTAB)
 7184/319D : 3C AF                      	LD	R3,#lo(EXPTAB)	; Coefficient table
 7185/319F : D6 31 E9                   	CALL	SMSER1		; Sum the series
 7186/31A2 : 6C 00                      	LD	R6,#hi(0)
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 121 - 2023/10/26 22時18分50秒


 7187/31A4 : 7C 00                      	LD	R7,#lo(0)	; Zero LSBs
 7188/31A6 : 50 E4                      	POP	R4
 7189/31A8 : 50 E5                      	POP	R5		; Scaling factor
 7190/31AA : 58 E6                      	LD	R5,R6		; Zero MSB
 7191/31AC : 8D 29 80                   	JP	FPMULT		; Scale result to correct value
 7192/31AF :                            ;
 7193/31AF :                            EXPTAB:
 7194/31AF : 08                         	DB	8			; Table used by EXP
 7195/31B0 : 40 2E 94 74                	DB	040H,02EH,094H,074H	; -1/7! (-1/5040)
 7196/31B4 : 70 4F 2E 77                	DB	070H,04FH,02EH,077H	;  1/6! ( 1/720)
 7197/31B8 : 6E 02 88 7A                	DB	06EH,002H,088H,07AH	; -1/5! (-1/120)
 7198/31BC : E6 A0 2A 7C                	DB	0E6H,0A0H,02AH,07CH	;  1/4! ( 1/24)
 7199/31C0 : 50 AA AA 7E                	DB	050H,0AAH,0AAH,07EH	; -1/3! (-1/6)
 7200/31C4 : FF FF 7F 7F                	DB	0FFH,0FFH,07FH,07FH	;  1/2! ( 1/2)
 7201/31C8 : 00 00 80 81                	DB	000H,000H,080H,081H	; -1/1! (-1/1)
 7202/31CC : 00 00 00 81                	DB	000H,000H,000H,081H	;  1/0! ( 1/1)
 7203/31D0 :                            ;
 7204/31D0 :                            SUMSER:
 7205/31D0 : D6 2B C8                   	CALL	STAKFP		; Put FPREG on stack
 7206/31D3 : 6C 29                      	LD	R6,#hi(MULT)
 7207/31D5 : 7C 78                      	LD	R7,#lo(MULT)	; Multiply by "X"
 7208/31D7 : 70 E7                      	PUSH	R7
 7209/31D9 : 70 E6                      	PUSH	R6		; To be done after
 7210/31DB : 70 E3                      	PUSH	R3
 7211/31DD : 70 E2                      	PUSH	R2		; Save address of table
 7212/31DF : D6 2C 03                   	CALL	BCDEFP		; Move FPREG to BCDE
 7213/31E2 : D6 29 80                   	CALL	FPMULT		; Square the value
 7214/31E5 : 50 E2                      	POP	R2
 7215/31E7 : 50 E3                      	POP	R3		; Restore address of table
 7216/31E9 :                            SMSER1:
 7217/31E9 : D6 2B C8                   	CALL	STAKFP		; Put value on stack
 7218/31EC : C2 02                      	LDC	R0,@RR2		; Get number of coefficients
 7219/31EE : A0 E2                      	INCW	RR2		; Point to start of table
 7220/31F0 : D6 2B EB                   	CALL	PHLTFP		; Move coefficient to FPREG
 7221/31F3 : 8B 06                      	JR	SUMLP1		; Skip "POP AF"
 7222/31F5 :                            SUMLP:
 7223/31F5 : 50 E0                      	POP	R0		; Restore count
 7224/31F7 : 50 E1                      	POP	R1
 7225/31F9 : 19 FC                      	LD	FLAGS,R1
 7226/31FB :                            SUMLP1:
 7227/31FB : 50 E4                      	POP	R4
 7228/31FD : 50 E5                      	POP	R5		; Restore number
 7229/31FF : 50 E6                      	POP	R6
 7230/3201 : 50 E7                      	POP	R7
 7231/3203 : 00 E0                      	DEC	R0		; Cont coefficients
 7232/3205 : EB 01                      	JR	NZ,$+3
 7233/3207 : AF                         	RET			; All done
 7234/3208 : 70 E7                      	PUSH	R7
 7235/320A : 70 E6                      	PUSH	R6		; Save number
 7236/320C : 70 E5                      	PUSH	R5
 7237/320E : 70 E4                      	PUSH	R4
 7238/3210 : 18 FC                      	LD	R1,FLAGS
 7239/3212 : 70 E1                      	PUSH	R1
 7240/3214 : 70 E0                      	PUSH	R0		; Save count
 7241/3216 : 70 E3                      	PUSH	R3
 7242/3218 : 70 E2                      	PUSH	R2		; Save address in table
 7243/321A : D6 29 80                   	CALL	FPMULT		; Multiply FPREG by BCDE
 7244/321D : 50 E2                      	POP	R2
 7245/321F : 50 E3                      	POP	R3		; Restore address in table
 7246/3221 : D6 2C 07                   	CALL	LOADFP		; Number at HL to BCDE
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 122 - 2023/10/26 22時18分50秒


 7247/3224 : 70 E3                      	PUSH	R3
 7248/3226 : 70 E2                      	PUSH	R2		; Save address in table
 7249/3228 : D6 27 3B                   	CALL	FPADD		; Add coefficient to FPREG
 7250/322B : 50 E2                      	POP	R2
 7251/322D : 50 E3                      	POP	R3		; Restore address in table
 7252/322F : 8D 31 F5                   	JP	SUMLP		; More coefficients
 7253/3232 :                            ;
 7254/3232 :                            RND:
 7255/3232 : D6 2B 76                   	CALL	TSTSGN		; Test sign of FPREG
 7256/3235 : 2C 80                      	LD	R2,#hi(SEED+2)
 7257/3237 : 3C 65                      	LD	R3,#lo(SEED+2)	; Random number seed
 7258/3239 : 5D 32 D4                   	JP	MI,RESEED	; Negative - Re-seed
 7259/323C : 2C 80                      	LD	R2,#hi(LSTRND)
 7260/323E : 3C 87                      	LD	R3,#lo(LSTRND)	; Last random number
 7261/3240 : D6 2B EB                   	CALL	PHLTFP		; Move last RND to FPREG
 7262/3243 : 2C 80                      	LD	R2,#hi(SEED+2)
 7263/3245 : 3C 65                      	LD	R3,#lo(SEED+2)	; Random number seed
 7264/3247 : EB 01                      	JR	NZ,$+3
 7265/3249 : AF                         	RET			; Return if RND(0)
 7266/324A : C2 82                      	LDC	R8,@RR2
 7267/324C : 02 08                      	ADD	R0,R8		; Add (SEED)+2)
 7268/324E : 56 E0 07                   	AND	R0,#00000111B	; 0 to 7
 7269/3251 : 4C 00                      	LD	R4,#0
 7270/3253 : D2 02                      	LDC	@RR2,R0		; Re-save seed
 7271/3255 : A0 E2                      	INCW	RR2		; Move to coefficient table
 7272/3257 : 02 00                      	ADD	R0,R0		; 4 bytes
 7273/3259 : 02 00                      	ADD	R0,R0		; per entry
 7274/325B : 58 E0                      	LD	R5,R0		; BC = Offset into table
 7275/325D : 02 35                      	ADD	R3,R5
 7276/325F : 12 24                      	ADC	R2,R4		; Point to coefficient
 7277/3261 : D6 2C 07                   	CALL	LOADFP		; Coefficient to BCDE
 7278/3264 :                            
 7279/3264 : 88 E4                      	LD	R8,R4		; @@@ SWAP BC
 7280/3266 : 48 E5                      	LD	R4,R5
 7281/3268 : 58 E8                      	LD	R5,R8
 7282/326A : 88 E6                      	LD	R8,R6		; @@@ SWAP DE
 7283/326C : 68 E7                      	LD	R6,R7
 7284/326E : 78 E8                      	LD	R7,R8
 7285/3270 :                            
 7286/3270 : D6 29 80                   	CALL	FPMULT	;	; Multiply FPREG by coefficient
 7287/3273 : 8C 80                      	LD	R8,#hi(SEED+1)
 7288/3275 : 9C 64                      	LD	R9,#lo(SEED+1)
 7289/3277 : C2 08                      	LDC	R0,@RR8		; Get (SEED+1)
 7290/3279 : 0E                         	INC	R0		; Add 1
 7291/327A : 56 E0 03                   	AND	R0,#00000011B	; 0 to 3
 7292/327D : 4C 00                      	LD	R4,#0
 7293/327F : A6 E0 01                   	CP	R0,#1		; Is it zero?
 7294/3282 : 12 04                      	ADC	R0,R4		; Yes - Make it 1
 7295/3284 : 8C 80                      	LD	R8,#hi(SEED+1)
 7296/3286 : 9C 64                      	LD	R9,#lo(SEED+1)
 7297/3288 : D2 08                      	LDC	@RR8,R0		; Re-save seed
 7298/328A : 2C 32                      	LD	R2,#hi(RNDTAB-4)
 7299/328C : 3C DD                      	LD	R3,#lo(RNDTAB-4); Addition table
 7300/328E : 02 00                      	ADD	R0,R0		; 4 bytes
 7301/3290 : 02 00                      	ADD	R0,R0		; per entry
 7302/3292 : 58 E0                      	LD	R5,R0		; BC = Offset into table
 7303/3294 : 02 35                      	ADD	R3,R5
 7304/3296 : 12 24                      	ADC	R2,R4		; Point to value
 7305/3298 : D6 27 25                   	CALL	ADDPHL		; Add value to FPREG
 7306/329B :                            RND1:
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 123 - 2023/10/26 22時18分50秒


 7307/329B : D6 2C 03                   	CALL	BCDEFP		; Move FPREG to BCDE
 7308/329E : 08 E7                      	LD	R0,R7		; Get LSB
 7309/32A0 : 78 E5                      	LD	R7,R5		; LSB = MSB
 7310/32A2 : B6 E0 4F                   	XOR	R0,#01001111B	; Fiddle around
 7311/32A5 : 58 E0                      	LD	R5,R0		; New MSB
 7312/32A7 : 1C 80                      	LD	R1,#80H
 7313/32A9 : D2 12                      	LDC	@RR2,R1		; Set exponent
 7314/32AB : 80 E2                      	DECW	RR2		; Point to MSB
 7315/32AD : C2 42                      	LDC	R4,@RR2		; Get MSB
 7316/32AF : 1C 80                      	LD	R1,#80H
 7317/32B1 : D2 12                      	LDC	@RR2,R1		; Make value -0.5
 7318/32B3 : 2C 80                      	LD	R2,#hi(SEED)
 7319/32B5 : 3C 63                      	LD	R3,#lo(SEED)	; Random number seed
 7320/32B7 : C2 82                      	LDC	R8,@RR2
 7321/32B9 : 8E                         	INC	R8
 7322/32BA : D2 82                      	LDC	@RR2,R8		; Count seed
 7323/32BC : C2 02                      	LDC	R0,@RR2		; Get seed
 7324/32BE : 26 E0 AB                   	SUB	R0,#171		; Do it modulo 171
 7325/32C1 : ED 32 CA                   	JP	NZ,RND2		; Non-zero - Ok
 7326/32C4 : D2 02                      	LDC	@RR2,R0		; Zero seed
 7327/32C6 : 5E                         	INC	R5		; Fillde about
 7328/32C7 : 00 E6                      	DEC	R6		; with the
 7329/32C9 : 7E                         	INC	R7		; number
 7330/32CA :                            RND2:
 7331/32CA : D6 27 E3                   	CALL	BNORM		; Normalise number
 7332/32CD : 2C 80                      	LD	R2,#hi(LSTRND)
 7333/32CF : 3C 87                      	LD	R3,#lo(LSTRND)	; Save random number
 7334/32D1 : 8D 2C 20                   	JP	FPTHL		; Move FPREG to last and return
 7335/32D4 :                            ;
 7336/32D4 :                            RESEED:
 7337/32D4 : D2 02                      	LDC	@RR2,R0		; Re-seed random numbers
 7338/32D6 : 80 E2                      	DECW	RR2
 7339/32D8 : D2 02                      	LDC	@RR2,R0
 7340/32DA : 80 E2                      	DECW	RR2
 7341/32DC : D2 02                      	LDC	@RR2,R0
 7342/32DE : 8D 32 9B                   	JP	RND1		; Return RND seed
 7343/32E1 :                            ;
 7344/32E1 :                            RNDTAB:
 7345/32E1 : 68 B1 46 68                	DB	068H,0B1H,046H,068H	; Table used by RND
 7346/32E5 : 99 E9 92 69                	DB	099H,0E9H,092H,069H
 7347/32E9 : 10 D1 75 68                	DB	010H,0D1H,075H,068H
 7348/32ED :                            ;
 7349/32ED :                            COS:
 7350/32ED : 2C 33                      	LD	R2,#hi(HALFPI)
 7351/32EF : 3C 59                      	LD	R3,#lo(HALFPI)	; Point to PI/2
 7352/32F1 : D6 27 25                   	CALL	ADDPHL		; Add it to PPREG
 7353/32F4 :                            SIN:
 7354/32F4 : D6 2B C8                   	CALL	STAKFP		; Put angle on stack
 7355/32F7 : 4C 83                      	LD	R4,#hi(8349H)
 7356/32F9 : 5C 49                      	LD	R5,#lo(8349H)	; BCDE = 2 PI
 7357/32FB : 6C 0F                      	LD	R6,#hi(0FDBH)
 7358/32FD : 7C DB                      	LD	R7,#lo(0FDBH)
 7359/32FF : D6 2B EE                   	CALL	FPBCDE		; Move 2 PI to FPREG
 7360/3302 : 50 E4                      	POP	R4
 7361/3304 : 50 E5                      	POP	R5		; Restore angle
 7362/3306 : 50 E6                      	POP	R6
 7363/3308 : 50 E7                      	POP	R7
 7364/330A : D6 2A 40                   	CALL	DVBCDE		; Divide angle by 2 PI
 7365/330D : D6 2B C8                   	CALL	STAKFP		; Put it on stack
 7366/3310 : D6 2D 0C                   	CALL	INT		; Get INT of result
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 124 - 2023/10/26 22時18分50秒


 7367/3313 : 50 E4                      	POP	R4
 7368/3315 : 50 E5                      	POP	R5		; Restore number
 7369/3317 : 50 E6                      	POP	R6
 7370/3319 : 50 E7                      	POP	R7
 7371/331B : D6 27 38                   	CALL	SUBCDE		; Make it 0 <= value < 1
 7372/331E : 2C 33                      	LD	R2,#hi(QUARTR)
 7373/3320 : 3C 5D                      	LD	R3,#lo(QUARTR)	; Point to 0.25
 7374/3322 : D6 27 2B                   	CALL	SUBPHL		; Subtract value from 0.25
 7375/3325 : D6 2B 76                   	CALL	TSTSGN		; Test sign of value
 7376/3328 : DF                         	SCF			; Flag positive
 7377/3329 : DD 33 35                   	JP	PL,SIN1		; Positive - Ok
 7378/332C : D6 27 21                   	CALL	ROUND		; Add 0.5 to value
 7379/332F : D6 2B 76                   	CALL	TSTSGN		; Test sign of value
 7380/3332 : 42 00                      	OR	R0,R0
 7381/3334 : CF                         	RCF			; Flag negative
 7382/3335 :                            SIN1:
 7383/3335 : 18 FC                      	LD	R1,FLAGS
 7384/3337 : 70 E1                      	PUSH	R1
 7385/3339 : 70 E0                      	PUSH	R0		; Save sign
 7386/333B : 5B 03                      	JR	MI,$+5
 7387/333D : D6 2B BC                   	CALL	INVSGN		; Negate value if positive
 7388/3340 : 2C 33                      	LD	R2,#hi(QUARTR)
 7389/3342 : 3C 5D                      	LD	R3,#lo(QUARTR)	; Point to 0.25
 7390/3344 : D6 27 25                   	CALL	ADDPHL		; Add 0.25 to value
 7391/3347 : 50 E0                      	POP	R0
 7392/3349 : 50 E1                      	POP	R1		; Restore sign
 7393/334B : 19 FC                      	LD	FLAGS,R1
 7394/334D : 7B 03                      	JR	C,$+5
 7395/334F : D6 2B BC                   	CALL	INVSGN		; Negative - Make positive
 7396/3352 : 2C 33                      	LD	R2,#hi(SINTAB)
 7397/3354 : 3C 61                      	LD	R3,#lo(SINTAB)	; Coefficient table
 7398/3356 : 8D 31 D0                   	JP	SUMSER		; Evaluate sum of series
 7399/3359 :                            ;
 7400/3359 :                            HALFPI:
 7401/3359 : DB 0F 49 81                	DB	0DBH,00FH,049H,081H	; 1.5708 (PI/2)
 7402/335D :                            ;
 7403/335D :                            QUARTR:
 7404/335D : 00 00 00 7F                	DB	000H,000H,000H,07FH	; 0.25
 7405/3361 :                            ;
 7406/3361 :                            SINTAB:
 7407/3361 : 05                         	DB	5			; Table used by SIN
 7408/3362 : BA D7 1E 86                	DB	0BAH,0D7H,01EH,086H	; 39.711
 7409/3366 : 64 26 99 87                	DB	064H,026H,099H,087H	;-76.575
 7410/336A : 58 34 23 87                	DB	058H,034H,023H,087H	; 81.602
 7411/336E : E0 5D A5 86                	DB	0E0H,05DH,0A5H,086H	;-41.342
 7412/3372 : DA 0F 49 83                	DB	0DAH,00FH,049H,083H	; 6.2832
 7413/3376 :                            ;
 7414/3376 :                            TAN:
 7415/3376 : D6 2B C8                   	CALL	STAKFP		; Put angle on stack
 7416/3379 : D6 32 F4                   	CALL	SIN		; Get SIN of angle
 7417/337C : 50 E4                      	POP	R4
 7418/337E : 50 E5                      	POP	R5		; Restore angle
 7419/3380 : 50 E2                      	POP	R2
 7420/3382 : 50 E3                      	POP	R3
 7421/3384 : D6 2B C8                   	CALL	STAKFP		; Save SIN of angle
 7422/3387 : 88 E6                      	LD	R8,R6
 7423/3389 : 98 E7                      	LD	R9,R7
 7424/338B : 68 E2                      	LD	R6,R2
 7425/338D : 78 E3                      	LD	R7,R3
 7426/338F : 28 E8                      	LD	R2,R8
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 125 - 2023/10/26 22時18分50秒


 7427/3391 : 38 E9                      	LD	R3,R9		; BCDE = Angle
 7428/3393 : D6 2B EE                   	CALL	FPBCDE		; Angle to FPREG
 7429/3396 : D6 32 ED                   	CALL	COS		; Get COS of angle
 7430/3399 : 8D 2A 38                   	JP	DIV		; TAN = SIN / COS
 7431/339C :                            ;
 7432/339C :                            ATN:
 7433/339C : D6 2B 76                   	CALL	TSTSGN		; Test sign of value
 7434/339F : DB 03                      	JR	PL,$+5
 7435/33A1 : D6 2B BC                   	CALL	INVSGN		; Negate result after if -ve
 7436/33A4 : DB 03                      	JR	PL,$+5
 7437/33A6 : D6 2B BC                   	CALL	INVSGN		; Negate value if -ve
 7438/33A9 : 8C 81                      	LD	R8,#hi(FPEXP)
 7439/33AB : 9C 34                      	LD	R9,#lo(FPEXP)
 7440/33AD : C2 08                      	LDC	R0,@RR8		; Get exponent
 7441/33AF : A6 E0 81                   	CP	R0,#81H		; Number less than 1?
 7442/33B2 : 7D 33 C8                   	JP	C,ATN1		; Yes - Get arc tangnt
 7443/33B5 : 4C 81                      	LD	R4,#hi(8100H)
 7444/33B7 : 5C 00                      	LD	R5,#lo(8100H)	; BCDE = 1
 7445/33B9 : 68 E5                      	LD	R6,R5
 7446/33BB : 78 E5                      	LD	R7,R5
 7447/33BD : D6 2A 40                   	CALL	DVBCDE		; Get reciprocal of number
 7448/33C0 : 2C 27                      	LD	R2,#hi(SUBPHL)
 7449/33C2 : 3C 2B                      	LD	R3,#lo(SUBPHL)	; Sub angle from PI/2
 7450/33C4 : 70 E3                      	PUSH	R3
 7451/33C6 : 70 E2                      	PUSH	R2		; Save for angle > 1
 7452/33C8 :                            ATN1:
 7453/33C8 : 2C 33                      	LD	R2,#hi(ATNTAB)
 7454/33CA : 3C D4                      	LD	R3,#lo(ATNTAB)	; Coefficient table
 7455/33CC : D6 31 D0                   	CALL	SUMSER		; Evaluate sum of series
 7456/33CF : 2C 33                      	LD	R2,#hi(HALFPI)
 7457/33D1 : 3C 59                      	LD	R3,#lo(HALFPI)	; PI/2 - angle in case > 1
 7458/33D3 : AF                         	RET		; Number > 1 - Sub from PI/2
 7459/33D4 :                            ;
 7460/33D4 :                            ATNTAB:
 7461/33D4 : 09                         	DB	9			; Table used by ATN
 7462/33D5 : 4A D7 3B 78                	DB	04AH,0D7H,03BH,078H	; 1/17
 7463/33D9 : 02 6E 84 7B                	DB	002H,06EH,084H,07BH	;-1/15
 7464/33DD : FE C1 2F 7C                	DB	0FEH,0C1H,02FH,07CH	; 1/13
 7465/33E1 : 74 31 9A 7D                	DB	074H,031H,09AH,07DH	;-1/11
 7466/33E5 : 84 3D 5A 7D                	DB	084H,03DH,05AH,07DH	; 1/9
 7467/33E9 : C8 7F 91 7E                	DB	0C8H,07FH,091H,07EH	;-1/7
 7468/33ED : E4 BB 4C 7E                	DB	0E4H,0BBH,04CH,07EH	; 1/5
 7469/33F1 : 6C AA AA 7F                	DB	06CH,0AAH,0AAH,07FH	;-1/3
 7470/33F5 : 00 00 00 81                	DB	000H,000H,000H,081H	; 1/1
 7471/33F9 :                            ;
 7472/33F9 :                            
 7473/33F9 :                            ARET:
 7474/33F9 : AF                         	RET			; A RETurn instruction
 7475/33FA :                            ;
 7476/33FA :                            GETINP:
 7477/33FA : D6 00 3C                   	CALL	CONIN		;input a character
 7478/33FD : AF                         	RET
 7479/33FE :                            ;
 7480/33FE :                            CLS:
 7481/33FE : 0C 0C                      	LD	R0,#CS		; ASCII Clear screen
 7482/3400 : 8D 36 1D                   	JP	MONOUT		; Output character
 7483/3403 :                            ;
 7484/3403 :                            WIDTH:
 7485/3403 : D6 26 EB                   	CALL	GETINT		; Get integer 0-255
 7486/3406 : 08 E7                      	LD	R0,R7		; Width to A
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 126 - 2023/10/26 22時18分50秒


 7487/3408 : 8C 80                      	LD	R8,#hi(LWIDTH)
 7488/340A : 9C 8F                      	LD	R9,#lo(LWIDTH)
 7489/340C : D2 08                      	LDC	@RR8,R0		; Set width
 7490/340E : AF                         	RET
 7491/340F :                            ;
 7492/340F :                            LINES:
 7493/340F : D6 16 7D                   	CALL	GETNUM		; Get a number
 7494/3412 : D6 0F 57                   	CALL	DEINT		; Get integer -32768 to 32767
 7495/3415 : 8C 80                      	LD	R8,#hi(LINESC)
 7496/3417 : 9C 93                      	LD	R9,#lo(LINESC)
 7497/3419 : D2 68                      	LDC	@RR8,R6
 7498/341B : 18 FC                      	LD	R1,FLAGS
 7499/341D : A0 E8                      	INCW	RR8
 7500/341F : 19 FC                      	LD	FLAGS,R1
 7501/3421 : D2 78                      	LDC	@RR8,R7		; Set lines counter
 7502/3423 : 8C 80                      	LD	R8,#hi(LINESN)
 7503/3425 : 9C 95                      	LD	R9,#lo(LINESN)
 7504/3427 : D2 68                      	LDC	@RR8,R6
 7505/3429 : 18 FC                      	LD	R1,FLAGS
 7506/342B : A0 E8                      	INCW	RR8
 7507/342D : 19 FC                      	LD	FLAGS,R1
 7508/342F : D2 78                      	LDC	@RR8,R7		; Set lines number
 7509/3431 : AF                         	RET
 7510/3432 :                            ;
 7511/3432 :                            DEEK:
 7512/3432 : D6 0F 57                   	CALL	DEINT		; Get integer -32768 to 32767
 7513/3435 : 70 E7                      	PUSH	R7
 7514/3437 : 70 E6                      	PUSH	R6		; Save number
 7515/3439 : 50 E2                      	POP	R2
 7516/343B : 50 E3                      	POP	R3		; Number to HL
 7517/343D : C2 42                      	LDC	R4,@RR2		; Get LSB of contents
 7518/343F : 18 FC                      	LD	R1,FLAGS
 7519/3441 : A0 E2                      	INCW	RR2
 7520/3443 : 19 FC                      	LD	FLAGS,R1
 7521/3445 : C2 02                      	LDC	R0,@RR2		; Get MSB of contents
 7522/3447 : 8D 1E B3                   	JP	ABPASS		; Return integer AB
 7523/344A :                            ;
 7524/344A :                            DOKE:
 7525/344A : D6 16 7D                   	CALL	GETNUM		; Get a number
 7526/344D : D6 0F 57                   	CALL	DEINT		; Get integer -32768 to 32767
 7527/3450 : 70 E7                      	PUSH	R7
 7528/3452 : 70 E6                      	PUSH	R6		; Save address
 7529/3454 : D6 0A 49                   	CALL	CHKSYN		; Make sure ',' follows
 7530/3457 : 2C                         	DB	','
 7531/3458 : D6 16 7D                   	CALL	GETNUM		; Get a number
 7532/345B : D6 0F 57                   	CALL	DEINT		; Get integer -32768 to 32767
 7533/345E : 50 E8                      	POP	R8
 7534/3460 : 50 E9                      	POP	R9
 7535/3462 : 70 E3                      	PUSH	R3
 7536/3464 : 70 E2                      	PUSH	R2
 7537/3466 : 28 E8                      	LD	R2,R8
 7538/3468 : 38 E9                      	LD	R3,R9		; Save value,get address
 7539/346A : D2 72                      	LDC	@RR2,R7		; Save LSB of value
 7540/346C : 18 FC                      	LD	R1,FLAGS
 7541/346E : A0 E2                      	INCW	RR2
 7542/3470 : 19 FC                      	LD	FLAGS,R1
 7543/3472 : D2 62                      	LDC	@RR2,R6		; Save MSB of value
 7544/3474 : 50 E2                      	POP	R2
 7545/3476 : 50 E3                      	POP	R3		; Restore code string address
 7546/3478 : AF                         	RET
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 127 - 2023/10/26 22時18分50秒


 7547/3479 :                            ;
 7548/3479 :                            
 7549/3479 :                            ; HEX$(nn) Convert 16 bit number to Hexadecimal string
 7550/3479 :                            ;
 7551/3479 :                            HEX:
 7552/3479 : D6 16 80                   	CALL	TSTNUM		; Verify it's a number
 7553/347C : D6 0F 57                   	CALL	DEINT		; Get integer -32768 to 32767
 7554/347F : 70 E5                      	PUSH	R5
 7555/3481 : 70 E4                      	PUSH	R4		; Save contents of BC
 7556/3483 : 2C 81                      	LD	R2,#hi(PBUFF)
 7557/3485 : 3C 36                      	LD	R3,#lo(PBUFF)
 7558/3487 : 08 E6                      	LD	R0,R6		; Get high order into A
 7559/3489 : A6 E0 00                   	CP	R0,#0
 7560/348C : 6B 12                      	JR	Z,HEX2		; Skip output if both high digits are zero
 7561/348E : D6 34 CE                   	CALL	BYT2ASC		; Convert D to ASCII
 7562/3491 : 08 E4                      	LD	R0,R4
 7563/3493 : A6 E0 30                   	CP	R0,#'0'
 7564/3496 : 6B 04                      	JR	Z,HEX1		; Don't store high digit if zero
 7565/3498 : D2 42                      	LDC	@RR2,R4		; Store it to PBUFF
 7566/349A : A0 E2                      	INCW	RR2		; Next location
 7567/349C :                            HEX1:
 7568/349C : D2 52                      	LDC	@RR2,R5		; Store C to PBUFF+1
 7569/349E : A0 E2                      	INCW	RR2		; Next location
 7570/34A0 :                            HEX2:
 7571/34A0 : 08 E7                      	LD	R0,R7		; Get lower byte
 7572/34A2 : D6 34 CE                   	CALL	BYT2ASC		; Convert E to ASCII
 7573/34A5 : 08 E6                      	LD	R0,R6
 7574/34A7 : A6 E0 00                   	CP	R0,#0
 7575/34AA : EB 07                      	JR	NZ,HEX3		; If upper byte was not zero then always print lower byte
 7576/34AC : 08 E4                      	LD	R0,R4
 7577/34AE : A6 E0 30                   	CP	R0,#'0'		; If high digit of lower byte is zero then don't print
 7578/34B1 : 6B 04                      	JR	Z,HEX4
 7579/34B3 :                            HEX3:
 7580/34B3 : D2 42                      	LDC	@RR2,R4		; to PBUFF+2
 7581/34B5 : A0 E2                      	INCW	RR2		; Next location
 7582/34B7 :                            HEX4:
 7583/34B7 : D2 52                      	LDC	@RR2,R5		; to PBUFF+3
 7584/34B9 : A0 E2                      	INCW	RR2		; PBUFF+4 to zero
 7585/34BB : B2 00                      	XOR	R0,R0		; Terminating character
 7586/34BD : D2 02                      	LDC	@RR2,R0		; Store zero to terminate
 7587/34BF : A0 E2                      	INCW	RR2		; Make sure PBUFF is terminated
 7588/34C1 : D2 02                      	LDC	@RR2,R0		; Store the double zero there
 7589/34C3 : 50 E4                      	POP	R4
 7590/34C5 : 50 E5                      	POP	R5		; Get BC back
 7591/34C7 : 2C 81                      	LD	R2,#hi(PBUFF)
 7592/34C9 : 3C 36                      	LD	R3,#lo(PBUFF)	; Reset to start of PBUFF
 7593/34CB : 8D 20 25                   	JP	STR1		; Convert the PBUFF to a string and return it
 7594/34CE :                            ;
 7595/34CE :                            BYT2ASC:
 7596/34CE : 48 E0                      	LD	R4,R0		; Save original value
 7597/34D0 : 56 E0 0F                   	AND	R0,#0FH		; Strip off upper nybble
 7598/34D3 : A6 E0 0A                   	CP	R0,#0AH		; 0-9?
 7599/34D6 : 7B 03                      	JR	C,ADD30		; If A-F, add 7 more
 7600/34D8 : 06 E0 07                   	ADD	R0,#07H		; Bring value up to ASCII A-F
 7601/34DB :                            ADD30:
 7602/34DB : 06 E0 30                   	ADD	R0,#30H		; And make ASCII
 7603/34DE : 58 E0                      	LD	R5,R0		; Save converted char to C
 7604/34E0 : 08 E4                      	LD	R0,R4		; Retrieve original value
 7605/34E2 : E0 E0                      	RR	R0		; and Rotate it right
 7606/34E4 : E0 E0                      	RR	R0
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 128 - 2023/10/26 22時18分50秒


 7607/34E6 : E0 E0                      	RR	R0
 7608/34E8 : E0 E0                      	RR	R0
 7609/34EA : 56 E0 0F                   	AND	R0,#0FH		; Mask off upper nybble
 7610/34ED : A6 E0 0A                   	CP	R0,#0AH		; 0-9? < A hex?
 7611/34F0 : 7B 03                      	JR	C,ADD301	; Skip Add 7
 7612/34F2 : 06 E0 07                   	ADD	R0,#07H		; Bring it up to ASCII A-F
 7613/34F5 :                            ADD301:
 7614/34F5 : 06 E0 30                   	ADD	R0,#30H		; And make it full ASCII
 7615/34F8 : 48 E0                      	LD	R4,R0		; Store high order byte
 7616/34FA : AF                         	RET
 7617/34FB :                            ;
 7618/34FB :                            ; Convert "&Hnnnn" to FPREG
 7619/34FB :                            ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
 7620/34FB :                            ; Char is in A, NC if char is;<=>?@ A-z, CY is set if 0-9
 7621/34FB :                            HEXTFP:
 7622/34FB : 88 E6                      	LD	R8,R6
 7623/34FD : 98 E7                      	LD	R9,R7
 7624/34FF : 68 E2                      	LD	R6,R2
 7625/3501 : 78 E3                      	LD	R7,R3
 7626/3503 : 28 E8                      	LD	R2,R8
 7627/3505 : 38 E9                      	LD	R3,R9		; Move code string pointer to DE
 7628/3507 : 2C 00                      	LD	R2,#hi(0000H)
 7629/3509 : 3C 00                      	LD	R3,#lo(0000H)	; Zero out the value
 7630/350B : D6 35 2F                   	CALL	GETHEX		; Check the number for valid hex
 7631/350E : 7D 35 6E                   	JP	C,HXERR		; First value wasn't hex, HX error
 7632/3511 : 8B 05                      	JR	HEXLP1		; Convert first character
 7633/3513 :                            HEXLP:
 7634/3513 : D6 35 2F                   	CALL	GETHEX		; Get second and addtional characters
 7635/3516 : 7B 3A                      	JR	C,HEXIT		; Exit if not a hex character
 7636/3518 :                            HEXLP1:
 7637/3518 : 02 33                      	ADD	R3,R3
 7638/351A : 12 22                      	ADC	R2,R2		; Rotate 4 bits to the left
 7639/351C : 02 33                      	ADD	R3,R3
 7640/351E : 12 22                      	ADC	R2,R2
 7641/3520 : 02 33                      	ADD	R3,R3
 7642/3522 : 12 22                      	ADC	R2,R2
 7643/3524 : 02 33                      	ADD	R3,R3
 7644/3526 : 12 22                      	ADC	R2,R2
 7645/3528 : 42 03                      	OR	R0,R3
 7646/352A : CF                         	RCF			; Add in D0-D3 into L
 7647/352B : 38 E0                      	LD	R3,R0		; Save new value
 7648/352D : 8B E4                      	JR	HEXLP		; And continue until all hex characters are in
 7649/352F :                            ;
 7650/352F :                            GETHEX:
 7651/352F : A0 E6                      	INCW	RR6		; Next location
 7652/3531 : C2 06                      	LDC	R0,@RR6		; Load character at pointer
 7653/3533 : A6 E0 20                   	CP	R0,#' '
 7654/3536 : 6D 35 2F                   	JP	Z,GETHEX	; Skip spaces
 7655/3539 : 26 E0 30                   	SUB	R0,#30H		; Get absolute value
 7656/353C : FB 01                      	JR	NC,$+3
 7657/353E : AF                         	RET			; < "0", error
 7658/353F : A6 E0 0A                   	CP	R0,#0AH
 7659/3542 : 7B 09                      	JR	C,NOSUB7	; Is already in the range 0-9
 7660/3544 : 26 E0 07                   	SUB	R0,#07H		; Reduce to A-F
 7661/3547 : A6 E0 0A                   	CP	R0,#0AH		; Value should be $0A-$0F at this point
 7662/354A : FB 01                      	JR	NC,$+3
 7663/354C : AF                         	RET			; CY set if was < = > ? @
 7664/354D :                            NOSUB7:
 7665/354D : A6 E0 10                   	CP	R0,#10H		; > Greater than "F"?
 7666/3550 : EF                         	CCF
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 129 - 2023/10/26 22時18分50秒


 7667/3551 : AF                         	RET			; CY set if it wasn't valid hex
 7668/3552 :                            
 7669/3552 :                            HEXIT:
 7670/3552 : 88 E6                      	LD	R8,R6
 7671/3554 : 98 E7                      	LD	R9,R7
 7672/3556 : 68 E2                      	LD	R6,R2
 7673/3558 : 78 E3                      	LD	R7,R3
 7674/355A : 28 E8                      	LD	R2,R8
 7675/355C : 38 E9                      	LD	R3,R9		; Value into DE, Code string into HL
 7676/355E : 08 E6                      	LD	R0,R6		; Load DE into AC
 7677/3560 : 58 E7                      	LD	R5,R7		; For prep to
 7678/3562 : 70 E3                      	PUSH	R3
 7679/3564 : 70 E2                      	PUSH	R2
 7680/3566 : D6 1E B1                   	CALL	ACPASS		; ACPASS to set AC as integer into FPREG
 7681/3569 : 50 E2                      	POP	R2
 7682/356B : 50 E3                      	POP	R3
 7683/356D : AF                         	RET
 7684/356E :                            ;
 7685/356E :                            HXERR:
 7686/356E : 7C 26                      	LD	R7,#HX		; ?HEX Error
 7687/3570 : 8D 05 19                   	JP	ERROR
 7688/3573 :                            ;
 7689/3573 :                            ; BIN$(NN) Convert integer to a 1-16 char binary string
 7690/3573 :                            BIN:
 7691/3573 : D6 16 80                   	CALL	TSTNUM		; Verify it's a number
 7692/3576 : D6 0F 57                   	CALL	DEINT		; Get integer -32768 to 32767
 7693/3579 :                            BIN2:
 7694/3579 : 70 E5                      	PUSH	R5
 7695/357B : 70 E4                      	PUSH	R4		; Save contents of BC
 7696/357D : 2C 81                      	LD	R2,#hi(PBUFF)
 7697/357F : 3C 36                      	LD	R3,#lo(PBUFF)
 7698/3581 : 4C 11                      	LD	R4,#17		; One higher than max char count
 7699/3583 :                            ZEROSUP:			; Suppress leading zeros
 7700/3583 : 00 E4                      	DEC	R4		; Max 16 chars
 7701/3585 : 08 E4                      	LD	R0,R4
 7702/3587 : A6 E0 01                   	CP	R0,#01H
 7703/358A : 6B 08                      	JR	Z,BITOUT	; Always output at least one character
 7704/358C : 10 E7                      	RLC	R7
 7705/358E : 10 E6                      	RLC	R6
 7706/3590 : FB F1                      	JR	NC,ZEROSUP
 7707/3592 : 8B 04                      	JR	BITOUT2
 7708/3594 :                            BITOUT:
 7709/3594 : 10 E7                      	RLC	R7
 7710/3596 : 10 E6                      	RLC	R6		; Top bit now in carry
 7711/3598 :                            BITOUT2:
 7712/3598 : 0C 30                      	LD	R0,#'0'		; Char for '0'
 7713/359A : 16 E0 00                   	ADC	R0,#0		; If carry set then '0' --> '1'
 7714/359D : D2 02                      	LDC	@RR2,R0
 7715/359F : A0 E2                      	INCW	RR2
 7716/35A1 : 00 E4                      	DEC	R4
 7717/35A3 : EB EF                      	JR	NZ,BITOUT
 7718/35A5 : B2 00                      	XOR	R0,R0
 7719/35A7 : CF                         	RCF			; Terminating character
 7720/35A8 : D2 02                      	LDC	@RR2,R0		; Store zero to terminate
 7721/35AA : A0 E2                      	INCW	RR2		; Make sure PBUFF is terminated
 7722/35AC : D2 02                      	LDC	@RR2,R0		; Store the double zero there
 7723/35AE : 50 E4                      	POP	R4
 7724/35B0 : 50 E5                      	POP	R5
 7725/35B2 : 2C 81                      	LD	R2,#hi(PBUFF)
 7726/35B4 : 3C 36                      	LD	R3,#lo(PBUFF)
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 130 - 2023/10/26 22時18分50秒


 7727/35B6 : 8D 20 25                   	JP	STR1
 7728/35B9 :                            ;
 7729/35B9 :                            ; Convert "&Bnnnn" to FPREG
 7730/35B9 :                            ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
 7731/35B9 :                            BINTFP:
 7732/35B9 : 88 E6                      	LD	R8,R6
 7733/35BB : 98 E7                      	LD	R9,R7
 7734/35BD : 68 E2                      	LD	R6,R2
 7735/35BF : 78 E3                      	LD	R7,R3
 7736/35C1 : 28 E8                      	LD	R2,R8
 7737/35C3 : 38 E9                      	LD	R3,R9		; Move code string pointer to DE
 7738/35C5 : 2C 00                      	LD	R2,#hi(0000H)
 7739/35C7 : 3C 00                      	LD	R3,#lo(0000H)	; Zero out the value
 7740/35C9 : D6 35 FC                   	CALL	CHKBIN		; Check the number for valid bin
 7741/35CC : 7D 36 15                   	JP	C,BINERR	; First value wasn't bin, HX error
 7742/35CF :                            BINIT:
 7743/35CF : 26 E0 30                   	SUB	R0,#'0'
 7744/35D2 : 02 33                      	ADD	R3,R3
 7745/35D4 : 12 22                      	ADC	R2,R2		; Rotate HL left
 7746/35D6 : 42 03                      	OR	R0,R3
 7747/35D8 : CF                         	RCF
 7748/35D9 : 38 E0                      	LD	R3,R0
 7749/35DB : D6 35 FC                   	CALL	CHKBIN		; Get second and addtional characters
 7750/35DE : FB EF                      	JR	NC,BINIT	; Process if a bin character
 7751/35E0 : 88 E6                      	LD	R8,R6
 7752/35E2 : 98 E7                      	LD	R9,R7
 7753/35E4 : 68 E2                      	LD	R6,R2
 7754/35E6 : 78 E3                      	LD	R7,R3
 7755/35E8 : 28 E8                      	LD	R2,R8
 7756/35EA : 38 E9                      	LD	R3,R9		; Value into DE, Code string into HL
 7757/35EC : 08 E6                      	LD	R0,R6		; Load DE into AC
 7758/35EE : 58 E7                      	LD	R5,R7		; For prep to
 7759/35F0 : 70 E3                      	PUSH	R3
 7760/35F2 : 70 E2                      	PUSH	R2
 7761/35F4 : D6 1E B1                   	CALL	ACPASS		; ACPASS to set AC as integer into FPREG
 7762/35F7 : 50 E2                      	POP	R2
 7763/35F9 : 50 E3                      	POP	R3
 7764/35FB : AF                         	RET
 7765/35FC :                            ;
 7766/35FC :                            ; Char is in A, NC if char is 0 or 1
 7767/35FC :                            CHKBIN:
 7768/35FC : 18 FC                      	LD	R1,FLAGS
 7769/35FE : A0 E6                      	INCW	RR6
 7770/3600 : 19 FC                      	LD	FLAGS,R1
 7771/3602 : C2 06                      	LDC	R0,@RR6
 7772/3604 : A6 E0 20                   	CP	R0,#' '
 7773/3607 : 6D 35 FC                   	JP	Z,CHKBIN	; Skip spaces
 7774/360A : A6 E0 30                   	CP	R0,#'0'		; Set C if < '0'
 7775/360D : FB 01                      	JR	NC,$+3
 7776/360F : AF                         	RET
 7777/3610 : A6 E0 32                   	CP	R0,#'2'
 7778/3613 : EF                         	CCF			; Set C if > '1'
 7779/3614 : AF                         	RET
 7780/3615 :                            ;
 7781/3615 :                            BINERR:
 7782/3615 : 7C 28                      	LD	R7,#BN		; ?BIN Error
 7783/3617 : 8D 05 19                   	JP	ERROR
 7784/361A :                            ;
 7785/361A :                            JJUMP1:
 7786/361A : 8D 00 6C                   	JP	CSTART		; Go and initialise
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 131 - 2023/10/26 22時18分50秒


 7787/361D :                            ;
 7788/361D :                            MONOUT:
 7789/361D : 8D 00 4F                   	JP	CONOUT		; output a char
 7790/3620 :                            ;
 7791/3620 :                            MONITR:
 7792/3620 : 8D 00 00                   	JP	0000H		; Restart (Normally Monitor Start)
 7793/3623 :                            ;
 7794/3623 :                            INITST:
 7795/3623 : 0C 00                      	LD	R0,#0		; Clear break flag
 7796/3625 : 8C 80                      	LD	R8,#hi(BRKFLG)
 7797/3627 : 9C 9A                      	LD	R9,#lo(BRKFLG)
 7798/3629 : D2 08                      	LDC	@RR8,R0
 7799/362B : 8D 00 77                   	JP	INIT
 7800/362E :                            ;
 7801/362E :                            OUTNCR:
 7802/362E : D6 0A 6F                   	CALL	OUTC		; Output character in A
 7803/3631 : 8D 13 1B                   	JP	PRCRLF		; Output CRLF
 7804/3634 :                            ;
 7805/3634 :                            	END
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 132 - 2023/10/26 22時18分50秒


  Symbol Table (* = unused):
  --------------------------

 ABPASS :                      1EB3 C |  ABS :                         2BB6 C |
*ACCSUM :                      0F15 C |  ACPASS :                      1EB1 C |
 ADD30 :                       34DB C |  ADD301 :                      34F5 C |
 ADDEXP :                      2B08 C |  ADDIG :                       2E21 C |
 ADDPHL :                      2725 C |  ALLFOL :                      256D C |
 ALLFOL1 :                     256F C |  ANTVLU :                      14A3 C |
*ARCHITECTURE :                                      "aarch64-apple-darwin" - |
*ARET :                        33F9 C |  ARLDSV :                      1C6D C |
 ARLDSV1 :                     1C77 C |  ARREND :                      8127 - |
 ARRLP :                       2244 C |  ASC :                         250C C |
 ASCTFP :                      2D7E C |  ASPCS :                       139D C |
 ATN :                         339C C |  ATN1 :                        33C8 C |
 ATNTAB :                      33D4 C |  ATOH :                        0F80 C |
 BADINP :                      13C7 C |  BAKSTK :                       428 C |
 BAKTMP :                      24C5 C |  BASTXT :                      80AB - |
 BCDEFP :                      2C03 C |  BFREE :                        147 C |
 BIN :                         3573 C | *BIN2 :                        3579 C |
 BINERR :                      3615 C |  BINIT :                       35CF C |
 BINTFP :                      35B9 C |  BITOUT :                      3594 C |
 BITOUT2 :                     3598 C |  BKSP :                           8 - |
 BN :                            28 - |  BNORM :                       27E3 C |
 BNRMLP :                      27E9 C |  BRK :                         0E45 C |
 BRKFLG :                      809A - |  BRKLIN :                      811B - |
 BRKMSG :                       422 C |  BRKRET :                       137 C |
 BS :                            10 - |  BSERR :                       1CED C |
 BUFFER :                      80AE - |  BYT2ASC :                     34CE C |
 BYTSFT :                      2A21 C | *CASESENSITIVE :                  0 - |
 CFEVAL :                      1B32 C |  CHARTY :                      1A96 C |
 CHEKFN :                      2007 C |  CHKBIN :                      35FC C |
 CHKLTR :                      0F3E C |  CHKSTK :                       4AC C |
 CHKSUM :                      8097 - |  CHKSYN :                      0A49 C |
 CHKTYP :                      1686 C |  CHKTYP1 :                     16B1 C |
 CHR :                         252B C |  CLEAR :                       0FD4 C |
 CLOTST :                      0ABF C |  CLREG :                        790 C |
 CLRPTR :                       725 C |  CLS :                         33FE C |
 CMPFP :                       2C87 C |  CMPLG1 :                      1991 C |
 CMPLOG :                      198F C |  CMPNUM :                      2C5A C |
 CMPRES :                      1A16 C |  CMPSTR :                      19E8 C |
 CN :                            20 - |  CNVNUM :                      2D92 C |
 COLD :                          5F C |  COMMAN :                      8090 - |
 COMPL :                       2894 C |  CONCAT :                      2399 C |
 CONEXP :                      2DCD C |  CONIN :                         3C C |
 CONINIT :                       22 C |  CONOUT :                        4F C |
 CONPOS :                      27DE C |  CONST :                         49 C |
*CONSTPI :        3.141592653589793 - |  CONT :                        0EC4 C |
 CONTAD :                      8121 - |  CONVAR :                      1814 C |
 COPY :                          81 C |  COS :                         32ED C |
 COUNT :                       0B86 C |  CPDEHL :                      0A3D C |
 CPYLIT :                       91E C |  CR :                            0D - |
 CRARLP :                      1D28 C |  CREARY :                      1CF2 C |
 CRESTR :                      11F1 C |  CRESTR1 :                     11F5 C |
 CRNCLP :                       7FE C |  CRTMST :                      205E C |
 CRTST :                       2077 C |  CRTSTE :                      2097 C |
 CRUNCH :                       7F0 C |  CS :                            0C - |
 CSTART :                        6C C |  CTLOFG :                      8092 - |
 CTRLC :                          3 - |  CTRLG :                          7 - |
 CTRLO :                         0F - |  CTRLQ :                         11 - |
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 133 - 2023/10/26 22時18分50秒


 CTRLR :                         12 - |  CTRLS :                         13 - |
 CTRLU :                         15 - |  CUROPR :                      8112 - |
 CURPOS :                      80F8 - |  DATA :                        113E C |
*DATE :                "2023/10/26" - |  DATFLG :                      80FB - |
 DATLIN :                      8116 - |  DATSNR :                       4EB C |
 DCBCDE :                      2CFB C |  DDERR :                        50B C |
 DEEK :                        3432 C |  DEF :                         1ED0 C |
 DEFSIZ :                      1D35 C |  DEINT :                       0F57 C |
 DEL :                           7F - |  DELCHR :                       968 C |
 DEPINT :                      0F51 C |  DETHL4 :                      2C24 C |
 DETHLB :                      2C26 C |  DIGTXT :                      2F77 C |
 DIM :                         1A52 C |  DIMRET :                      1A46 C |
 DINPOS :                      0AB5 C |  DIV :                         2A38 C |
 DIV1 :                        8050 - |  DIV10 :                       2A2A C |
 DIV2 :                        8057 - |  DIV3 :                        805E - |
 DIV4 :                        8062 - |  DIVLP :                       2A8F C |
 DIVSUP :                      804E - |  DOAGN :                        7D8 C |
 DOCOM :                       134E C |  DODEL :                        937 C |
 DOEBIT :                      3007 C |  DOFN :                        1F2D C |
 DOKE :                        344A C |  DONULL :                      1325 C |
 DOSPC :                       1396 C |  DOTAB :                       1371 C |
 DPOINT :                      2DC9 C |  DTSTR :                       207D C |
 DVBCDE :                      2A40 C |  DZ :                            14 - |
 DZERR :                        503 C |  ECHDEL :                       955 C |
 ECHDEL1 :                      957 C |  EDIGIT :                      2E68 C |
 ENDBUF :                       928 C |  ENDCON :                      2DED C |
 ENDDIM :                      1E46 C |  ENDINP :                      1313 C |
 ENDNAM :                      1A8A C |  ENDPRG :                      0E6F C |
 ENFMEM :                       4C6 C |  ENFMEM1 :                      4CA C |
 ERRIN :                        543 C |  ERRLIN :                      811F - |
 ERRMSG :                       410 C |  ERROR :                        519 C |
 ERRORS :                       37E C |  ESC :                           1B - |
 EVAL :                        16B8 C |  EVAL1 :                       16BC C |
 EVAL2 :                       16C8 C |  EVAL3 :                       16D2 C |
 EVLPAR :                      17EE C |  EVNOT :                       1A27 C |
 EXCUTE :                      0D63 C |  EXP :                         314B C |
 EXPLP :                       2DB7 C |  EXPTAB :                      31AF C |
 EXPTEN :                      302A C |  EXTIG :                       1560 C |
*FALSE :                          0 - |  FANDT :                       15B2 C |
 FC :                             8 - |  FCERR :                       0F7B C |
 FDTLP :                       1571 C |  FINDEL :                      1DE6 C |
 FLAGS :                        0FC - |  FLGDIF :                      2B91 C |
 FLGREL :                      2B9B C |  FNARG :                       812D - |
 FNCTAB :                       1C8 C |  FNDARY :                      1C83 C |
 FNDARY1 :                     1C87 C |  FNDELP :                      1DF0 C |
 FNDELP1 :                     1DF4 C |  FNDEND :                       6B7 C |
 FNDNUM :                      26E8 C |  FNDTOK :                      0B49 C |
 FNDVAR :                      1B07 C |  FNDWRD :                       836 C |
 FNOFST :                      1844 C |  FNRGNM :                      812B - |
 FNTHR :                       1B1E C |  FNVAL :                       18B3 C |
 FOPRND :                      1718 C |  FOR :                         0BF8 C |
 FORFLG :                      8118 - |  FORFND :                      0C60 C |
 FORSLP :                      0C22 C |  FPADD :                       273B C |
 FPBCDE :                      2BEE C |  FPEXP :                       8134 - |
 FPINT :                       2CBC C |  FPMULT :                      2980 C |
 FPREG :                       8131 - |  FPROND :                      285C C |
 FPSINT :                      0F4B C |  FPTHL :                       2C20 C |
 FRE :                         1E55 C |  FRENUM :                      1EA7 C |
 FRMEVL :                      1817 C | *FULLPMMU :                       1 - |
 GARBGE :                      219F C |  GARBLP :                      21A9 C |
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 134 - 2023/10/26 22時18分50秒


 GETCHR :                      0DAD C |  GETCMD :                       57C C |
 GETHEX :                      352F C |  GETINP :                      33FA C |
 GETINT :                      26EB C |  GETLEN :                      24F8 C |
 GETLIN :                       97F C |  GETLN :                       0F86 C |
 GETNUM :                      167D C |  GETNXT :                       86D C |
 GETSTR :                      2465 C |  GETVAR :                      1A60 C |
 GETVAR1 :                     1A63 C |  GNXARY :                      2240 C |
 GOFUNC :                      18CA C |  GOSUB :                       1086 C |
 GOTO :                        10B5 C |  GRBARY :                      229B C |
 GRBDON :                      2127 C |  GRBDON1 :                     212D C |
 GRBLP :                       21D3 C |  GSTRCU :                      2468 C |
 GSTRDE :                      247E C |  GSTRHL :                      2472 C |
*GTFLNM :                      2514 C |  GTFNAM :                      1A6B C |
 GTLNLP :                      0F8A C |  GTSIXD :                      2F1C C |
 GTVLUS :                      1456 C |  HALF :                        307E C |
 HALFPI :                      3359 C | *HAS64 :                          1 - |
*HASFPU :                         0 - | *HASPMMU :                        0 - |
 HEX :                         3479 C |  HEX1 :                        349C C |
 HEX2 :                        34A0 C |  HEX3 :                        34B3 C |
 HEX4 :                        34B7 C |  HEXIT :                       3552 C |
 HEXLP :                       3513 C |  HEXLP1 :                      3518 C |
 HEXTFP :                      34FB C |  HX :                            26 - |
 HXERR :                       356E C |  ID :                            16 - |
 IDTEST :                      1FE7 C |  IF :                          124E C |
 IFGO :                        125F C |  IFJMP :                       0D6E C |
 IMR :                          0FB - |  INCHL :                       2C19 C |
 INCLEN :                      0AAE C |  INDFND :                       472 C |
 INEWLN :                       620 C |  INIT :                          77 C |
 INITAB :                       3A8 C |  INITBE :                       410 C |
 INITST :                      3623 C |  INMSG :                        417 C |
 INP :                         2694 C |  INPBIN :                      14F4 C |
 INPBRK :                      0E68 C |  INPBRK1 :                     0E6B C |
 INPORT :                      808C - |  INPSUB :                      808B - |
 INPUT :                       13E1 C |  INRNG :                       2F2F C |
*INSUPMODE :                      0 - |  INT :                         2D0C C |
*INT0 :                           0 C | *INT1 :                           2 C |
*INT2 :                           4 C | *INT3 :                           6 C |
*INT4 :                           8 C | *INT5 :                          0A C |
 INTVAR :                       74F C |  INVSGN :                      2BBC C |
*IPR :                          0F9 - |  IRQ :                          0FA - |
 ITMSEP :                      14CA C | *JJUMP1 :                      361A C |
 JSTZER :                      303C C |  KILFOR :                      1661 C |
 KILIN :                        979 C |  LCRFLG :                      80F9 - |
 LEFT :                        254A C |  LEN :                         24F0 C |
 LET :                         1163 C |  LETNUM :                      1216 C |
 LETSTR :                      11A5 C |  LF :                            0A - |
 LFRGNM :                      2675 C |  LINEAT :                      80A9 - |
 LINEIN :                      2E7E C |  LINES :                       340F C |
 LINESC :                      8093 - |  LINESN :                      8095 - |
 LINFND :                       5E7 C |  LIST :                        0ADC C |
 LISTLP :                      0AF0 C | *LISTON :                         1 - |
 LOADFP :                      2C07 C |  LOG :                         28FA C |
 LOGTAB :                      28ED C |  LOKFOR :                       432 C |
 LOOPST :                      8114 - |  LS :                            1C - |
 LSTBIN :                      8119 - |  LSTLP2 :                      0B31 C |
 LSTLP3 :                      0B34 C |  LSTRAM :                      80FC - |
 LSTRND :                      8087 - |  LTSTND :                      150D C |
 LWIDTH :                      808F - | *MACEXP :                         7 - |
 MAKINT :                      26EE C |  MAKNUM :                      2F54 C |
 MANLP :                       2D9F C |  MATCH :                        8C5 C |
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 135 - 2023/10/26 22時18分50秒


 MEMMSG :                       196 C |  MID :                         25BC C |
 MID1 :                        255E C |  MIDNUM :                      2685 C |
 MINCDE :                      27B9 C |  MINUS :                       17F6 C |
 MKTMST :                      205B C |  MLDBLP :                      2D4B C |
 MLDEBC :                      2D3D C |  MLOOP :                        0A8 C |
 MLSP10 :                      2B51 C |  MO :                            24 - |
*MOMCPU :                      8601 - | *MOMCPUNAME :               "Z8601" - |
 MONITR :                      3620 C |  MONOUT :                      361D C |
 MORDT :                       151B C |  MORINP :                       98D C |
 MOVBUF :                       682 C |  MOVDIR :                       8F0 C |
 MOVLP :                        49B C |  MOVSTR :                       487 C |
 MOVUP :                        484 C |  MRPRNT :                      1271 C |
*MSIZE :                        0A4 C |  MUL8LP :                      29D8 C |
 MULLN2 :                      296E C |  MULT :                        2978 C |
 MULT8 :                       29C9 C |  MULTEN :                      2E0F C |
 MULVAL :                      8143 - |  MVSTPT :                      1207 C |
 NEDMOR :                      1452 C |  NEGAFT :                      3094 C |
 NEMEM :                        13D C | *NESTMAX :                      100 - |
 NEW :                          722 C |  NEXITM :                      13AA C |
 NEXT :                        15BE C |  NEXT1 :                       15C2 C |
 NF :                             0 - |  NFERR :                        507 C |
*NMIFLG :                      8099 - |  NOCHNG :                       8B9 C |
 NOENED :                      3046 C |  NOLIN :                       0EA9 C |
 NOMADD :                      2A0B C |  NOMLAD :                      2D78 C |
 NOPMPT :                      1404 C |  NOPMPT1 :                     1408 C |
 NORMAL :                      280F C |  NOSPC :                        8AC C |
 NOSUB7 :                      354D C |  NOSWAP :                      277D C |
 NOTAMP :                      17C7 C |  NOTSTR :                      1AAC C |
 NOXOR :                       26C3 C |  NSCFOR :                      1AC2 C |
 NULFLG :                      8091 - |  NULL :                        0F08 C |
 NULLP :                       1334 C |  NULLS :                       808E - |
 NUMASC :                      2EA8 C |  NXTARY :                      1CBC C |
 NXTBYT :                       894 C |  NXTCHR :                       911 C |
 NXTDAT :                      8129 - |  NXTDTA :                      113A C |
 NXTITM :                      143B C |  NXTITM1 :                     143D C |
 NXTOPR :                      811D - |  NXTSTL :                      1146 C |
 NXTSTT :                      114C C |  OD :                             6 - |
 OKMSG :                        41C C |  OM :                            0C - |
 OMERR :                        4E6 C |  ON :                          1226 C |
 ONGO :                        1239 C |  ONGOLP :                      123B C |
 ONJMP :                       0D71 C |  OPNPAR :                      16B4 C |
 OPRND :                       1795 C |  OS :                            1A - |
 OTKLN :                        976 C |  OTPORT :                      804C - |
 OUTC :                        0A6F C |  OUTEXP :                      3028 C |
 OUTIT :                       0A2F C |  OUTNBS :                      0A35 C |
 OUTNCR :                      362E C |  OUTSUB :                      804B - |
 OUTWRD :                      0B57 C |  OV :                            0A - |
 OVERR :                        513 C |  OVTST1 :                      2B3B C |
 OVTST2 :                      2B44 C |  OVTST3 :                      2B47 C |
*P0 :                             0 - |  P01M :                         0F8 - |
*P1 :                             1 - | *P2 :                             2 - |
 P2M :                          0F6 - | *P3 :                             3 - |
 P3M :                          0F7 - |  PADD :                        2E5D C |
*PADDING :                        1 - |  PAND :                        1900 C |
 PAND1 :                       1903 C |  PASSA :                       1EC8 C |
 PBUFF :                       8136 - |  PEEK :                        2701 C |
 PEND :                        0E55 C |  PEND1 :                       0E58 C |
 PHLTFP :                      2BEB C |  PLUCDE :                      2875 C |
 PNORM :                       2821 C |  POINT :                       809E - |
 POKE :                        2709 C |  POPAF :                       217D C |
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 136 - 2023/10/26 22時18分50秒


 POPHL :                       24C0 C |  POPHRT :                      2A1C C |
 POPNOK :                       566 C |  POR :                         18FA C |
 POR1 :                        1966 C |  POS :                         1EC2 C |
 POSINT :                      0F4E C |  POUT :                        26A3 C |
 POWER :                       30B0 C |  POWER1 :                      30C9 C |
 POWER2 :                      3107 C |  POWERS :                      3082 C |
 PRCRLF :                      131B C |  PRE0 :                         0F5 - |
*PRE1 :                         0F3 - |  PRINT :                       1276 C |
 PRITAB :                       369 C |  PRNTHL :                      2E8D C |
 PRNTLP :                      1279 C |  PRNTNB :                      12F2 C |
 PRNTOK :                       56A C |  PRNTST :                      12F8 C |
 PRNUMS :                      2100 C |  PROCES :                       9B1 C |
 PROGND :                      8123 - |  PROGST :                      8146 - |
 PROMPT :                       7E3 C |  PRS :                         2102 C |
 PRS1 :                        2105 C |  PRSLP :                       210C C |
 PSET :                        80A1 - |  PSUB :                        2730 C |
 PTRLP :                        6A0 C |  PUTBUF :                      0A12 C |
 PUTCTL :                      0A18 C |  PUTFID :                      0D0E C |
 QTSTLP :                      2083 C |  QTSTR :                       2079 C |
 QUARTR :                      335D C |  RAMTOP :                      8000 - |
 RD :                            12 - |  READ :                        1428 C |
 READFG :                      811A - |  REDO :                        13B4 C |
 REGPTR :                        70 - | *RELAXED :                        0 - |
 REM :                         1142 C |  REM1 :                        1144 C |
 RESDIV :                      2AB6 C |  RESDIV1 :                     2ABE C |
 RESDIV2 :                     2ACA C |  RESEED :                      32D4 C |
 RESET :                       80A4 - |  RESTNL :                      0E03 C |
 RESTOR :                      0DC5 C |  RESZER :                      2805 C |
 RETADR :                      1BBD C |  RETINT :                      2BA1 C |
 RETLIN :                      1128 C |  RETNAD :                       8DA C |
 RETNUL :                      1BCE C |  RETNUM :                      180C C |
 RETREL :                      2B8D C |  RETREL1 :                     2B8F C |
 RETURN :                      10F2 C |  RG :                             4 - |
 RIGHT :                       25AA C |  RIGHT1 :                      2550 C |
 RINPUT :                      809B - |  RLTLP :                       16EE C |
 RND :                         3232 C |  RND1 :                        329B C |
 RND2 :                        32CA C |  RNDTAB :                      32E1 C |
 RNGTST :                      304D C |  ROMTOP :                         0 - |
 RONDB :                       2841 C |  RONDUP :                      283F C |
 ROUND :                       2721 C |  RP :                           0FD - |
 RSCALE :                      2E57 C |  RSLNBK :                      0BE1 C |
 RSTSTR :                      25E6 C |  RUN :                         1079 C |
 RUNCNT :                      0D12 C |  RUNFST :                       743 C |
 RUNLIN :                      10B1 C |  SAVEXP :                      2808 C |
 SAVSTP :                      0CE8 C |  SAVSTR :                      2033 C |
 SBSCPT :                      1BEB C |  SCALE :                       28BA C |
 SCALLP :                      28BC C |  SCALMI :                      2DD5 C |
 SCALPL :                      2E0C C |  SCNEND :                      2347 C |
 SCPTLP :                      1C07 C |  SDIV0 :                          1 - |
 SDIV1 :                          1 - |  SEARCH :                       85F C |
 SEED :                        8063 - |  SETIO :                       26D2 C |
 SETLIN :                      0B69 C |  SETLIT :                       903 C |
 SETPTR :                       68F C |  SETTOP :                       0C7 C |
 SFTPRG :                       604 C |  SGN :                         2B98 C |
 SGNEXP :                      18DC C |  SGNRES :                      8135 - |
 SHRITE :                      28CD C |  SHRLP :                       28D2 C |
 SHRT1 :                       28DC C |  SIGNON :                       156 C |
 SIGNS :                       2C34 C |  SIN :                         32F4 C |
 SIN1 :                        3335 C |  SINIT :                         5C C |
 SINTAB :                      3361 C |  SIO :                          0F0 - |
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 137 - 2023/10/26 22時18分50秒


 SIXDIG :                      2EE0 C |  SMPVAR :                      2209 C |
 SMSER1 :                      31E9 C |  SN :                             2 - |
 SNERR :                        4FF C |  SPCFST :                      2EBE C |
 SPCLP :                       13A2 C |  SPH :                          0FE - |
 SPL :                          0FF - |  SQR :                         30A6 C |
 SRCHLN :                       6D9 C |  SRCHLP :                       6E3 C |
 SSTSA :                       2436 C |  ST :                            1E - |
 STACK :                       80B3 - |  STAKFP :                      2BC8 C |
 STALL :                       0E35 C |  STARTB :                        65 C |
 STKTHS :                      1765 C |  STLOOK :                      81AA - |
 STOP :                        0E4D C |  STORED :                      1023 C |
 STPOOL :                      22C7 C |  STR :                         201F C |
 STR1 :                        2025 C |  STRADD :                      22CE C |
 STRBOT :                      8110 - |  STRENT :                      14CE C |
 STRSPC :                      80A7 - |  STTLIN :                      1304 C |
 SUBCDE :                      2738 C |  SUBPHL :                      272B C |
 SUMLP :                       31F5 C |  SUMLP1 :                      31FB C |
 SUMSER :                      31D0 C |  SUPTLZ :                      2FF5 C |
 SVNAM2 :                      1A88 C |  SVSTAD :                      206A C |
 T0 :                           0F4 - | *T1 :                           0F2 - |
 TAN :                         3376 C |  TESTOS :                      2184 C |
 TESTR :                       2123 C |
*TIME :               "22\-026\-103\-12618\-027\-120\-12250\-025\-089\-110" - |
 TM :                            18 - |  TMERR :                        517 C |
 TMPSTR :                      810C - |  TMR :                          0F1 - |
 TMSTPL :                      8100 - |  TMSTPT :                      80FE - |
 TOPOOL :                      2543 C |  TOSTRA :                      2454 C |
*TRUE :                           1 - |  TRYAGN :                      2F97 C |
 TSALP :                       2455 C |  TSTACK :                      80ED - |
 TSTBRK :                      0E1C C |  TSTNUM :                      1680 C |
 TSTOPL :                      20BE C |  TSTRED :                      1971 C |
 TSTREM :                       909 C |  TSTSGN :                      2B76 C |
 TSTSTR :                      1685 C |  TTYLIN :                       97F C |
 TYPE :                        80FA - | *UARTCR :                     0E001 - |
*UARTDR :                     0E000 - |  UF :                            22 - |
 UFERR :                        50F C |  UL :                            0E - |
 ULERR :                       10ED C |  UNITY :                       28E9 C |
 UPDATA :                      0E05 C |  USR :                         8048 - |
 VAL :                         261F C |  VAL1 :                        265C C |
 VAL2 :                        2667 C |  VAL3 :                        266A C |
 VAREND :                      8125 - | *VERSION :                     142F - |
 WAIT :                        26A9 C |  WAITLP :                      26C7 C |
*WARM :                          62 C |  WARMST :                       131 C |
 WIDTH :                       3403 C |  WORDS :                        200 C |
 WORDTB :                       31F C |  WRKSPC :                      8045 - |
 XXXXX :                        144 C |  ZDATA :                         83 - |
*ZDIV :                         0AF - |  ZEND :                          80 - |
 ZEQUAL :                       0B4 - |  ZERARY :                      1D8F C |
 ZERBYT :                       41B - |  ZEROLP :                      1BA5 C |
 ZEROSUP :                     3583 C |  ZFN :                          0A7 - |
 ZFOR :                          81 - |  ZGOSUB :                        8C - |
 ZGOTO :                         88 - |  ZGTR :                         0B3 - |
 ZLEFT :                        0CF - |  ZLTH :                         0B5 - |
 ZMINUS :                       0AD - |  ZNEW :                         0A4 - |
 ZNOT :                         0AA - |  ZONELP :                      1366 C |
 ZOR :                          0B2 - |  ZPLUS :                        0AC - |
*ZPOINT :                       0C7 - |  ZPRINT :                        9E - |
 ZREM :                          8E - |  ZSGN :                         0B6 - |
 ZSPC :                         0A8 - |  ZSTEP :                        0AB - |
 ZTAB :                         0A5 - |  ZTHEN :                        0A9 - |
 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 138 - 2023/10/26 22時18分50秒


*ZTIMES :                       0AE - |  ZTO :                          0A6 - |

    713 symbols
     46 unused symbols

 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 139 - 2023/10/26 22時18分50秒


  Defined Functions:
  ------------------

HI                                    | LO                                   

 AS V1.42 Beta [Bld 250] - Source File z8basic.asm - Page 140 - 2023/10/26 22時18分50秒


  Code Pages:
  ----------

STANDARD (0 changed characters)

1 code page

0.04 seconds assembly time

   7806 lines source file
      2 passes
      0 errors
      0 warnings
